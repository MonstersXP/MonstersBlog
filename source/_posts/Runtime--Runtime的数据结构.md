---
title: Runtime--Runtime的数据结构(一)
date: 2017-08-08 11:01:18

description: Runtime 的基础数据结构：objc_object、objc_class、isa 指针、method_t

categories: Runtime
tags: [Objective-C]
---

***
[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)
[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)
[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)
[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)
[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)
***

**目录**

* objc_object
* objc_class
* isa 指针
* objc_class 中的成员结构
* Runtime 的基础数据结构总结图

## objc_object

![](/imag/objc_object.png)

我们平时使用的所有的对象都是 id 类型，对应到 Runtime 中就是 objc_object 的结构体，这个结构体中主要包含以下几个成员部分：

1. isa_t：  isa_t 是一个共用体
2. 关于 isa 操作的相关方法：提供了 isa 操作相关的一些方法，比如通过 objc_object 这个结构体来获取它的 isa 所指向的类对象，包括通过类对象的 isa 指针获取它的元类对象一些遍历的方法
3. 弱引用相关方法：比如说，标记一个对象，它是否曾经有过弱指针
4. 关联对象相关方法：比说，这个对象，为它设置了一些关联属性，关联属性的一些方法也体现在 objc_object 结构体当中
5. 内存管理相关：比如， 在 MRC 下面经常使用到的 retain，relese，包括 ARC，MRC 下面都可以用到的 艾特aotorelesepool 


## objc_class


![](/img/objc_class.png)

在 OC 当中使用的类对应的是 Runtime 中就是 objc_class 的结构体，objc_class 继承自 objc_object （class 也是一个对象，称类对象）

objc_class包含：

1. 拥有一个 superClass 指针，对指向的类型也是 class ，如果说是一个类对象的话，那么它的 superClass 指针指向的就是他的父类对象，也就是平时说的类与父类的关系，实际上就是通过 objc_class 中 superClass 这么一个成员变量来定义的
2. 包含一个cache_t 成员变量，cache_t表达了方法缓存的一个结构，在消息传递的过程中，或使用方法缓存的数据结构
3. 关于 class_data_bits_t 数据结构：实际上我们关于一个类所定义的一些变量、属性、包括他的一些方法都在 bits 成员结构当中

## isa 指针

### isa指针相关说明

![](/img/isa指针.png)

isa指针是 C++ 当中的一个共用体，在 OC 中是定义成了 isa_t 的名称

对于一个共用体来说，无论是在64位架构上面还是在32位架构上面，实际上都是32个0或者1的数字，或者64个0或者1的数字，大多数及其都是64位的

isa指针分两种类型，一种是指针型的 isa ，一种是非指针型的 isa

1. 指针型的 isa 64位的0或者说1它的整体内容代表的是 Class 的地址（比如对于使用一个 objc_object 这么一个对象的时候，可以通过 isa 的内容来获取到它的类对象的地址）
2. 非指针型的 isa 的值的部分代表 Class 的地址（比如针对64位架构上面的am（没听清）架构，可能是对应的其中某一部分的33位或者44位所代表的值，意味着是 Class 的地址，不是说整个64位都代表 Class 的地址）这样做的目的是因为在寻址过程当中，实际上只有三四十位的位数就可以保证我们寻找到所有的 Class 的地址，多出的这些位可以用来存储其他的相关内容，来达到节省内存的目的

### isa 指向

![](/img/isa指向.png)

关于对象，它指向的是类对象

* 比如拥有一个实例，实例就是 OC 中对应的 id 类型，表述在 Runtime 中就是 objc_object ，objc_object 当中有一个 isa 指针，对于实例来说它的 isa 指针就指向他对应的 class ，或者说称之为**类对象**

关于类对象，isa 的指向是其元类对象

* class 代表的是 objc_class ,而 objc_class 又继承自 objc_object，所以 class 实际上也是一种对象，称之为类对象，那么class当中由于继承自 objc_object ，所以也有一个 isa 指针，这个 isa 指针指向的是其元类对象，那么在进行方法调用的时候，调用一个实例的实例方法实际上是通过 isa 指针到它的类对象当中去进行方法查找，如果调用的是一个类方法，那么是通过类对象的 isa 指向他的元类对象当中去查找

## objc_class 中的成员结构

### cache_t

* 用于**快速**查找方法执行函数

* 是可**增量扩展**的**嘻哈表**结构

* 是**局部性原理**的最佳应用

1. 实际上是用于快速查找方法执行函数的机构，比如说在调用一个方法的时候，如果有一个缓存，就不用到它对应的方法列表当中去逐一遍历去查找这个方法的具体实现，可以提高方法调用的速度，或者说消息传递的速度

2. 是可增量扩展的哈希表结构。增量扩展体现在，当这个结构存储的量在增大的过程中，他也会逐渐去增量的扩大它的内存空间来支持更多的缓存，用哈希表来实现数据结构主要是为了提高查找效率

3. cache_t 这个数据结构实际上是计算机局部性原理的最佳应用，局部性原理指的是，一般在调用放大的时候，可能往往调用的就那么几个方法，也就是这几个方法是调用频次最高的，这个时候把调用频次最高的方法放到缓存当中，下次的命中率就会更高一些，这个就是局部性原理的一个简单说明

***cache_t 具体的数据结构说明***

![](/img/cache_t具体的数据结构说明.png)

可以理解是由一个数组来实现的，数组中每一个对象都是 bucke_t 这么一个结构体来封装的，对于bucke_t 它有两个主要的成员变量，第一个是 key 第二个是 IMP ，key 对应 OC 当中的 selecter，在调用一个方法的时候，他实际上是一个选择器 SEL ，可以通过方法选择器的名称来寻找一个方法的具体实现，IMP 可以理解为是一个无类型的函数指针
那么比如说给你一个 key，可以通过哈希查找算法来定位当前这个key所对应的 bucket_t 的数据结构位于数组当中的哪个位置，然后当定位到这个位置之后，就可以提取 bucket_t 里面的具体函数的实现（IMP）来调用函数


### class-data-bits-t

* **class-data-bits-t** 主要是对 **class-rw-t** 的封装

* **class-rw-t** 代表了类相关的**读写**信息、对 class_ro_t 的封装

* **class-ro-t** 代表了类相关的**只读**信息

class-rw-t 代表了类相关的读写信息，比如说给类添加的一些分类当中的一些方法或者说属性，以及协议都在 class-rw-t 当中（rw 是 read write 的简写）

### class-rw-t

![](/img/class_rw_t.png)

class_rw_t 主要包含第一部分 class_ro_t，第二部分 protocols（协议），第三部分 properties（属性），第四部分methods（方法），在给分类创建的协议属性方法都是在这三个数据结构当中，这三个数据结构是一个二维数组，都继承自 list_array_tt 这么样一个结构，对于二位数组解释：以 methods 为例，数组（一维）当中每一个元素又是一个数组（二维），二维数组当中所装载的内容是 method_t 数据结构 

比说添加了一个分类 A ，那么分类 A 当中的所有的方法以一个列表的形势作为二维数组的其中一个元素，第二个分类当中的方法列表就作为二维数组的第二个元素，以此类推

### class_ro_t

![](/img/class_ro_t.png)

class_ro_t 主要由以下几个部分组成

1. 第一个是关于这个类的类名
2. ivars，就是我们声明或者定义的一些类的成员变量
3. 第三个是类的属性
4. 第四个是类遵从的一些协议
5. 最后一个是这个类添加的一些方法列表

关于 ivars ，properties，protocols，methodList 实际上都是一维数组，这里的方法列表等内容和 class_rw_t 中的方法列表等内容是有区别的，前者是一维数组，后者是二维数组，同样的在 class_rw_t 当中，方法列表当中存储的内容一般情况下都是分类当中添加的一些方法内容，关于 class_ro_t 当中这样的一维数组的方法列表当中存储的就是我们原始定义的或者说添加的一些类的方法列表内容

那么 methodList 当中所对应的每一个数组原元素实际上也是 method_t 数据结构 ，method_t 实际上是对一个方法的抽象说明

### method_t

![](/img/method_t.png)

### type Encodings 

![](/img/typeEncodings.png)

const char*类型的 types 成员属性，实际上它的表达结构大致是这样的

首先它是不可变的字符指针，它所指向的字符组成结构大致是这样的，首先第一个位置永远都是函数的返回值（为什么是在第一个位置：在定义一个函数的时候函数的参数可以有多个，但是返回值永远只有一个，没有返回值可以成为 void 类型，所以返回值在 tpye 中占第一个位置）后续可以有参数一，参数二，直到参数n，后面这些就是这个函数每一个参数的参数类型，那么就有返回值类型以及函数每个参数类型所组成的字符串来表达一个函数它的返回值是什么类型的，它的参数有几个，以及每一个参数的类型是什么

举一个例子：比如在 OC 中的一个方法 -（void）aMethod；这个函数它的返回值是 void 类型，没有参数，它对应的 type 值是 v@：，v@：就是 method_t 当中 types 所储存的内容，v 对应的是返回值 @，对应的是参数1，：对应的是参数2 ，它具体代表的含义是 v 对应的是函数的返回值是 void 类型的，@ 对应的是 OC 当中的 id 类型，它表示的是一个对象，在后续的学习当中我们可以知道，我们所调用的一个方法或者说消息传递，到达 Runtime 层面的时候都是转化成 objc_messSend 函数调用，这个函数调用的第一个和第二个参数是固定的并且是不可变的，第一个参数必须是 id 类型的，也就是消息的接收者或者称之为 self ，第二个参数是一个：，：所表达的含义是 SEL，表示这个参数是一个选择器。所以说一个 method_t 当中的 types 成员变量所表达的实际上是函数的返回值类型，以及参数个数，包括每个参数的类型。

## Runtime 的基础数据结构总结图

![](/img/Runtime的基础数据结构总结图.png)
