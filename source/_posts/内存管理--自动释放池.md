---
title: 内存管理(五)--自动释放池
date: 2018-07-08 01:01:18

description: 自动释放池

categories: 内存管理
tags: [Objective-C]
---

***
[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)
[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)
[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)
[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)
[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)
[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)
[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)
***

### 思考一个问题先

 
 ```
 - (void)viewDidLoad
 {
    [super viewDidLoad];
    
    NSMutableArray *array = [NSMutableArray array];
    NSLog(@"%@",array);
 }
 ```
 
 在 viewDidLoad 方法中通过 [NSMutableArray array] 创建了一个数组对象，然后在控制台打印它的值
 
 
**思考：这个 array 对应的内存是在什么时机释放的？**

**思考：AutoreleasePool 的实现原理是怎样的？**

**思考：AutoreleasePool 为何可以嵌套使用？**

## 自动释放池

**首先来看 @autoreleasepool{} 经过编译器编译后会变成什么**

```
编译器会将 @autoreleasepool{} 改写为：

void *ctx = objc_autoreleasePoolPush();

{}中的代码

objc_autoreleasePoolPop(ctx)

```

第一段是 objc_autoreleasePoolPush 这个函数调用，是没有参数的，返回值是一个无类型的指针
中间是花括号中所添加的代码
之后会调用 objc_autoreleasePoolPop 函数，这个函数的入参就是前一个函数 objc_autoreleasePoolPush 返回结果

### objc_autoreleasePoolPush 的内部实现

![](/img/objc_autoreleasePoolPush的内部实现.png)

这个函数在内部当中会调用一个 C++ 类的方法，这个类叫 ，是一个很关键的数据结构，调用它里面的一个 push 方法，这个方法的参数和返回值和前面这个方法的参数和返回值是一致的

### objc_autoreleasePoolPop 的内部实现

![](/img/objc_autoreleasePoolPop的内部实现.png)

这个函数最终也是会调用 objc_autoreleasePoolPage 当中的一个 pop 函数，参数和 objc_autoreleasePoolPop 函数的参数是一致的

**一次 pop 实际上是一次批量的 pop 操作**
理解：在 autoreleasepool 花括号当中所包含的所有对象都会添加到自动释放池当中，那么当进行 pop 之后，是花括号中所有的对象都会被发送一次 release 消息，所以解释为是一次批量的 pop 操作

## 自动释放池的数据结构

#### 1.自动释放池

思考：什么是自动释放池或者说自动释放池的实现结构是怎样的？

* 是以**栈**为结点通过**双向链接**的形式组合而成

* 是和**线程**一一对应的

#### 2.双向链表

![](/img/双向链表.png)

#### 3.栈

![](/img/栈.png)

## AutoreleasePoolPage 类（C++ 的类）

![](/img/AutoreleasePoolPage.png)

这个类的组成结构主要有四个成员变量

* 第一个是 id* 类型的 next，实际上就是指向栈当中下一个可填充位置
* 之后是两个 AutoreleasePoolPage 类型的成员变量，分别为 parent 和 child，也就是双向链表中的父指针和孩子指针
* 还有一个成员变量 pthread_t 类型的，所以说 autoreleasepool 是和线程一一对应的，就是从这个结构当中的 Thread 成员变量提现出来的


### AutoreleasePoolPage 的结构

![](/img/AutoreleasePoolPage的结构.png)

最下边是 AutoreleasePoolPage 自身所占有的内存，上面这些可以用来存储花括号中填充的 autorelease 对象，同样的这个栈是向下增长的，所以下面是高地址，上面是低地址，有一个 next 指针也就是 AutoreleasePoolPage 这个结构当中的一个成员变量，指向当前栈的一个空的位置，比如说现在在进行一个入栈操作，就可以添加到 next 指针所指向的位置

### AutoreleasePoolPage::push 方法实现

![](/img/AutoreleasePoolPage的push方法实现.png)

如果发生了一个 AutoreleasePoolPage::push 操作，会把当前 next 位置置为 nil ，称他为哨兵对象，然后将 next 指针指向下一个可入栈的位置，这就是 AutoreleasePoolPage 的 push 方法的实现过程
实际上每次进行一个 AutoreleasePool 的代码块的创建，相当于是不断的在栈当中去插入哨兵对象

### [ obj  autorelease ] 方法系统内部实现

![](/img/autorelease方法系统内部实现.png)

比如说调用了一个对象的 autorelease 方法
首先会判断当前 next 指针是否指向了栈顶，如果没有指向栈顶就直接把这个对象添加到当前这个栈的 next 位置，结束流程，假如当前 next 已经指向了栈顶，这个时候当前这个 AutoreleasePoolPage 就没有办法再装新的 autorelease 对象了，于是就需要增加一个栈节点拼接到到链表上，之后在新的栈上面去添加对象最终结束流程

### AutoreleasePoolPage::pop 方法实现

* **根据传入的哨兵对象找到对应的位置**

* **给上次push操作之后添加的对应一次发送release消息**

* **回退next指针到正确位置**

首先对 pop 流程做一个简单的说明：
* 在进行 pop 操作的时候会根据传入的哨兵对象来找到 pop 的最终位置，这个所谓的哨兵对象就是前面提到的 objc_autoreleasePoolPush 函数的返回值，实际上返回的就是栈当中对应的哨兵地址，pop 操作和 push 操作是一一对应的，那么要 pop 回哪个位置实际上是 pop 回它所指向的前一个哨兵对象
* 然后给上次 push 操作之后所添加的对象依次发送 release 消息
* 之后回退 next 指针到正确的位置