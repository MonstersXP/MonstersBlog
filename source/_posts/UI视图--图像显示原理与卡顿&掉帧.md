---
title: UI视图--图像显示原理与卡顿&掉帧
date: 2018-04-05 14:22:09
description: 图像显示原理与卡顿&掉帧
categories: UI视图
tags: [Objective-C]
---

## 图像显示原理

![](/img/图像显示原理.png)

1. CPU和GPU两个硬件是通过总线链接起来的
2. 在CPU中输出的结果是位图，经由总线在合适的时机上传给GPU
3. GPU拿到位图之后，会做相应位图的图层渲染，包括文理的合成
4. 之后会把结果放到帧缓冲区（Frame Buffer）当中
5. 由视频控制器根据VSync信号在指定时间之前去提取在帧缓存区当中的显示内容，最终显示到手机屏幕上


## UIView的显示过程

![](/img/UIView的显示过程.png)

1. 当创建一个UIView控件之后，显示部分是由 [CALayer](https://xiaopengmonsters.github.io/2016/12/18/CAlayer/) 来负责的
2. CALayer当中有一个contents属性，就是我们最终要绘制到屏幕上的位图
3. 比如说我们创建的是一个UILable，contents里面最终放置的结果就是关于hello word的文字位图
4. 然后系统会在合适的时机回调一个drawRect：方法，在此基础上可以绘制一些自定义想要绘制的内容
5. 绘制好的位图，最终会由Core Animation框架提交给GPU部分的OpenGL（ES）渲染管线进行最终的位图的渲染，包括文理的合成，然后显示到屏幕上面


## UI卡顿&掉帧原因

![](/img/UI卡顿&掉帧原因.png)


一般60fps为流畅：每一秒钟会有60帧的画面更新

那么每隔 16.7ms（1/60）就要产生一帧画面，那么在这 16.7 毫秒之内，需要 CPU 和 GPU 共同完成产生一帧数据

比如 CPU 花费一定的时间做文本的布局，UI计算，包括一些视图的绘制，以及图片解码，然后把最终产生的位图提交给 GPU，再由 GPU 进行相应的图层的合成，文理渲染，然后准备好下一帧画面，再下一帧 VSync 信号到来的时候就可以显示画面

那假如说 CPU 在做文本布局，UI计算，视图绘制，以及图片解码等工作时长太长的话 ，那么留给 GPU 的时间就非常少，那 GPU 要想把图层的合成，文理渲染全部准备完毕，可能就要总时间超过了 16.7ms，那这样的话在下一帧 VSync 的信号到来的时候，我们没有准备好这一帧当下的画面，那就由此产生了掉帧，我们看到的效果就是滑动卡顿

总之，就是在规定的 16.7ms 之内，在下一帧 VSync 信号到来之前，CPU 和 GPU 并没有共同完成下一帧画面的合成，于是就会导致卡顿或者说掉帧


#### 滑动优化方案

CPU

* 对象创建、调整、销毁（可以放在子线程）
* 预排版（布局计算，文本计算）
* 预渲染（文本等异步绘制，图片编码等）

GPU

* 纹理渲染（避免离屏渲染、CPU异步绘制机制减轻GPU压力）
* 视图混合（减轻层级复杂度）