---
title: 内存管理(二)--有关散列表实现的内存管理方法的数据结构
date: 2018-06-18 01:01:18

description: 有关散列表实现的内存管理方法的数据结构

categories: 内存管理
tags: [Objective-C]
---

***
[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)
[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)
[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)
[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)
[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)
[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)
[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)
***


### 数据结构

* **Spinlock_t** （自旋锁）
* RefacountMap （弱用计数表）
* weak_table _t  (弱引用表)


### 自旋锁（Spinlock_t）

* 自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。
* Spinlock_t 是 “忙等” 的锁
* 适用于轻量访问


自身很大的一个特点：循环等待访问，不释放当前资源

自旋锁本身是一种忙等的锁，忙等指的是：如果当前锁已被其他线程获取，那么当前线程会不断的探测这个锁是否有被释放，如果释放自己第一时间去获取这个锁

是一个循环等待的访问，类似一个 while 循环一直在访问能不能获得当前的锁，如果不能他就继续循环，直到有一次能获得这个锁，它才会停止循环

再比如说其他的锁，比如正常的信号量，如果当他获取不到这个锁的时候，他会把自己这个线程进行阻塞休眠，然后等到其他线程释放这个锁的时候来唤醒当前线程

应用场景
用于轻量级数据访问，简单的 int 值 +1/-1 操作（在引用计数方面应用）

自旋锁适应于轻量访问，比如说以前讲到的 Side Table 表，如果说我们对某一个对象进行引用计数操作的话，来访问这个表，那么实际上做加一减一的操作是非常快的操作，可以把它定义为轻量访问，在这种轻量访问的场景下可以使用自旋锁

思考：你是否有使用过自旋锁？自旋锁和普通的锁有什么区别？自旋锁适应于哪些场景？
 
### 引用计数表（RefacountMap）

![](/img/RefacountMap.png)

引用计数表是哈希表，正如名字 Map，可以理解为是一个字典，也就是说通过一个指针可以找到对应对象的引用计数，这个查找过程也是哈希查找，这个哈希查找的哈希算法实际上是对传入对象的指针进行伪装的操作，然后获取对应的引用计数

在这里再次明确一下哈希查找的过程，实际上之所以使用哈希查找就是为了提高查找效率，而查找效率的提高源于我们存储一个对象的引用计数是通过这个函数来计算存储位置的，而获取这个对象所代表的引用计数值的时候，也是通过这个函数来计算应该获取的索引位置，所以插入和获取都是通过同一函数来计算位置的，也就避免了一些循环遍历的操作，所以哈希查找可以提高查找效率

思考：引用计数表是用什么来实现的？为什么用哈希表？
答：是用哈希表来实现的，答案在上面

size_t 代表的就是对应对象的引用计数值，实际上就是一个无符号 long 型的变量

**size_t 具体的每一个 bit 位代表的含义：**

比如说引用计数存储使用一个64位来表示的，那么在 size_t 中

* 第一个二进制位 weakly_referenced 表示的是这个对象是否有弱引用，0没有，1有
* 第二位表示当前对象是否正在进行 dealloc 操作
* 后面的存储的就是这个对象实际的引用计数值
那么在计算对象的具体引用计数值，需要对这个值（2-63）向右偏移两位，因为后面这两位要去掉才可以取到真实的引用计数值

### 弱引用表（weak_table _t）

![](/img/weak_table_t.png)

在 Runtime 源码当中，弱引用表系统是通过 weak_table _t 来定义的，weak _ table _ t 实际上也是一张哈希表，同样的给以一个对象的指针作为 Key ，通过一个哈希函数就可以计算出对应的弱引用的对象它的存储位置，weak _ entry_t 是一个结构体数组，这个结构体数组当中存储的每一个对象是弱引用指针，也就是在代码中定义的，比如说 _ _ weak id obj，那么 obj 这个内存地址或者说指针就存储到 weak_entry_t 这个结构体数组当中
这就是弱引用表的数据结构的描述