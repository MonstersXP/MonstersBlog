---
title: 内存管理--循环引用
date: 2018-06-03 01:01:18

description: 循环引用比较常见，为了让循环引用不在浪费开发，是时候来一篇文章总结了

categories: 内存管理
tags: [Objective-C]
---

## 循环引用介绍

循环引用主要可以分为三种类型

* 自循环引用
* 相互循环引用
* 多循环引用

**自循环引用**

 ![](/img/自循环引用.png)
 
 假如有一个对象，对象当中有一个成员变量 obj，这个对象是强持有他的成员变量，如果此时给这个成员变量 obj 赋值原对象的话，就造成自循环引用
 
 相互循坏引用
  
 ![](/img/相互循坏引用.png)
 
 比如说有一个对象 A ，其中有一个 id 类型的 obj，还有一个对象 B 它当中也有一个 id 类型的 obj，如果此时对象 A 中的 obj 指向对象 B，同时对象 B 中的 obj 指向对象 A，此时就造成相互循坏引用
 
 多循环引用
 
  ![](/img/多循环引用.png)
  
  假如在某一个类当中，有对象 1，对象 2，对象 n，每一个对象当中都一个 id 类型的 obj，假如说此时每一个对象的 obj 都指向下一个对象，就产生了一个多循环引用
  
 **循环引用考点**
  
* 代理（相互循环引用）
* Block
* NSTimer
* 大环引用

## 如何破除循环引用

* 避免产生循环引用（比如使用代理过程中，两个对象一个使用强引用，一个使用弱引用）
* 在合适的时机手动断环

**破除循环引用具体的解决方案**

* _ _weak （在使用代理、Block的时候会用到）
* _ _block（一般使用在 Block 方面产生的循环引用问题）
* _ _ unsafe_unretained（由这个关键字修饰的对象也没有增加引用计数，和 _ _weak 在效果上是等效的）

**_ _weak 破解**

避免产生循环应用的常用方案

![](/img/避免产生循环应用的常用方案.png)

假如说左侧的对象 A 和 右侧的对象 B 都有一个成员变量 id 类型的 obj，当把 对象 A 中的成员变量声明为 _ _weak 的时候，就可以破除相互循环引用
对象 B 强持有 A ，而 A 弱引用 B，此时规避了循环引用

**_ _block 破解**

![](/img/__block破解.png)

**_ _ unsafe_unretained 破解**

![](/img/__unsafe_unretained破解.png)

如果被修饰对象在某一时机被释放，再通过这个指针去访问原对象的话，会由于悬垂指针的原因导致内存泄露

## 循环应用的示例

* Block 的使用示例

* NSTimeer 的使用示例

### Block 的循环应用问题

想了解 Block 的循环引用问题，请移驾 Block 章节的 [Block--Block 的循环应用]()

### NSTimeer 的循环应用问题

![](/img/NSTimeer的循环应用问题1.png)

假如一个实际的场景：比如有一个页面，在这个页面当中有一个 banner 广告栏，需要在每一秒钟滚动一次，一般情况下会把 banner 广告栏的 UI 对象作为 VC 的一个成员变量，由 VC 对它进行强持有，那么由于 banner 需要每个一秒钟进行一个滚动播放，又涉及到定会器的使用，所以需要在这个对象当中去添加一个成员变量 NSTimer，当添加了 NSTimer 之后，在为它分配了一个相应的定时回调事件之后，NSTimer 会对他的 target 进行强引用，这个时候就产生了一个相互循环引用

![](/img/NSTimeer的循环应用问题2.png)

如果把这个对象对 NSTimer 的强引用换为弱引用（如上图）来解除，是大错特错的

![](/img/NSTimeer的循环应用问题3.png)

因为 NSTimer 刚被分派之后，会被当前线程的 RunLoop 强引用，如果说我们这个对象后者说 NSTimer 是在主线程中创建的，那么就由主线程的 RunLoop 持有这个 NSTimer，所以即使这个对象弱引用了 NSTimer，但是由于主线程的 RunLoop 常住内存 通过对 NSTimer 的强引用，再通过 NSTimer 对对象的强引用，仍然对这个对象产生了一个强引用，那么此时，即使 VC 页面退出，对对象的引用去掉的话，这个当前 banner 广告栏由于被 RunLoop 间接的持有，这个对象也不会被释放，此时就产生了内存泄露

关于 NSTimer 是有**重复定时器**和**非重复定时器**之分
假如我们创建的 NSTimer 是非重复的定时器，一般情况下我们会在定时器的回调方法当中去调用 NSTimer 的 invalidate 方法，同时使 timer 为 nil，通过这种办法，可以把 RunLoop 对 NSTimer 的强引用给解除，同时 NSTimer 也解除了对对象的强引用

**思考：**接入说 NSTimer 是一个重复多次回调的定时器的话，就不能在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作

![](/img/NSTimeer的循环应用问题4.png)

![](/img/NSTimeer的循环应用问题5.png)

在左侧是 RunLoop 对 NSTimer 的强引用，在右侧是 VC 对 对象的强引用，我们可以在 NSTimer 和对象中间添加一个中间对象，然后由 NSTimer 对中间对象执行一个强引用，同时中间对象分别对 NSTimer 和 banner广告栏的对象做一个弱引用，此时对于一个重复的定时器而言，当当前 VC 或者说页面退出之后，VC 就释放了对 banner 广告栏这个对象强引用，当下次 NSTimer 的回调事件回来的时候，我们可以在中间对象当中 NSTimer 的回调方法里面去判断当前中间对象所持有的弱引用对象是否被废弃掉了，实际上就是判断中间对象所持有的 weak 变量是否为 nil，如果为 nil 的话，在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作，这样的话就可以释放 RunLoop 对 NSTimer 的强引用，NSTimer 对中间对象的强引用，NSTimer和中间对象都可以得到内存的释放达到破除循环引用的目的

**代码实现：**

通过对 NSTimer 添加分类文件，添加一个分派定时器的方法

![](/img/NSTimeer的循环应用问题6.png)

定义的中间对象：

在中间对象当中定义了三个成员变量，一个是 用 weak 指向的 target， 另一个是 selector 也就是定时器的回调方法，还持有了一个弱引用实现的成员变量 timer，然后中间对象中还有一个方法 fire，fire方法的实现就是对他所持有的 target 进行判断，如果当前 target 仍然存在的话，那么判断它是否响应这个选择器，如果响应的话就执行对应的回调方法，如果 target 不存在就把 timer 置为无效

![](/img/NSTimeer的循环应用问题7.png)

分类实现：

首先创建中间对象，然后把传递给 NSTimer 分类当中方法的 taeget 和 selector 分别指派给中间对象，然后再调用系统的 NSTimer 方法去创建 timer，同时指定回调事件是中间对象的 fire 方法，会在 fire 方法当中对实际的回调方法进行调用

![](/img/NSTimeer的循环应用问题8.png)


### 至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题