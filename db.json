{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/五角星.png","path":"img/五角星.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/正方形.png","path":"img/正方形.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1535684710000},{"_id":"themes/maupassant/README.md","hash":"253b7eead5dac44c0cbc86dfc25aa352a56850c4","modified":1535684710000},{"_id":"source/_posts/.DS_Store","hash":"94d97062cd8fbf98e551a680773727ba30bda7fb","modified":1536653880000},{"_id":"source/.DS_Store","hash":"9ce340652af19d21c110558d73b02a6281f5b25a","modified":1536903502000},{"_id":"source/_posts/AFNetworking框架分析.md","hash":"aee10b7c42eff207c2101eea5cca15a128f46bc9","modified":1536656380000},{"_id":"themes/maupassant/_config.yml","hash":"b972b6144da8b0f70dc4542944c27d7a887d97c5","modified":1535684710000},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1535684710000},{"_id":"source/_posts/Block--Block 的循环引用.md","hash":"93a6f903de3fba7167a853b6c7e6cffd434a79ff","modified":1536659281000},{"_id":"source/_posts/Block--Block 的内存管理.md","hash":"4f2d41c05d860133a8ecf495f0e5e90246ebc837","modified":1536659250000},{"_id":"source/_posts/Block--_ _block 修饰符.md","hash":"b071d202eab6e63663ff581394559df49dcac37b","modified":1536659243000},{"_id":"source/_posts/APP的优化.md","hash":"23cce966d840e3d414b527fceee3dc26f9d15953","modified":1535687484000},{"_id":"source/_posts/Block--Block 本质和截获变量.md","hash":"735b5ac365c29939b24b24b1c8eb700d29fa084c","modified":1536659191000},{"_id":"source/_posts/CAlayer.md","hash":"7245dd8a3d3bcacd2dc9b2393c34c63796e05260","modified":1535684710000},{"_id":"source/_posts/LLDB.md","hash":"9dac11ce21a85affa94f67da1622e4f139913451","modified":1535684710000},{"_id":"source/_posts/NStimer准确吗.md","hash":"4a4476b27176275e236f716fedbdd67ff3edfc4e","modified":1535684710000},{"_id":"source/_posts/RunLoop.md","hash":"3aca23598f67dcd6776e664a2fbc84e6d7829c50","modified":1535684710000},{"_id":"source/_posts/Runtime.md","hash":"2313b5d64acc9e3a25f98d3671ebe0a4198ec5fd","modified":1536655145000},{"_id":"source/_posts/Runtime--Runtime的数据结构.md","hash":"915a902620c56765097b57d505eaa8fe643222f0","modified":1536655152000},{"_id":"source/_posts/Runtime--类对象与元类对象.md","hash":"043d6d35b5f5c0cac5b4b75f2cebdd6a5c4a41e0","modified":1536655157000},{"_id":"source/_posts/Runtime之动态添加方法.md","hash":"dbacf95f22a6fe5a577762d561eae65db29189e0","modified":1536655123000},{"_id":"source/_posts/UITableView的优化进阶篇.md","hash":"e2714df6473e5b817975a88394c2938337ec670c","modified":1535687465000},{"_id":"source/_posts/Runtime之动态添加属性.md","hash":"dd725e737345808e82d058b94226a08aca483359","modified":1536655138000},{"_id":"source/_posts/UI视图--图像显示原理与卡顿&掉帧.md","hash":"ff1044f5222c4973965d03a061b43261694e0794","modified":1535687264000},{"_id":"source/_posts/hello-world.md","hash":"485a00b40bdb71b56acace162599121493365e34","modified":1535684710000},{"_id":"source/_posts/UI视图--UI绘制原理&异步绘制.md","hash":"5ca8771d6f5a60b8288eadf0fed8f13a23d4ebd3","modified":1535687268000},{"_id":"source/_posts/iOS中的多线程.md","hash":"37a90bd0fb95d2a5b3c5a774f4fc17f1a4a24808","modified":1535684710000},{"_id":"source/_posts/iOS Delegate 引发的血案.md","hash":"93ee6dd63d67f0fa13fc4868e48f45fa92a3df25","modified":1535684710000},{"_id":"source/_posts/UI视图--离屏渲染.md","hash":"df7fe8a5b317b80d31c51cd86894acde227b9ebc","modified":1535687569000},{"_id":"source/_posts/UITableView的优化.md","hash":"e8783aeec2b03dbc143b1ac576db7995f8f44437","modified":1535687476000},{"_id":"source/_posts/iOS应用架构谈：网络层框架的设计.md","hash":"1cd93b639a5052c819a947993c56fc7aa0377ae5","modified":1536659738000},{"_id":"source/_posts/iOS应用架构谈：网络层框架的优化.md","hash":"a0f4df85cbc2f12bdbb3ccbf786a4413d070473f","modified":1536659747000},{"_id":"source/_posts/内存管理--引用计数管理.md","hash":"65b4fd97be41a3e3d6bbd6a53567bf0ca6bf51f4","modified":1536894254000},{"_id":"source/_posts/内存管理--内存管理方案.md","hash":"32069d6b443d75bbe7f02d0279a6eae5a3611fdb","modified":1536659494000},{"_id":"source/_posts/iOS应用架构谈：本地持久化方案及动态部署.md","hash":"7159ad5078dbe257e94671aa875ba45656d43efc","modified":1536659731000},{"_id":"source/_posts/内存管理--循环引用.md","hash":"ed399027cd30bfc34e764fd0748d2901e29f7ac1","modified":1536659480000},{"_id":"source/_posts/内存管理--有关散列表实现的内存管理方法的数据结构.md","hash":"66d0f70489b4d665446e85a1e7c880adabec3ae7","modified":1536748128000},{"_id":"source/_posts/内存管理--弱引用管理.md","hash":"634ad180798baa93559c463efb76158538fcca73","modified":1536915736000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"29a7db76d360de5164e3a9efcc41e1d15b72365d","modified":1535684710000},{"_id":"source/_posts/如何清空view上的所有子视图.md","hash":"707199f107b3b611f2d2457b905402242d15e644","modified":1535684710000},{"_id":"themes/maupassant/languages/en.yml","hash":"053b2cb18e3e2804277faf2cb78651be2aa066d9","modified":1535684710000},{"_id":"source/about/index.md","hash":"0e2ec2dd0cbfba774e6ee085d440011ef7f2744f","modified":1535684710000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1535684710000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1535684710000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1535684710000},{"_id":"source/_posts/内存管理--自动释放池.md","hash":"568a4fd11d9236a746a32e4066f2476cfa88d6eb","modified":1536916173000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"418b6fa3b2bb3d21bf91b61a8e100a5f543ec31d","modified":1535684710000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1535684710000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1535684710000},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1535684710000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1535684710000},{"_id":"themes/maupassant/layout/post.pug","hash":"db3d124ee6c9d21a65996c9adc48f4d80134bd34","modified":1535684710000},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1535684710000},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1535684710000},{"_id":"themes/maupassant/layout/index.pug","hash":"ebe5495c3514e570af033728e664be4b1d4cd659","modified":1535684710000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1535684710000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/cnzz_tongji.pug","hash":"07036cfbfa82e16826cee2a795bee9216c815c9b","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"532f540d1813bb7184b688cc22b292943c38fd0f","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ae5537e123f7e95e2a423dce3147ef5f3d3114b6","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"6a46b9b4400aca5d1bd4db8243a5f25d0ed40be5","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"eb38a1b1bbde2556562edbab78c2f90fd7927e9d","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"0e2f902fd2f096ff9fcc84f4e60a8b2588962fe3","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"974db7838079076f380effcb291e27b89799f0ed","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1535684710000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1535684710000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1535684710000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1535684710000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1535684710000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1535684710000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1535684710000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1535684710000},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1535684710000},{"_id":"themes/maupassant/source/css/donate.css","hash":"d0079ba8202d925a93ab1cb44f2087b81f476755","modified":1535684710000},{"_id":"themes/maupassant/source/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1535684710000},{"_id":"themes/maupassant/source/donate/index.html","hash":"58260d8d8b5cfa3f46705914e6df164d9f08d9dd","modified":1535684710000},{"_id":"themes/maupassant/source/css/style.scss","hash":"fd8349ff25385b2dea1b3edc8e62275448a66bcd","modified":1535684710000},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1535684710000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1535684710000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1535684710000},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1535684710000},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1535684710000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1535684710000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1535684710000},{"_id":"themes/maupassant/source/img/五角星.png","hash":"79b5e875f19125fd621a35cb927e8b1bd2eeda6d","modified":1535684710000},{"_id":"themes/maupassant/source/img/正方形.png","hash":"14c10989435d450a2aa211c1f44ff6faa1784bb2","modified":1535684710000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1535684710000},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1535684710000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1535684710000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1535684710000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1535684710000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1535684710000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1535684710000},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"69d5a3fc3e229c3b4713b72798ba0cb974d5de37","modified":1535684710000},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"153e9353c736795d9386f006a7c850f502aa25cc","modified":1535684710000},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1535684710000},{"_id":"themes/maupassant/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1535684710000},{"_id":"source/_posts/内存管理--有关散列表实现的内存管理方法的数据结构~.md","hash":"220eeeb81ac302c93b4819f8c669d6aacc6b9cb2","modified":1536659502000}],"Category":[{"name":"iOS","_id":"cjlxj6fmy000266r266ohbsm2"},{"name":"Block","_id":"cjlxj6fn3000766r2mn2g53bn"},{"name":"三方框架","parent":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6fnj000r66r2bmzr7t17"},{"name":"性能优化","_id":"cjlxj6fnm000z66r2hm0d2xnb"},{"name":"问题记录","_id":"cjlxj6fno001766r2ry9ylfcu"},{"name":"RunLoop","_id":"cjlxj6fnr001f66r2thif695s"},{"name":"Runtime","_id":"cjlxj6fnt001l66r20jkyuckv"},{"name":"UI视图","_id":"cjlxj6fnw002266r25kd7wmlh"},{"name":"内存管理","_id":"cjlxj6gcg002t66r2yho4h9dq"}],"Data":[],"Page":[{"title":"关于","date":"2017-12-21T08:23:08.000Z","donate":true,"_content":"\nNickname: [monsters]()\n\nEmail: [xiaopeng__w@163.com]()\n\nGithub: [xiaopengmonsters](https://github.com/xiaopengmonsters)\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-12-21 16:23:08\ndonate: true\n---\n\nNickname: [monsters]()\n\nEmail: [xiaopeng__w@163.com]()\n\nGithub: [xiaopengmonsters](https://github.com/xiaopengmonsters)\n","updated":"2018-08-31T03:05:10.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjlxj6gc2002766r2fg4k73md","content":"<p>Nickname: <a href=\"\">monsters</a></p>\n<p>Email: <a href=\"\">xiaopeng__w@163.com</a></p>\n<p>Github: <a href=\"https://github.com/xiaopengmonsters\" target=\"_blank\" rel=\"noopener\">xiaopengmonsters</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Nickname: <a href=\"\">monsters</a></p>\n<p>Email: <a href=\"\">xiaopeng__w@163.com</a></p>\n<p>Github: <a href=\"https://github.com/xiaopengmonsters\" target=\"_blank\" rel=\"noopener\">xiaopengmonsters</a></p>\n"}],"Post":[{"title":"AFNetworking框架分析","date":"2017-03-16T05:23:28.000Z","description":"想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。","toc":false,"_content":"\n想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。\n\n说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。\n\n## AFN的结构\n\n首先我们来看看AFN的结构：\n\n![](/img/AFN结构图.png)\n\n从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。\n\n1. **NSURLSession**：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。\n2. **Reachability**：网络状态监听模块\n3. **Security**：网络通讯安全策略模块 \n3. **Seriaalization**：网络通信信息序列化、反序列化模块\n4. **UIKit**：对于IOSUIKit的扩展库\n\n## 核心模块NSURLSession\n\n### 1、NSURLSession由三个基本模块构成：\n\n* NSURLSession\n* NSURLSessionConfiguation\n* NSURLSessionTask\n\nNSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求\n\nNSURLSession的行为取决于三个方面。包括\n\n* NSURLSession的类型\n* NSURLSessionTask的类型\n* 在创建task时APP是否处于前端\n\n\n### 2、NSURLSession有三种类型\n\n* defaultSession（默认会话模式）：将cache和creditials储存于本地\n\n* Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。\n\n* backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。\n\n**在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。**\n\n### 3、NSURLSessionTask包括三种Task类型\n\n* NSURLSessionDataTask\n* NSURLSessionDownLoadTask\n* NSURLSessionUploadTask\n\n所有的Task状态都是暂停的，需要用[Task resume]启动Task\n\n### 4、NSURLSession有两种获取数据的方式\n\n* 初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法\n* 初始化Session时未指定delegate的，通过block回调返回数据。\n\n### 5、NSURLSession对象的销毁，有两种销毁模式\n\n* - (void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用\n* - (void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate\n\n这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。\n\n**使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。**\n\n## 网络请求的过程\n\n创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。\n\nAFURLSessionManager封装了上述网络交互功能\nAFURLSessionManager请求过程：\n\n1. 初始化AFURLSessionManager\n2. 获取AFURLSessionManager的Task对象\n3. 启动Task\n\nAFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理\n\n初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度\n\n### NSURLSessionDelegate的响应\n\n因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。\n\n\n### 参考文章\n\n[AFNetworking实现原理理解](https://www.jianshu.com/p/02b25f6d1e1f)\n","source":"_posts/AFNetworking框架分析.md","raw":"---\ntitle: AFNetworking框架分析\ndate: 2017-3-16 13:23:28\n\ndescription: 想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。\ncategories: [iOS,三方框架]\ntags: [Objective-C]\ntoc: false \n---\n\n想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。\n\n说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。\n\n## AFN的结构\n\n首先我们来看看AFN的结构：\n\n![](/img/AFN结构图.png)\n\n从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。\n\n1. **NSURLSession**：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。\n2. **Reachability**：网络状态监听模块\n3. **Security**：网络通讯安全策略模块 \n3. **Seriaalization**：网络通信信息序列化、反序列化模块\n4. **UIKit**：对于IOSUIKit的扩展库\n\n## 核心模块NSURLSession\n\n### 1、NSURLSession由三个基本模块构成：\n\n* NSURLSession\n* NSURLSessionConfiguation\n* NSURLSessionTask\n\nNSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求\n\nNSURLSession的行为取决于三个方面。包括\n\n* NSURLSession的类型\n* NSURLSessionTask的类型\n* 在创建task时APP是否处于前端\n\n\n### 2、NSURLSession有三种类型\n\n* defaultSession（默认会话模式）：将cache和creditials储存于本地\n\n* Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。\n\n* backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。\n\n**在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。**\n\n### 3、NSURLSessionTask包括三种Task类型\n\n* NSURLSessionDataTask\n* NSURLSessionDownLoadTask\n* NSURLSessionUploadTask\n\n所有的Task状态都是暂停的，需要用[Task resume]启动Task\n\n### 4、NSURLSession有两种获取数据的方式\n\n* 初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法\n* 初始化Session时未指定delegate的，通过block回调返回数据。\n\n### 5、NSURLSession对象的销毁，有两种销毁模式\n\n* - (void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用\n* - (void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate\n\n这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。\n\n**使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。**\n\n## 网络请求的过程\n\n创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。\n\nAFURLSessionManager封装了上述网络交互功能\nAFURLSessionManager请求过程：\n\n1. 初始化AFURLSessionManager\n2. 获取AFURLSessionManager的Task对象\n3. 启动Task\n\nAFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理\n\n初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度\n\n### NSURLSessionDelegate的响应\n\n因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。\n\n\n### 参考文章\n\n[AFNetworking实现原理理解](https://www.jianshu.com/p/02b25f6d1e1f)\n","slug":"AFNetworking框架分析","published":1,"updated":"2018-09-11T08:59:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fmt000066r29xuk6rvq","content":"<p>想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。</p>\n<p>说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。</p>\n<h2 id=\"AFN的结构\"><a href=\"#AFN的结构\" class=\"headerlink\" title=\"AFN的结构\"></a>AFN的结构</h2><p>首先我们来看看AFN的结构：</p>\n<p><img src=\"/img/AFN结构图.png\" alt=\"\"></p>\n<p>从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。</p>\n<ol>\n<li><strong>NSURLSession</strong>：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。</li>\n<li><strong>Reachability</strong>：网络状态监听模块</li>\n<li><strong>Security</strong>：网络通讯安全策略模块 </li>\n<li><strong>Seriaalization</strong>：网络通信信息序列化、反序列化模块</li>\n<li><strong>UIKit</strong>：对于IOSUIKit的扩展库</li>\n</ol>\n<h2 id=\"核心模块NSURLSession\"><a href=\"#核心模块NSURLSession\" class=\"headerlink\" title=\"核心模块NSURLSession\"></a>核心模块NSURLSession</h2><h3 id=\"1、NSURLSession由三个基本模块构成：\"><a href=\"#1、NSURLSession由三个基本模块构成：\" class=\"headerlink\" title=\"1、NSURLSession由三个基本模块构成：\"></a>1、NSURLSession由三个基本模块构成：</h3><ul>\n<li>NSURLSession</li>\n<li>NSURLSessionConfiguation</li>\n<li>NSURLSessionTask</li>\n</ul>\n<p>NSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求</p>\n<p>NSURLSession的行为取决于三个方面。包括</p>\n<ul>\n<li>NSURLSession的类型</li>\n<li>NSURLSessionTask的类型</li>\n<li>在创建task时APP是否处于前端</li>\n</ul>\n<h3 id=\"2、NSURLSession有三种类型\"><a href=\"#2、NSURLSession有三种类型\" class=\"headerlink\" title=\"2、NSURLSession有三种类型\"></a>2、NSURLSession有三种类型</h3><ul>\n<li><p>defaultSession（默认会话模式）：将cache和creditials储存于本地</p>\n</li>\n<li><p>Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。</p>\n</li>\n<li><p>backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。</p>\n</li>\n</ul>\n<p><strong>在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。</strong></p>\n<h3 id=\"3、NSURLSessionTask包括三种Task类型\"><a href=\"#3、NSURLSessionTask包括三种Task类型\" class=\"headerlink\" title=\"3、NSURLSessionTask包括三种Task类型\"></a>3、NSURLSessionTask包括三种Task类型</h3><ul>\n<li>NSURLSessionDataTask</li>\n<li>NSURLSessionDownLoadTask</li>\n<li>NSURLSessionUploadTask</li>\n</ul>\n<p>所有的Task状态都是暂停的，需要用[Task resume]启动Task</p>\n<h3 id=\"4、NSURLSession有两种获取数据的方式\"><a href=\"#4、NSURLSession有两种获取数据的方式\" class=\"headerlink\" title=\"4、NSURLSession有两种获取数据的方式\"></a>4、NSURLSession有两种获取数据的方式</h3><ul>\n<li>初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法</li>\n<li>初始化Session时未指定delegate的，通过block回调返回数据。</li>\n</ul>\n<h3 id=\"5、NSURLSession对象的销毁，有两种销毁模式\"><a href=\"#5、NSURLSession对象的销毁，有两种销毁模式\" class=\"headerlink\" title=\"5、NSURLSession对象的销毁，有两种销毁模式\"></a>5、NSURLSession对象的销毁，有两种销毁模式</h3><ul>\n<li><ul>\n<li>(void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用</li>\n</ul>\n</li>\n<li><ul>\n<li>(void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate</li>\n</ul>\n</li>\n</ul>\n<p>这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。</p>\n<p><strong>使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。</strong></p>\n<h2 id=\"网络请求的过程\"><a href=\"#网络请求的过程\" class=\"headerlink\" title=\"网络请求的过程\"></a>网络请求的过程</h2><p>创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。</p>\n<p>AFURLSessionManager封装了上述网络交互功能<br>AFURLSessionManager请求过程：</p>\n<ol>\n<li>初始化AFURLSessionManager</li>\n<li>获取AFURLSessionManager的Task对象</li>\n<li>启动Task</li>\n</ol>\n<p>AFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理</p>\n<p>初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度</p>\n<h3 id=\"NSURLSessionDelegate的响应\"><a href=\"#NSURLSessionDelegate的响应\" class=\"headerlink\" title=\"NSURLSessionDelegate的响应\"></a>NSURLSessionDelegate的响应</h3><p>因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.jianshu.com/p/02b25f6d1e1f\" target=\"_blank\" rel=\"noopener\">AFNetworking实现原理理解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。</p>\n<p>说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。</p>\n<h2 id=\"AFN的结构\"><a href=\"#AFN的结构\" class=\"headerlink\" title=\"AFN的结构\"></a>AFN的结构</h2><p>首先我们来看看AFN的结构：</p>\n<p><img src=\"/img/AFN结构图.png\" alt=\"\"></p>\n<p>从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。</p>\n<ol>\n<li><strong>NSURLSession</strong>：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。</li>\n<li><strong>Reachability</strong>：网络状态监听模块</li>\n<li><strong>Security</strong>：网络通讯安全策略模块 </li>\n<li><strong>Seriaalization</strong>：网络通信信息序列化、反序列化模块</li>\n<li><strong>UIKit</strong>：对于IOSUIKit的扩展库</li>\n</ol>\n<h2 id=\"核心模块NSURLSession\"><a href=\"#核心模块NSURLSession\" class=\"headerlink\" title=\"核心模块NSURLSession\"></a>核心模块NSURLSession</h2><h3 id=\"1、NSURLSession由三个基本模块构成：\"><a href=\"#1、NSURLSession由三个基本模块构成：\" class=\"headerlink\" title=\"1、NSURLSession由三个基本模块构成：\"></a>1、NSURLSession由三个基本模块构成：</h3><ul>\n<li>NSURLSession</li>\n<li>NSURLSessionConfiguation</li>\n<li>NSURLSessionTask</li>\n</ul>\n<p>NSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求</p>\n<p>NSURLSession的行为取决于三个方面。包括</p>\n<ul>\n<li>NSURLSession的类型</li>\n<li>NSURLSessionTask的类型</li>\n<li>在创建task时APP是否处于前端</li>\n</ul>\n<h3 id=\"2、NSURLSession有三种类型\"><a href=\"#2、NSURLSession有三种类型\" class=\"headerlink\" title=\"2、NSURLSession有三种类型\"></a>2、NSURLSession有三种类型</h3><ul>\n<li><p>defaultSession（默认会话模式）：将cache和creditials储存于本地</p>\n</li>\n<li><p>Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。</p>\n</li>\n<li><p>backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。</p>\n</li>\n</ul>\n<p><strong>在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。</strong></p>\n<h3 id=\"3、NSURLSessionTask包括三种Task类型\"><a href=\"#3、NSURLSessionTask包括三种Task类型\" class=\"headerlink\" title=\"3、NSURLSessionTask包括三种Task类型\"></a>3、NSURLSessionTask包括三种Task类型</h3><ul>\n<li>NSURLSessionDataTask</li>\n<li>NSURLSessionDownLoadTask</li>\n<li>NSURLSessionUploadTask</li>\n</ul>\n<p>所有的Task状态都是暂停的，需要用[Task resume]启动Task</p>\n<h3 id=\"4、NSURLSession有两种获取数据的方式\"><a href=\"#4、NSURLSession有两种获取数据的方式\" class=\"headerlink\" title=\"4、NSURLSession有两种获取数据的方式\"></a>4、NSURLSession有两种获取数据的方式</h3><ul>\n<li>初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法</li>\n<li>初始化Session时未指定delegate的，通过block回调返回数据。</li>\n</ul>\n<h3 id=\"5、NSURLSession对象的销毁，有两种销毁模式\"><a href=\"#5、NSURLSession对象的销毁，有两种销毁模式\" class=\"headerlink\" title=\"5、NSURLSession对象的销毁，有两种销毁模式\"></a>5、NSURLSession对象的销毁，有两种销毁模式</h3><ul>\n<li><ul>\n<li>(void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用</li>\n</ul>\n</li>\n<li><ul>\n<li>(void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate</li>\n</ul>\n</li>\n</ul>\n<p>这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。</p>\n<p><strong>使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。</strong></p>\n<h2 id=\"网络请求的过程\"><a href=\"#网络请求的过程\" class=\"headerlink\" title=\"网络请求的过程\"></a>网络请求的过程</h2><p>创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。</p>\n<p>AFURLSessionManager封装了上述网络交互功能<br>AFURLSessionManager请求过程：</p>\n<ol>\n<li>初始化AFURLSessionManager</li>\n<li>获取AFURLSessionManager的Task对象</li>\n<li>启动Task</li>\n</ol>\n<p>AFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理</p>\n<p>初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度</p>\n<h3 id=\"NSURLSessionDelegate的响应\"><a href=\"#NSURLSessionDelegate的响应\" class=\"headerlink\" title=\"NSURLSessionDelegate的响应\"></a>NSURLSessionDelegate的响应</h3><p>因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.jianshu.com/p/02b25f6d1e1f\" target=\"_blank\" rel=\"noopener\">AFNetworking实现原理理解</a></p>\n"},{"title":"Block(四)--Block 的循环引用","date":"2018-06-04T17:01:18.000Z","description":"循环引用 Block 篇","_content":"\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","source":"_posts/Block--Block 的循环引用.md","raw":"---\ntitle: Block(四)--Block 的循环引用\ndate: 2018-06-05 01:01:18\n\ndescription: 循环引用 Block 篇\n\ncategories: Block\ntags: [Objective-C]\n---\n\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","slug":"Block--Block 的循环引用","published":1,"updated":"2018-09-11T09:48:01.000Z","_id":"cjlxj6fmw000166r2vtiy70qs","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n"},{"title":"Block(二)--_ _block 修饰符","date":"2018-07-20T17:01:18.000Z","description":"_ _block 修饰符","_content":"\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","source":"_posts/Block--_ _block 修饰符.md","raw":"---\ntitle: Block(二)--_ _block 修饰符\ndate: 2018-07-21 01:01:18\n\ndescription: _ _block 修饰符\n\ncategories: Block\ntags: [Objective-C]\n---\n\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","slug":"Block--_ _block 修饰符","published":1,"updated":"2018-09-11T09:47:23.000Z","_id":"cjlxj6fn0000466r22aj3urwj","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n"},{"title":"Block(三)--Block 的内存管理","date":"2018-08-05T17:01:18.000Z","description":"Block 的内存管理","_content":"\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","source":"_posts/Block--Block 的内存管理.md","raw":"---\ntitle: Block(三)--Block 的内存管理\ndate: 2018-08-06 01:01:18\n\ndescription: Block 的内存管理\n\ncategories: Block\ntags: [Objective-C]\n---\n\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","slug":"Block--Block 的内存管理","published":1,"updated":"2018-09-11T09:47:30.000Z","_id":"cjlxj6fn1000566r25nfmq9dj","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n"},{"title":"APP的优化","date":"2018-01-08T07:21:18.000Z","description":"一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。","toc":"fales","_content":"\n***\n[UITableView的优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)\n[UITableView的优化进阶篇](https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/)\n[APP的优化](https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/)\n***\n\n一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。\n\n# 1、启动优化\n\n[iOS App 启动性能优化](https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA)这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。\n\n在这里只对启动优化做一个概括，大概分为以下几种：\n\n1. 移除不需要用到的动态库\n2. 移除不需要用到的类\n3. 合并功能类似的类和扩展（Category）\n4. 压缩资源图片\n5. 优化applicationWillFinishLaunching\n6. 优化rootViewController加载\n\n总结：\n\n* 利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时\n\n   1. 重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目\n   2. 定期扫描不再使用的动态库、类、函数，例如每两个迭代一次\n   3. 用dispatchonce()代替所有的__attribute__((constructor))函数、C++静态对象初始化、ObjC的+load \n   4. 在设计师可接受的范围内压缩图片的大小，会有意外收获\n\n\n* 利用锚点分析applicationWillFinishLaunching的耗时\n\n   1. 将不需要马上在applicationWillFinishLaunching执行的代码延后执行\n   2. rootViewController的加载，适当将某一级的childViewController或subviews延后加载\n   3. 如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController\n\n   \n* 不应放过的一些小细节\n\n   1. 异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵\n   2. 有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画\n\n\n计算代码执行耗时（用Instruments也可以）：\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    \n    CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n    \n    // do something\n    \n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    \n    NSLog(@\"%fms\",(end -start)*1000);\n     \n}\n\n```\n\n# 2、UITableView的优化\n\nUITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解[UITableView优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)的文章，在这里就不具体描述。\n\n# 3、未完待续。。。\n","source":"_posts/APP的优化.md","raw":"---\ntitle: APP的优化\ndate: 2018-1-8 15:21:18\n\ndescription: 一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。\n\ncategories: [性能优化]\ntags: [Objective-C]\ntoc: fales \n---\n\n***\n[UITableView的优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)\n[UITableView的优化进阶篇](https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/)\n[APP的优化](https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/)\n***\n\n一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。\n\n# 1、启动优化\n\n[iOS App 启动性能优化](https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA)这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。\n\n在这里只对启动优化做一个概括，大概分为以下几种：\n\n1. 移除不需要用到的动态库\n2. 移除不需要用到的类\n3. 合并功能类似的类和扩展（Category）\n4. 压缩资源图片\n5. 优化applicationWillFinishLaunching\n6. 优化rootViewController加载\n\n总结：\n\n* 利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时\n\n   1. 重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目\n   2. 定期扫描不再使用的动态库、类、函数，例如每两个迭代一次\n   3. 用dispatchonce()代替所有的__attribute__((constructor))函数、C++静态对象初始化、ObjC的+load \n   4. 在设计师可接受的范围内压缩图片的大小，会有意外收获\n\n\n* 利用锚点分析applicationWillFinishLaunching的耗时\n\n   1. 将不需要马上在applicationWillFinishLaunching执行的代码延后执行\n   2. rootViewController的加载，适当将某一级的childViewController或subviews延后加载\n   3. 如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController\n\n   \n* 不应放过的一些小细节\n\n   1. 异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵\n   2. 有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画\n\n\n计算代码执行耗时（用Instruments也可以）：\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    \n    CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n    \n    // do something\n    \n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    \n    NSLog(@\"%fms\",(end -start)*1000);\n     \n}\n\n```\n\n# 2、UITableView的优化\n\nUITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解[UITableView优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)的文章，在这里就不具体描述。\n\n# 3、未完待续。。。\n","slug":"APP的优化","published":1,"updated":"2018-08-31T03:51:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fn2000666r2978utfjv","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">UITableView的优化进阶篇</a><br><a href=\"https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">APP的优化</a></p>\n<hr>\n<p>一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。</p>\n<h1 id=\"1、启动优化\"><a href=\"#1、启动优化\" class=\"headerlink\" title=\"1、启动优化\"></a>1、启动优化</h1><p><a href=\"https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA\" target=\"_blank\" rel=\"noopener\">iOS App 启动性能优化</a>这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。</p>\n<p>在这里只对启动优化做一个概括，大概分为以下几种：</p>\n<ol>\n<li>移除不需要用到的动态库</li>\n<li>移除不需要用到的类</li>\n<li>合并功能类似的类和扩展（Category）</li>\n<li>压缩资源图片</li>\n<li>优化applicationWillFinishLaunching</li>\n<li>优化rootViewController加载</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><p>利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时</p>\n<ol>\n<li>重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目</li>\n<li>定期扫描不再使用的动态库、类、函数，例如每两个迭代一次</li>\n<li>用dispatchonce()代替所有的<strong>attribute</strong>((constructor))函数、C++静态对象初始化、ObjC的+load </li>\n<li>在设计师可接受的范围内压缩图片的大小，会有意外收获</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>利用锚点分析applicationWillFinishLaunching的耗时</p>\n<ol>\n<li>将不需要马上在applicationWillFinishLaunching执行的代码延后执行</li>\n<li>rootViewController的加载，适当将某一级的childViewController或subviews延后加载</li>\n<li>如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>不应放过的一些小细节</p>\n<ol>\n<li>异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵</li>\n<li>有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画</li>\n</ol>\n</li>\n</ul>\n<p>计算代码执行耗时（用Instruments也可以）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%fms\"</span>,(end -start)*<span class=\"number\">1000</span>);</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、UITableView的优化\"><a href=\"#2、UITableView的优化\" class=\"headerlink\" title=\"2、UITableView的优化\"></a>2、UITableView的优化</h1><p>UITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解<a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView优化</a>的文章，在这里就不具体描述。</p>\n<h1 id=\"3、未完待续。。。\"><a href=\"#3、未完待续。。。\" class=\"headerlink\" title=\"3、未完待续。。。\"></a>3、未完待续。。。</h1>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">UITableView的优化进阶篇</a><br><a href=\"https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">APP的优化</a></p>\n<hr>\n<p>一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。</p>\n<h1 id=\"1、启动优化\"><a href=\"#1、启动优化\" class=\"headerlink\" title=\"1、启动优化\"></a>1、启动优化</h1><p><a href=\"https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA\" target=\"_blank\" rel=\"noopener\">iOS App 启动性能优化</a>这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。</p>\n<p>在这里只对启动优化做一个概括，大概分为以下几种：</p>\n<ol>\n<li>移除不需要用到的动态库</li>\n<li>移除不需要用到的类</li>\n<li>合并功能类似的类和扩展（Category）</li>\n<li>压缩资源图片</li>\n<li>优化applicationWillFinishLaunching</li>\n<li>优化rootViewController加载</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><p>利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时</p>\n<ol>\n<li>重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目</li>\n<li>定期扫描不再使用的动态库、类、函数，例如每两个迭代一次</li>\n<li>用dispatchonce()代替所有的<strong>attribute</strong>((constructor))函数、C++静态对象初始化、ObjC的+load </li>\n<li>在设计师可接受的范围内压缩图片的大小，会有意外收获</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>利用锚点分析applicationWillFinishLaunching的耗时</p>\n<ol>\n<li>将不需要马上在applicationWillFinishLaunching执行的代码延后执行</li>\n<li>rootViewController的加载，适当将某一级的childViewController或subviews延后加载</li>\n<li>如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>不应放过的一些小细节</p>\n<ol>\n<li>异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵</li>\n<li>有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画</li>\n</ol>\n</li>\n</ul>\n<p>计算代码执行耗时（用Instruments也可以）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%fms\"</span>,(end -start)*<span class=\"number\">1000</span>);</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、UITableView的优化\"><a href=\"#2、UITableView的优化\" class=\"headerlink\" title=\"2、UITableView的优化\"></a>2、UITableView的优化</h1><p>UITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解<a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView优化</a>的文章，在这里就不具体描述。</p>\n<h1 id=\"3、未完待续。。。\"><a href=\"#3、未完待续。。。\" class=\"headerlink\" title=\"3、未完待续。。。\"></a>3、未完待续。。。</h1>"},{"title":"Block(一)--Block 本质和截获变量","date":"2018-07-15T17:01:18.000Z","description":"更深的理解 Block","_content":"\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","source":"_posts/Block--Block 本质和截获变量.md","raw":"---\ntitle: Block(一)--Block 本质和截获变量\ndate: 2018-07-16 01:01:18\n\ndescription: 更深的理解 Block\n\ncategories: Block\ntags: [Objective-C]\n---\n\n*******\n[Block(一) -- Block 本质和截获变量](https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/)\n[Block(二) -- _ _block 修饰符](https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/)\n[Block(三) -- Block 的内存管理](https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n******\n\n## 先思考两个问题\n\n**题1：**\n\n![](/img/Block题1.png)\n\n以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰\n在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用\n\n思考：这段代码有什么问题？\n\n答案：会产生循环引用，是自循环方式的循环引用\n\n由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用\n\n\n![](/img/Block题1答案.png)\n\n可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）\n\n\n**题2：**\n\n![](/img/Block题2.png)\n\n在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用\n\n答案：\n\n* **在 MRC 下**，不会产生循环应用\n* **在ARC下**，会产生循环引用，引起内存泄漏\n\n\n![](/img/ARC下的循环引用.png)\n\n比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 _ _ block 修饰符所修饰的变量，所以 block 对象它持有了 _ _ block 变量，而 _ _block 变量它本身也是对原对象有一个强引用的持有的，因为 _ _ block 变量它的指向是原来的对象，这种循环引用叫大环引用\n\n![](/img/ARC下的循环引用答案.png)\n\n可以通过断环的方式解除\n\n具体的改写方案：（ARC下的解决方案）\n\n![](/img/ARC下的解决方案.png)\n\n在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用\n\n当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁\n\n但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在\n\n","slug":"Block--Block 本质和截获变量","published":1,"updated":"2018-09-11T09:46:31.000Z","_id":"cjlxj6fn5000a66r2c229t2ox","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/07/16/Block--Block%20%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%88%AA%E8%8E%B7%E5%8F%98%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">Block(一) – Block 本质和截获变量</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/21/Block--_%20_block%20%E4%BF%AE%E9%A5%B0%E7%AC%A6/\" target=\"_blank\" rel=\"noopener\">Block(二) – _ _block 修饰符</a><br><a href=\"https://xiaopengmonsters.github.io/2018/08/06/Block--Block%20%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">Block(三) – Block 的内存管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"先思考两个问题\"><a href=\"#先思考两个问题\" class=\"headerlink\" title=\"先思考两个问题\"></a>先思考两个问题</h2><p><strong>题1：</strong></p>\n<p><img src=\"/img/Block题1.png\" alt=\"\"></p>\n<p>以下划线开头的 array 和以下划线开头的 strBlk 都是作为当前对象的两个成员变量，而 array 一般用 strong 关键字修饰，block 一般用 copy 修饰<br>在代码中首先对 array 进行创建，之后创建 strBlk ，在 block 的表达式当中，使用到了当前对象的 array 成员变量，之后再对这个 block 进行调用</p>\n<p>思考：这段代码有什么问题？</p>\n<p>答案：会产生循环引用，是自循环方式的循环引用</p>\n<p>由于当前对象是通过 copy 属性关键字声明的 block，所以当前对象对于这个 block 是有一个强引用的，而 block 的表达式中又使用到了当前对象的 array 成员变量，在截获变量知识中，关于 block 中所使用到的对象类的局部变量或者说成员变量，会连同其属性关键字一块截获，而 array 属性关键字是通过 strong 来修饰的，所以在这个 block 中就有一个 strong 类型的指针指向原来的这个对象或者说当前对象，由此就产生了一个循环引用</p>\n<p><img src=\"/img/Block题1答案.png\" alt=\"\"></p>\n<p>可以通过在当前栈上去声明或者说创建一个 _ _weak 所有权修饰符修饰的一个 weakArray 这么样的一个指针或者说变量来指向原对象的 array 成员变量，然后在这个 block 中使用创建的 weakArray ，由此就可以解除自循坏引用（是通过避免循环引用来解除的）</p>\n<p><strong>题2：</strong></p>\n<p><img src=\"/img/Block题2.png\" alt=\"\"></p>\n<p>在这个栈上面通过 _ _block 修饰符所修饰的变量来指向当前对象，同时当前对象的成员变量 block 在这里进行创建，block 的表达式当中有使用到 self 的一个 var 成员变量，在这个是使用的是 blockSelf 而不是直接使用当前对象，然后对其进行调用</p>\n<p>答案：</p>\n<ul>\n<li><strong>在 MRC 下</strong>，不会产生循环应用</li>\n<li><strong>在ARC下</strong>，会产生循环引用，引起内存泄漏</li>\n</ul>\n<p><img src=\"/img/ARC下的循环引用.png\" alt=\"\"></p>\n<p>比方说这个对象有一个成员变量 block，那么它持有 block，而这个 block 当中使用到了 <em> </em> block 修饰符所修饰的变量，所以 block 对象它持有了 <em> </em> block 变量，而 _ <em>block 变量它本身也是对原对象有一个强引用的持有的，因为 </em> _ block 变量它的指向是原来的对象，这种循环引用叫大环引用</p>\n<p><img src=\"/img/ARC下的循环引用答案.png\" alt=\"\"></p>\n<p>可以通过断环的方式解除</p>\n<p>具体的改写方案：（ARC下的解决方案）</p>\n<p><img src=\"/img/ARC下的解决方案.png\" alt=\"\"></p>\n<p>在 block 内部这个位置加上对 blockSelf 这个变量进行 nil 赋值操作就可以规避循环引用</p>\n<p>当调用这个 block 之后就会断开刚才所说的这个环然后就可以都得到内存的释放和销毁</p>\n<p>但是这种解决方案有一个弊端，就是说如果我们很长一段时间或者说永远都不会调用这个 block 的话，这个循环引用的环就会一直都存在</p>\n"},{"title":"CAlayer","date":"2016-12-18T05:54:01.000Z","description":"在平时开发中，我们经常使用到UILable、UIButton、UIImageView、UITextField等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。","_content":"\n主要从以下几个方面了解CAlayer：\n\n1. CALayer和UIView的关系\n2. CALayer的基本属性\n3. position和anchorPoint的作用\n4. CALayer和UIView的选择\n3. CALayer所属框架\n4. CALayer的隐式动画\n4. 自定义图层\n\n\n在平时开发中，我们经常使用到`UILable`、`UIButton`、`UIImageView`、`UITextField`等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。\n\n\n这里有[UIKit框架结构图](https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2)，此图来自简书@不懂技术的爱迪生。\n\n这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。\n\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\n\n# CALayer和UIView的关系\n* 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。\n\n```\n@property(nonatomic,readonly,retain) CALayer *layer; \n\n```\n\n* CALayer的基本属性\n\n``` bash\n 宽度和高度\n @property CGRect bounds;\n \n 位置(默认指中点，具体由anchorPoint决定)\n @property CGPoint position;\n \n 锚点(x,y的范围都是0-1)，决定了position的含义\n @property CGPoint anchorPoint;\n \n 背景颜色(CGColorRef类型)\n @property CGColorRef backgroundColor;\n \n 形变属性\n @property CATransform3D transform;\n \n 让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)\n @property CGRect contentsRect;\n \n 边框颜色(CGColorRef类型)\n @property CGColorRef borderColor;\n \n 边框宽度\n @property CGFloat borderWidth;\n \n 圆角半径\n @property CGFloat cornerRadius;\n \n 内容(比如设置为图片CGImageRef)\n @property(retain) id contents;\n```\n* CALayer的阴影属性\n\n```\n阴影颜色\n@property CGColorRef shadowColor;\n \n阴影不透明(0.0 ~ 1.0)\n@property float shadowOpacity;\n \n阴影偏移位置\n@property CGSize shadowOffset;\n```\n\n* CALayer的使用时的问题（存在的疑惑）\n\n首先，CALayer是定义在QuartzCore框架中的(Core Animation)\nCGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的\n \n其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。\n \n为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。\n\n## CALayer的position和anchorPoint\n\n position和anchorPoint是CALayer非常重要的2个属性\n\n\n```\n@property CGPoint position;\n```\n\n* position:它是用来设置当前的layer在父控件当中的位置的,\n所以它的坐标原点.以父控件的左上角为(0.0)点.\n\n```\n@property CGPoint anchorPoint;\n```\n\n\n\n* anchorPoint称为“定位点”、“锚点”\n决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.\n\n\n\n# UIView和CALayer的选择\n\n\n通过CALayer，就能做出跟UIView一样的界面效果\n \n但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，\n所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。\n当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。\n\n\n那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。\n\n# 隐式动画\n\n先了解是什么根层和非根层.\n\n\n* 根层:UIView内部自动关联着的那个layer我们称它是根层\n* 非根层:自己手动创建的层,称为非根层\n\n什么是隐式动画？\n\n* 隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.\n我们称这个默认产生的动画为隐式动画.\n\n关闭隐式动画效果\n\n\n* 首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.\n* 什么是事务?\n很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.\n\n```\n开启事务\n[CATransaction begin];\n\n设置事务没有动画\n[CATransaction setDisableActions:NO];\n\n设置隐式动画执行的时长\n[CATransaction setAnimationDuration:2];\n\n提交事务\n[CATransaction commit];\n```\n\n\n# 自定义图层\n\n## 方法一\n\n### 方法描述：\n\n\n设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n\n```\n//创建图层\nCALayer *layer = [CALayer layer];\n// 设置delegate  设置了CALayer的delegate，这里的self是指控制器\n\nlayer.delegate = self;\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n\n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n\n// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图\n[layer setNeedsDisplay];\n\n//将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n\n```\n\n```\n#pragma mark 画一个矩形框\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {\n    \n    // 设置蓝色\n    CGContextSetRGBStrokeColor(ctx, 0, 0, 1, 1);\n    \n    // 设置边框宽度\n    CGContextSetLineWidth(ctx, 10);\n    \n    // 添加一个跟层一样大的矩形到路径中\n    CGContextAddRect(ctx, layer.bounds);\n    \n    // 绘制路径\n    CGContextStrokePath(ctx);\n}\n\n```\n### 效果\n\n![](/img/五角星.png)\n\n## 方法二\n\n### 方法描述：\n* 创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图\n\n```\n//创建自定义图层类\nXPCALayer *layer = [XPCALayer layer];\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n \n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n    \n// 设置图层颜色\nlayer.backgroundColor = [UIColor redColor].CGColor;\n    \n// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图\n[layer setNeedsDisplay];\n    \n // 将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n```\n\n* 类内的实现，重写父类方法，绘制一个实心三角\n\n```\n- (void)drawInContext:(CGContextRef)ctx{\n    \n    // 设置为蓝色\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    \n    // 设置起点\n    CGContextMoveToPoint(ctx, 50, 0);\n    \n    // 从(50, 0)连线到(0, 100)\n    CGContextAddLineToPoint(ctx, 0, 100);\n    \n    // 从(0, 100)连线到(100, 100)\n    CGContextAddLineToPoint(ctx, 100, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 0, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 100, 100);\n    \n    // 合并路径，连接起点和终点\n    CGContextClosePath(ctx);\n    \n    // 绘制路径\n    CGContextFillPath(ctx);\n}\n\n```\n### 效果\n\n![](/img/正方形.png)\n\n\n## 总结\n\n### 1.注意\n\n\n* 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n \n###  2.UIView的详细显示过程\n * 当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法\n * 平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕\n  \n","source":"_posts/CAlayer.md","raw":"---\ntitle: CAlayer\ndate: 2016-12-18 13:54:01\ncategories: iOS\ndescription: 在平时开发中，我们经常使用到UILable、UIButton、UIImageView、UITextField等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。\ntags: [Objective-C]\n---\n\n主要从以下几个方面了解CAlayer：\n\n1. CALayer和UIView的关系\n2. CALayer的基本属性\n3. position和anchorPoint的作用\n4. CALayer和UIView的选择\n3. CALayer所属框架\n4. CALayer的隐式动画\n4. 自定义图层\n\n\n在平时开发中，我们经常使用到`UILable`、`UIButton`、`UIImageView`、`UITextField`等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。\n\n\n这里有[UIKit框架结构图](https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2)，此图来自简书@不懂技术的爱迪生。\n\n这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。\n\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\n\n# CALayer和UIView的关系\n* 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。\n\n```\n@property(nonatomic,readonly,retain) CALayer *layer; \n\n```\n\n* CALayer的基本属性\n\n``` bash\n 宽度和高度\n @property CGRect bounds;\n \n 位置(默认指中点，具体由anchorPoint决定)\n @property CGPoint position;\n \n 锚点(x,y的范围都是0-1)，决定了position的含义\n @property CGPoint anchorPoint;\n \n 背景颜色(CGColorRef类型)\n @property CGColorRef backgroundColor;\n \n 形变属性\n @property CATransform3D transform;\n \n 让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)\n @property CGRect contentsRect;\n \n 边框颜色(CGColorRef类型)\n @property CGColorRef borderColor;\n \n 边框宽度\n @property CGFloat borderWidth;\n \n 圆角半径\n @property CGFloat cornerRadius;\n \n 内容(比如设置为图片CGImageRef)\n @property(retain) id contents;\n```\n* CALayer的阴影属性\n\n```\n阴影颜色\n@property CGColorRef shadowColor;\n \n阴影不透明(0.0 ~ 1.0)\n@property float shadowOpacity;\n \n阴影偏移位置\n@property CGSize shadowOffset;\n```\n\n* CALayer的使用时的问题（存在的疑惑）\n\n首先，CALayer是定义在QuartzCore框架中的(Core Animation)\nCGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的\n \n其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。\n \n为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。\n\n## CALayer的position和anchorPoint\n\n position和anchorPoint是CALayer非常重要的2个属性\n\n\n```\n@property CGPoint position;\n```\n\n* position:它是用来设置当前的layer在父控件当中的位置的,\n所以它的坐标原点.以父控件的左上角为(0.0)点.\n\n```\n@property CGPoint anchorPoint;\n```\n\n\n\n* anchorPoint称为“定位点”、“锚点”\n决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.\n\n\n\n# UIView和CALayer的选择\n\n\n通过CALayer，就能做出跟UIView一样的界面效果\n \n但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，\n所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。\n当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。\n\n\n那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。\n\n# 隐式动画\n\n先了解是什么根层和非根层.\n\n\n* 根层:UIView内部自动关联着的那个layer我们称它是根层\n* 非根层:自己手动创建的层,称为非根层\n\n什么是隐式动画？\n\n* 隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.\n我们称这个默认产生的动画为隐式动画.\n\n关闭隐式动画效果\n\n\n* 首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.\n* 什么是事务?\n很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.\n\n```\n开启事务\n[CATransaction begin];\n\n设置事务没有动画\n[CATransaction setDisableActions:NO];\n\n设置隐式动画执行的时长\n[CATransaction setAnimationDuration:2];\n\n提交事务\n[CATransaction commit];\n```\n\n\n# 自定义图层\n\n## 方法一\n\n### 方法描述：\n\n\n设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n\n```\n//创建图层\nCALayer *layer = [CALayer layer];\n// 设置delegate  设置了CALayer的delegate，这里的self是指控制器\n\nlayer.delegate = self;\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n\n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n\n// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图\n[layer setNeedsDisplay];\n\n//将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n\n```\n\n```\n#pragma mark 画一个矩形框\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {\n    \n    // 设置蓝色\n    CGContextSetRGBStrokeColor(ctx, 0, 0, 1, 1);\n    \n    // 设置边框宽度\n    CGContextSetLineWidth(ctx, 10);\n    \n    // 添加一个跟层一样大的矩形到路径中\n    CGContextAddRect(ctx, layer.bounds);\n    \n    // 绘制路径\n    CGContextStrokePath(ctx);\n}\n\n```\n### 效果\n\n![](/img/五角星.png)\n\n## 方法二\n\n### 方法描述：\n* 创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图\n\n```\n//创建自定义图层类\nXPCALayer *layer = [XPCALayer layer];\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n \n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n    \n// 设置图层颜色\nlayer.backgroundColor = [UIColor redColor].CGColor;\n    \n// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图\n[layer setNeedsDisplay];\n    \n // 将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n```\n\n* 类内的实现，重写父类方法，绘制一个实心三角\n\n```\n- (void)drawInContext:(CGContextRef)ctx{\n    \n    // 设置为蓝色\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    \n    // 设置起点\n    CGContextMoveToPoint(ctx, 50, 0);\n    \n    // 从(50, 0)连线到(0, 100)\n    CGContextAddLineToPoint(ctx, 0, 100);\n    \n    // 从(0, 100)连线到(100, 100)\n    CGContextAddLineToPoint(ctx, 100, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 0, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 100, 100);\n    \n    // 合并路径，连接起点和终点\n    CGContextClosePath(ctx);\n    \n    // 绘制路径\n    CGContextFillPath(ctx);\n}\n\n```\n### 效果\n\n![](/img/正方形.png)\n\n\n## 总结\n\n### 1.注意\n\n\n* 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n \n###  2.UIView的详细显示过程\n * 当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法\n * 平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕\n  \n","slug":"CAlayer","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fn7000c66r28gcw1qm2","content":"<p>主要从以下几个方面了解CAlayer：</p>\n<ol>\n<li>CALayer和UIView的关系</li>\n<li>CALayer的基本属性</li>\n<li>position和anchorPoint的作用</li>\n<li>CALayer和UIView的选择</li>\n<li>CALayer所属框架</li>\n<li>CALayer的隐式动画</li>\n<li>自定义图层</li>\n</ol>\n<p>在平时开发中，我们经常使用到<code>UILable</code>、<code>UIButton</code>、<code>UIImageView</code>、<code>UITextField</code>等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。</p>\n<p>这里有<a href=\"https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2\" target=\"_blank\" rel=\"noopener\">UIKit框架结构图</a>，此图来自简书@不懂技术的爱迪生。</p>\n<p>这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。</p>\n<p>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。</p>\n<h1 id=\"CALayer和UIView的关系\"><a href=\"#CALayer和UIView的关系\" class=\"headerlink\" title=\"CALayer和UIView的关系\"></a>CALayer和UIView的关系</h1><ul>\n<li>在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) CALayer *layer;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的基本属性</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">宽度和高度</span><br><span class=\"line\">@property CGRect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">位置(默认指中点，具体由anchorPoint决定)</span><br><span class=\"line\">@property CGPoint position;</span><br><span class=\"line\"></span><br><span class=\"line\">锚点(x,y的范围都是0-1)，决定了position的含义</span><br><span class=\"line\">@property CGPoint anchorPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">背景颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">形变属性</span><br><span class=\"line\">@property CATransform3D transform;</span><br><span class=\"line\"></span><br><span class=\"line\">让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)</span><br><span class=\"line\">@property CGRect contentsRect;</span><br><span class=\"line\"></span><br><span class=\"line\">边框颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef borderColor;</span><br><span class=\"line\"></span><br><span class=\"line\">边框宽度</span><br><span class=\"line\">@property CGFloat borderWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">圆角半径</span><br><span class=\"line\">@property CGFloat cornerRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">内容(比如设置为图片CGImageRef)</span><br><span class=\"line\">@property(retain) id contents;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的阴影属性</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阴影颜色</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGColorRef shadowColor;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影不透明(<span class=\"number\">0.0</span> ~ <span class=\"number\">1.0</span>)</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>float shadowOpacity;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影偏移位置</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGSize shadowOffset;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的使用时的问题（存在的疑惑）</li>\n</ul>\n<p>首先，CALayer是定义在QuartzCore框架中的(Core Animation)<br>CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的</p>\n<p>其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。</p>\n<p>为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。</p>\n<h2 id=\"CALayer的position和anchorPoint\"><a href=\"#CALayer的position和anchorPoint\" class=\"headerlink\" title=\"CALayer的position和anchorPoint\"></a>CALayer的position和anchorPoint</h2><p> position和anchorPoint是CALayer非常重要的2个属性</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGPoint position;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>position:它是用来设置当前的layer在父控件当中的位置的,<br>所以它的坐标原点.以父控件的左上角为(0.0)点.</li>\n</ul>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property CGPoint <span class=\"built_in\">anchor</span>Point;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>anchorPoint称为“定位点”、“锚点”<br>决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.</li>\n</ul>\n<h1 id=\"UIView和CALayer的选择\"><a href=\"#UIView和CALayer的选择\" class=\"headerlink\" title=\"UIView和CALayer的选择\"></a>UIView和CALayer的选择</h1><p>通过CALayer，就能做出跟UIView一样的界面效果</p>\n<p>但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，<br>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。<br>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。</p>\n<p>那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。</p>\n<h1 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h1><p>先了解是什么根层和非根层.</p>\n<ul>\n<li>根层:UIView内部自动关联着的那个layer我们称它是根层</li>\n<li>非根层:自己手动创建的层,称为非根层</li>\n</ul>\n<p>什么是隐式动画？</p>\n<ul>\n<li>隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.<br>我们称这个默认产生的动画为隐式动画.</li>\n</ul>\n<p>关闭隐式动画效果</p>\n<ul>\n<li>首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.</li>\n<li>什么是事务?<br>很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开启事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\"></span><br><span class=\"line\">设置事务没有动画</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">设置隐式动画执行的时长</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setAnimationDuration:<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">提交事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义图层\"><a href=\"#自定义图层\" class=\"headerlink\" title=\"自定义图层\"></a>自定义图层</h1><h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><h3 id=\"方法描述：\"><a href=\"#方法描述：\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><p>设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建图层</span></span><br><span class=\"line\"><span class=\"built_in\">CALayer</span> *layer = [<span class=\"built_in\">CALayer</span> layer];</span><br><span class=\"line\"><span class=\"comment\">// 设置delegate  设置了CALayer的delegate，这里的self是指控制器</span></span><br><span class=\"line\"></span><br><span class=\"line\">layer.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#pragma</span> <span class=\"selector-tag\">mark</span> 画一个矩形框</span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawLayer</span><span class=\"selector-pseudo\">:(CALayer</span> *)<span class=\"selector-tag\">layer</span> <span class=\"selector-tag\">inContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBStrokeColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置边框宽度</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加一个跟层一样大的矩形到路径中</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddRect</span>(ctx, layer.bounds);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextStrokePath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/五角星.png\" alt=\"\"></p>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><h3 id=\"方法描述：-1\"><a href=\"#方法描述：-1\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><ul>\n<li>创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建自定义图层类</span></span><br><span class=\"line\">XPCALayer *layer = [XPCALayer layer];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 设置图层颜色</span></span><br><span class=\"line\">layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// 将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类内的实现，重写父类方法，绘制一个实心三角</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawInContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置为蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置起点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">50</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(50, 0)连线到(0, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(0, 100)连线到(100, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 合并路径，连接起点和终点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextClosePath</span>(ctx);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextFillPath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果-1\"><a href=\"#效果-1\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/正方形.png\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"1-注意\"><a href=\"#1-注意\" class=\"headerlink\" title=\"1.注意\"></a>1.注意</h3><ul>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n</ul>\n<h3 id=\"2-UIView的详细显示过程\"><a href=\"#2-UIView的详细显示过程\" class=\"headerlink\" title=\"2.UIView的详细显示过程\"></a>2.UIView的详细显示过程</h3><ul>\n<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法</li>\n<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>主要从以下几个方面了解CAlayer：</p>\n<ol>\n<li>CALayer和UIView的关系</li>\n<li>CALayer的基本属性</li>\n<li>position和anchorPoint的作用</li>\n<li>CALayer和UIView的选择</li>\n<li>CALayer所属框架</li>\n<li>CALayer的隐式动画</li>\n<li>自定义图层</li>\n</ol>\n<p>在平时开发中，我们经常使用到<code>UILable</code>、<code>UIButton</code>、<code>UIImageView</code>、<code>UITextField</code>等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。</p>\n<p>这里有<a href=\"https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2\" target=\"_blank\" rel=\"noopener\">UIKit框架结构图</a>，此图来自简书@不懂技术的爱迪生。</p>\n<p>这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。</p>\n<p>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。</p>\n<h1 id=\"CALayer和UIView的关系\"><a href=\"#CALayer和UIView的关系\" class=\"headerlink\" title=\"CALayer和UIView的关系\"></a>CALayer和UIView的关系</h1><ul>\n<li>在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) CALayer *layer;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的基本属性</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">宽度和高度</span><br><span class=\"line\">@property CGRect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">位置(默认指中点，具体由anchorPoint决定)</span><br><span class=\"line\">@property CGPoint position;</span><br><span class=\"line\"></span><br><span class=\"line\">锚点(x,y的范围都是0-1)，决定了position的含义</span><br><span class=\"line\">@property CGPoint anchorPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">背景颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">形变属性</span><br><span class=\"line\">@property CATransform3D transform;</span><br><span class=\"line\"></span><br><span class=\"line\">让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)</span><br><span class=\"line\">@property CGRect contentsRect;</span><br><span class=\"line\"></span><br><span class=\"line\">边框颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef borderColor;</span><br><span class=\"line\"></span><br><span class=\"line\">边框宽度</span><br><span class=\"line\">@property CGFloat borderWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">圆角半径</span><br><span class=\"line\">@property CGFloat cornerRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">内容(比如设置为图片CGImageRef)</span><br><span class=\"line\">@property(retain) id contents;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的阴影属性</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阴影颜色</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGColorRef shadowColor;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影不透明(<span class=\"number\">0.0</span> ~ <span class=\"number\">1.0</span>)</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>float shadowOpacity;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影偏移位置</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGSize shadowOffset;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的使用时的问题（存在的疑惑）</li>\n</ul>\n<p>首先，CALayer是定义在QuartzCore框架中的(Core Animation)<br>CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的</p>\n<p>其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。</p>\n<p>为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。</p>\n<h2 id=\"CALayer的position和anchorPoint\"><a href=\"#CALayer的position和anchorPoint\" class=\"headerlink\" title=\"CALayer的position和anchorPoint\"></a>CALayer的position和anchorPoint</h2><p> position和anchorPoint是CALayer非常重要的2个属性</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGPoint position;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>position:它是用来设置当前的layer在父控件当中的位置的,<br>所以它的坐标原点.以父控件的左上角为(0.0)点.</li>\n</ul>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property CGPoint <span class=\"built_in\">anchor</span>Point;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>anchorPoint称为“定位点”、“锚点”<br>决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.</li>\n</ul>\n<h1 id=\"UIView和CALayer的选择\"><a href=\"#UIView和CALayer的选择\" class=\"headerlink\" title=\"UIView和CALayer的选择\"></a>UIView和CALayer的选择</h1><p>通过CALayer，就能做出跟UIView一样的界面效果</p>\n<p>但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，<br>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。<br>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。</p>\n<p>那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。</p>\n<h1 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h1><p>先了解是什么根层和非根层.</p>\n<ul>\n<li>根层:UIView内部自动关联着的那个layer我们称它是根层</li>\n<li>非根层:自己手动创建的层,称为非根层</li>\n</ul>\n<p>什么是隐式动画？</p>\n<ul>\n<li>隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.<br>我们称这个默认产生的动画为隐式动画.</li>\n</ul>\n<p>关闭隐式动画效果</p>\n<ul>\n<li>首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.</li>\n<li>什么是事务?<br>很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开启事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\"></span><br><span class=\"line\">设置事务没有动画</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">设置隐式动画执行的时长</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setAnimationDuration:<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">提交事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义图层\"><a href=\"#自定义图层\" class=\"headerlink\" title=\"自定义图层\"></a>自定义图层</h1><h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><h3 id=\"方法描述：\"><a href=\"#方法描述：\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><p>设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建图层</span></span><br><span class=\"line\"><span class=\"built_in\">CALayer</span> *layer = [<span class=\"built_in\">CALayer</span> layer];</span><br><span class=\"line\"><span class=\"comment\">// 设置delegate  设置了CALayer的delegate，这里的self是指控制器</span></span><br><span class=\"line\"></span><br><span class=\"line\">layer.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#pragma</span> <span class=\"selector-tag\">mark</span> 画一个矩形框</span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawLayer</span><span class=\"selector-pseudo\">:(CALayer</span> *)<span class=\"selector-tag\">layer</span> <span class=\"selector-tag\">inContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBStrokeColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置边框宽度</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加一个跟层一样大的矩形到路径中</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddRect</span>(ctx, layer.bounds);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextStrokePath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/五角星.png\" alt=\"\"></p>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><h3 id=\"方法描述：-1\"><a href=\"#方法描述：-1\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><ul>\n<li>创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建自定义图层类</span></span><br><span class=\"line\">XPCALayer *layer = [XPCALayer layer];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 设置图层颜色</span></span><br><span class=\"line\">layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// 将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类内的实现，重写父类方法，绘制一个实心三角</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawInContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置为蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置起点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">50</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(50, 0)连线到(0, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(0, 100)连线到(100, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 合并路径，连接起点和终点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextClosePath</span>(ctx);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextFillPath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果-1\"><a href=\"#效果-1\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/正方形.png\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"1-注意\"><a href=\"#1-注意\" class=\"headerlink\" title=\"1.注意\"></a>1.注意</h3><ul>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n</ul>\n<h3 id=\"2-UIView的详细显示过程\"><a href=\"#2-UIView的详细显示过程\" class=\"headerlink\" title=\"2.UIView的详细显示过程\"></a>2.UIView的详细显示过程</h3><ul>\n<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法</li>\n<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕</li>\n</ul>\n"},{"title":"LLDB","date":"2017-01-05T05:10:18.000Z","description":null,"_content":"\n\n待续","source":"_posts/LLDB.md","raw":"---\ntitle: LLDB\ndate: 2017-01-05 13:10:18\n\ndescription: \n\ncategories: iOS\ntags: [Objective-C]\n---\n\n\n待续","slug":"LLDB","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fn9000g66r2dc71i68e","content":"<p>待续</p>\n","site":{"data":{}},"excerpt":"","more":"<p>待续</p>\n"},{"title":"NStimer准确吗","date":"2017-12-14T05:15:48.000Z","description":"NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件。","toc":false,"_content":"\n### 基本使用\n\n```\n /*   \n  * TimeInterval:设定执行时间    \n  * target:目标    \n  * @selector:方法(也就是目标(target)的行为(selector))  \n  * userInfo:用于向selector方法中传参数,  一般是self\n  * repeats:是否重复\n  */\n  \nNSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:.3 target:self selector:@selector(changeColor:) userInfo:view repeats:YES];    \n[timer fire];//开始执行\n\n//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)\n- (void)changeColor:(NSTimer *)sender\n{    \n//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),\n对于此题上面穿的是一个view对象,所以直接用UIview类型接收   \n UIView * vie = sender.userInfo;   \n //修改传入视图的背景色   \n vie.backgroundColor = [UIColor colorWithRed:arc4random() % 256 / 255.0 green:arc4random() % 256 / 255.0 blue:arc4random() % 256 / 255.0 alpha:1.0];\n}\n\n```\n\nNSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：\n\n1. NSTimer被添加到特定mode的runloop中\n2. 该mode型的runloop正在运行\n3. 到达激发时间。\n\n所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。\n\n### 不准的原因\n\n1. NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。\n2. 模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。\n\n* 这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n### 解决NStimer不准的问题\n\n1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果\n\n```\n- (void)timerMethod2 {\n    \n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n    \n    [thread start];\n}\n\n- (void)newThread{\n    \n    @autoreleasepool\n    \n    {\n        \n        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n        \n        [[NSRunLoop currentRunLoop] run];\n    }\n}\n\n```\n\n2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。\n\n\n**注意：**\n\n* 一开始的时候系统就为我们将主线程的main runloop隐式的启动了。\n\n* 在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop\n","source":"_posts/NStimer准确吗.md","raw":"---\ntitle: NStimer准确吗\ndate: 2017-12-14 13:15:48\n\ndescription: NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件。\n\ncategories: 问题记录\ntags: [Objective-C]\ntoc: false \n---\n\n### 基本使用\n\n```\n /*   \n  * TimeInterval:设定执行时间    \n  * target:目标    \n  * @selector:方法(也就是目标(target)的行为(selector))  \n  * userInfo:用于向selector方法中传参数,  一般是self\n  * repeats:是否重复\n  */\n  \nNSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:.3 target:self selector:@selector(changeColor:) userInfo:view repeats:YES];    \n[timer fire];//开始执行\n\n//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)\n- (void)changeColor:(NSTimer *)sender\n{    \n//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),\n对于此题上面穿的是一个view对象,所以直接用UIview类型接收   \n UIView * vie = sender.userInfo;   \n //修改传入视图的背景色   \n vie.backgroundColor = [UIColor colorWithRed:arc4random() % 256 / 255.0 green:arc4random() % 256 / 255.0 blue:arc4random() % 256 / 255.0 alpha:1.0];\n}\n\n```\n\nNSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：\n\n1. NSTimer被添加到特定mode的runloop中\n2. 该mode型的runloop正在运行\n3. 到达激发时间。\n\n所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。\n\n### 不准的原因\n\n1. NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。\n2. 模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。\n\n* 这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n### 解决NStimer不准的问题\n\n1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果\n\n```\n- (void)timerMethod2 {\n    \n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n    \n    [thread start];\n}\n\n- (void)newThread{\n    \n    @autoreleasepool\n    \n    {\n        \n        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n        \n        [[NSRunLoop currentRunLoop] run];\n    }\n}\n\n```\n\n2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。\n\n\n**注意：**\n\n* 一开始的时候系统就为我们将主线程的main runloop隐式的启动了。\n\n* 在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop\n","slug":"NStimer准确吗","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fna000i66r2zl8bwgoo","content":"<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">  * TimeInterval:设定执行时间    </span></span><br><span class=\"line\"><span class=\"comment\">  * target:目标    </span></span><br><span class=\"line\"><span class=\"comment\">  * @selector:方法(也就是目标(target)的行为(selector))  </span></span><br><span class=\"line\"><span class=\"comment\">  * userInfo:用于向selector方法中传参数,  一般是self</span></span><br><span class=\"line\"><span class=\"comment\">  * repeats:是否重复</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  </span><br><span class=\"line\">NSTimer * timer = [NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">.3</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">changeColor:</span>) <span class=\"string\">userInfo:</span>view <span class=\"string\">repeats:</span>YES];    </span><br><span class=\"line\">[timer fire];<span class=\"comment\">//开始执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">changeColor:</span>(NSTimer *)sender</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\"><span class=\"comment\">//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),</span></span><br><span class=\"line\">对于此题上面穿的是一个view对象,所以直接用UIview类型接收   </span><br><span class=\"line\"> UIView * vie = sender.userInfo;   </span><br><span class=\"line\"> <span class=\"comment\">//修改传入视图的背景色   </span></span><br><span class=\"line\"> vie.backgroundColor = [UIColor <span class=\"string\">colorWithRed:</span>arc4random() % <span class=\"number\">256</span> <span class=\"regexp\">/ 255.0 green:arc4random() % 256 /</span> <span class=\"number\">255.0</span> <span class=\"string\">blue:</span>arc4random() % <span class=\"number\">256</span> / <span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：</p>\n<ol>\n<li>NSTimer被添加到特定mode的runloop中</li>\n<li>该mode型的runloop正在运行</li>\n<li>到达激发时间。</li>\n</ol>\n<p>所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。</p>\n<h3 id=\"不准的原因\"><a href=\"#不准的原因\" class=\"headerlink\" title=\"不准的原因\"></a>不准的原因</h3><ol>\n<li>NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</li>\n<li>模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</li>\n</ol>\n<ul>\n<li>这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</li>\n</ul>\n<h3 id=\"解决NStimer不准的问题\"><a href=\"#解决NStimer不准的问题\" class=\"headerlink\" title=\"解决NStimer不准的问题\"></a>解决NStimer不准的问题</h3><p>1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)timerMethod2 &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(newThread) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)newThread&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(showTime) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[[NSRunLoop currentRunLoop]</span> <span class=\"selector-tag\">addTimer</span><span class=\"selector-pseudo\">:self.timer</span> <span class=\"selector-tag\">forMode</span><span class=\"selector-pseudo\">:NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n<p>[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</p>\n</li>\n<li><p>在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">  * TimeInterval:设定执行时间    </span></span><br><span class=\"line\"><span class=\"comment\">  * target:目标    </span></span><br><span class=\"line\"><span class=\"comment\">  * @selector:方法(也就是目标(target)的行为(selector))  </span></span><br><span class=\"line\"><span class=\"comment\">  * userInfo:用于向selector方法中传参数,  一般是self</span></span><br><span class=\"line\"><span class=\"comment\">  * repeats:是否重复</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  </span><br><span class=\"line\">NSTimer * timer = [NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">.3</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">changeColor:</span>) <span class=\"string\">userInfo:</span>view <span class=\"string\">repeats:</span>YES];    </span><br><span class=\"line\">[timer fire];<span class=\"comment\">//开始执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">changeColor:</span>(NSTimer *)sender</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\"><span class=\"comment\">//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),</span></span><br><span class=\"line\">对于此题上面穿的是一个view对象,所以直接用UIview类型接收   </span><br><span class=\"line\"> UIView * vie = sender.userInfo;   </span><br><span class=\"line\"> <span class=\"comment\">//修改传入视图的背景色   </span></span><br><span class=\"line\"> vie.backgroundColor = [UIColor <span class=\"string\">colorWithRed:</span>arc4random() % <span class=\"number\">256</span> <span class=\"regexp\">/ 255.0 green:arc4random() % 256 /</span> <span class=\"number\">255.0</span> <span class=\"string\">blue:</span>arc4random() % <span class=\"number\">256</span> / <span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：</p>\n<ol>\n<li>NSTimer被添加到特定mode的runloop中</li>\n<li>该mode型的runloop正在运行</li>\n<li>到达激发时间。</li>\n</ol>\n<p>所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。</p>\n<h3 id=\"不准的原因\"><a href=\"#不准的原因\" class=\"headerlink\" title=\"不准的原因\"></a>不准的原因</h3><ol>\n<li>NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</li>\n<li>模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</li>\n</ol>\n<ul>\n<li>这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</li>\n</ul>\n<h3 id=\"解决NStimer不准的问题\"><a href=\"#解决NStimer不准的问题\" class=\"headerlink\" title=\"解决NStimer不准的问题\"></a>解决NStimer不准的问题</h3><p>1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)timerMethod2 &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(newThread) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)newThread&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(showTime) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[[NSRunLoop currentRunLoop]</span> <span class=\"selector-tag\">addTimer</span><span class=\"selector-pseudo\">:self.timer</span> <span class=\"selector-tag\">forMode</span><span class=\"selector-pseudo\">:NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n<p>[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</p>\n</li>\n<li><p>在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</p>\n</li>\n</ul>\n"},{"title":"RunLoop[转]","date":"2017-04-20T07:21:18.000Z","description":"RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。","toc":"ture","_content":"\nRunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。\n\n## RunLoop 的概念\n\n一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：\n\n```\nfunction loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n```\n所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 \"接受消息->等待->处理\" 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。\n\n## RunLoop 与线程的关系\n\n苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:\n\n```\n/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef loopsDic;\n/// 访问 loopsDic 时的锁\nstatic CFSpinLock_t loopsLock;\n  \n/// 获取一个 pthread 对应的 RunLoop。\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    OSSpinLockLock(&loopsLock);\n     \n    if (!loopsDic) {\n        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。\n        loopsDic = CFDictionaryCreateMutable();\n        CFRunLoopRef mainLoop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);\n    }\n     \n    /// 直接从 Dictionary 里获取。\n    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));\n     \n    if (!loop) {\n        /// 取不到时，创建一个\n        loop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, thread, loop);\n        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。\n        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);\n    }\n     \n    OSSpinLockUnLock(&loopsLock);\n    return loop;\n}\n  \nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n  \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n```\n\n线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。\n\n## RunLoop 对外的接口\n\n在 CoreFoundation 里面关于 RunLoop 有5个类:\n\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n* CFRunLoopObserverRef\n\n其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png)\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。\n\n**CFRunLoopSourceRef** 是事件产生的地方。Source有两个版本：Source0 和 Source1。\n\n* Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n* Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。\n\n**CFRunLoopTimerRef** 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。\n\n**CFRunLoopObserverRef** 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒\n    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop\n};\n```\n\n上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。\n\n## RunLoop 的 Mode\n\nCFRunLoopMode 和 CFRunLoop 的结构大致如下：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n  \nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n这里有个概念叫 \"CommonModes\"：一个 Mode 可以将自己标记为\"Common\"属性（通过将其 ModeName 添加到 RunLoop 的 \"commonModes\" 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 \"Common\" 标记的所有Mode里。\n\n应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为\"Common\"属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 \"commonModeItems\" 中。\"commonModeItems\" 被 RunLoop 自动更新到所有具有\"Common\"属性的 Mode 里去。\n\n## RunLoop 的内部逻辑\nRunLoop 内部的逻辑大致如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png)\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n## 苹果用 RunLoop 实现的功能\n\n首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:\n\n1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。\n2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。\n3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。\n4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。\n5. kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。\n\n当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：\n\n```\n{\n    /// 1. 通知Observers，即将进入RunLoop\n    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);\n    do {\n  \n        /// 2. 通知 Observers: 即将触发 Timer 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);\n        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 4. 触发 Source0 (非基于port的) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 6. 通知Observers，即将进入休眠\n        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);\n  \n        /// 7. sleep to wait msg.\n        mach_msg() -> mach_msg_trap();\n         \n  \n        /// 8. 通知Observers，线程被唤醒\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);\n  \n        /// 9. 如果是被Timer唤醒的，回调Timer\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);\n  \n        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block\n        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);\n  \n        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);\n  \n  \n    } while (...);\n  \n    /// 10. 通知Observers，即将退出RunLoop\n    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);\n}\n\n```\n\n### 自动释放池 AutoreleasePool\n\nApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。\n\n* 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n* 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n### 事件响应\n\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n### 手势识别\n\n当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n### 界面更新\n\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n### 定时器\n\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。\n\n如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。\n\nCADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。\n\n### PerformSelecter\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n### 关于GCD\n\n实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。\n\n当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 **__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()** 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n## 整理文章\n\n[深入理解RunLoop](http://www.cocoachina.com/ios/20150601/11970.html)","source":"_posts/RunLoop.md","raw":"---\ntitle: RunLoop[转]\ndate: 2017-4-20 15:21:18\n\ndescription: RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。\n\ncategories: [RunLoop]\ntags: [Objective-C]\ntoc: ture \n---\n\nRunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。\n\n## RunLoop 的概念\n\n一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：\n\n```\nfunction loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n```\n所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 \"接受消息->等待->处理\" 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。\n\n## RunLoop 与线程的关系\n\n苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:\n\n```\n/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef loopsDic;\n/// 访问 loopsDic 时的锁\nstatic CFSpinLock_t loopsLock;\n  \n/// 获取一个 pthread 对应的 RunLoop。\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    OSSpinLockLock(&loopsLock);\n     \n    if (!loopsDic) {\n        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。\n        loopsDic = CFDictionaryCreateMutable();\n        CFRunLoopRef mainLoop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);\n    }\n     \n    /// 直接从 Dictionary 里获取。\n    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));\n     \n    if (!loop) {\n        /// 取不到时，创建一个\n        loop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, thread, loop);\n        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。\n        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);\n    }\n     \n    OSSpinLockUnLock(&loopsLock);\n    return loop;\n}\n  \nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n  \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n```\n\n线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。\n\n## RunLoop 对外的接口\n\n在 CoreFoundation 里面关于 RunLoop 有5个类:\n\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n* CFRunLoopObserverRef\n\n其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png)\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。\n\n**CFRunLoopSourceRef** 是事件产生的地方。Source有两个版本：Source0 和 Source1。\n\n* Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n* Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。\n\n**CFRunLoopTimerRef** 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。\n\n**CFRunLoopObserverRef** 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒\n    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop\n};\n```\n\n上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。\n\n## RunLoop 的 Mode\n\nCFRunLoopMode 和 CFRunLoop 的结构大致如下：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n  \nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n这里有个概念叫 \"CommonModes\"：一个 Mode 可以将自己标记为\"Common\"属性（通过将其 ModeName 添加到 RunLoop 的 \"commonModes\" 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 \"Common\" 标记的所有Mode里。\n\n应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为\"Common\"属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 \"commonModeItems\" 中。\"commonModeItems\" 被 RunLoop 自动更新到所有具有\"Common\"属性的 Mode 里去。\n\n## RunLoop 的内部逻辑\nRunLoop 内部的逻辑大致如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png)\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n## 苹果用 RunLoop 实现的功能\n\n首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:\n\n1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。\n2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。\n3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。\n4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。\n5. kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。\n\n当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：\n\n```\n{\n    /// 1. 通知Observers，即将进入RunLoop\n    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);\n    do {\n  \n        /// 2. 通知 Observers: 即将触发 Timer 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);\n        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 4. 触发 Source0 (非基于port的) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 6. 通知Observers，即将进入休眠\n        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);\n  \n        /// 7. sleep to wait msg.\n        mach_msg() -> mach_msg_trap();\n         \n  \n        /// 8. 通知Observers，线程被唤醒\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);\n  \n        /// 9. 如果是被Timer唤醒的，回调Timer\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);\n  \n        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block\n        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);\n  \n        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);\n  \n  \n    } while (...);\n  \n    /// 10. 通知Observers，即将退出RunLoop\n    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);\n}\n\n```\n\n### 自动释放池 AutoreleasePool\n\nApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。\n\n* 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n* 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n### 事件响应\n\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n### 手势识别\n\n当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n### 界面更新\n\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n### 定时器\n\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。\n\n如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。\n\nCADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。\n\n### PerformSelecter\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n### 关于GCD\n\n实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。\n\n当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 **__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()** 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n## 整理文章\n\n[深入理解RunLoop](http://www.cocoachina.com/ios/20150601/11970.html)","slug":"RunLoop","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnf000m66r200lk77vf","content":"<p>RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。</p>\n<h2 id=\"RunLoop-的概念\"><a href=\"#RunLoop-的概念\" class=\"headerlink\" title=\"RunLoop 的概念\"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = get_next_message();</span><br><span class=\"line\">        process_message(message);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>\n<h2 id=\"RunLoop-与线程的关系\"><a href=\"#RunLoop-与线程的关系\" class=\"headerlink\" title=\"RunLoop 与线程的关系\"></a>RunLoop 与线程的关系</h2><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> loopsDic;</span><br><span class=\"line\"><span class=\"comment\">/// 访问 loopsDic 时的锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFSpinLock_t</span> loopsLock;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    OSSpinLockLock(&amp;loopsLock);</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loopsDic) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class=\"line\">        loopsDic = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">/// 直接从 Dictionary 里获取。</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 取不到时，创建一个</span></span><br><span class=\"line\">        loop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class=\"line\">        <span class=\"comment\">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h2 id=\"RunLoop-对外的接口\"><a href=\"#RunLoop-对外的接口\" class=\"headerlink\" title=\"RunLoop 对外的接口\"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png\" alt=\"\"></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>\n<ul>\n<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>\n</ul>\n<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>\n<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>), <span class=\"comment\">// 即将进入Loop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>), <span class=\"comment\">// 即将处理 Timer</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 即将处理 Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>), <span class=\"comment\">// 刚从休眠中唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit          = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>), <span class=\"comment\">// 即将退出Loop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>\n<h2 id=\"RunLoop-的-Mode\"><a href=\"#RunLoop-的-Mode\" class=\"headerlink\" title=\"RunLoop 的 Mode\"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>\n<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>\n<h2 id=\"RunLoop-的内部逻辑\"><a href=\"#RunLoop-的内部逻辑\" class=\"headerlink\" title=\"RunLoop 的内部逻辑\"></a>RunLoop 的内部逻辑</h2><p>RunLoop 内部的逻辑大致如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png\" alt=\"\"></p>\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<h2 id=\"苹果用-RunLoop-实现的功能\"><a href=\"#苹果用-RunLoop-实现的功能\" class=\"headerlink\" title=\"苹果用 RunLoop 实现的功能\"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:</p>\n<ol>\n<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>\n<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>\n<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>\n</ol>\n<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    /// <span class=\"number\">1</span>. 通知Observers，即将进入RunLoop</span><br><span class=\"line\">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopEntry</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">2</span>. 通知 Observers: 即将触发 Timer 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeTimers</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        /// <span class=\"number\">3</span>. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeSources</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">4</span>. 触发 Source0 (非基于port的) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(<span class=\"name\">source0</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">6</span>. 通知Observers，即将进入休眠</span><br><span class=\"line\">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">; _objc_autoreleasePoolPush();</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">7</span>. sleep to wait msg.</span><br><span class=\"line\">        mach_msg() -&gt; mach_msg_trap()<span class=\"comment\">;</span></span><br><span class=\"line\">         </span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">8</span>. 通知Observers，线程被唤醒</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopAfterWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被Timer唤醒的，回调Timer</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(<span class=\"name\">timer</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class=\"line\">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class=\"name\">dispatched_block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(<span class=\"name\">source1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125; while (<span class=\"name\">...</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    /// <span class=\"number\">10</span>. 通知Observers，即将退出RunLoop</span><br><span class=\"line\">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopExit</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动释放池-AutoreleasePool\"><a href=\"#自动释放池-AutoreleasePool\" class=\"headerlink\" title=\"自动释放池 AutoreleasePool\"></a>自动释放池 AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<ul>\n<li>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li>\n<li>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>\n</ul>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>\n<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class=\"line\">    <span class=\"selector-tag\">QuartzCore</span><span class=\"selector-pseudo\">:CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::observer_callback</span>:</span><br><span class=\"line\">        <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::commit()</span>;</span><br><span class=\"line\">            <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Context</span><span class=\"selector-pseudo\">::commit_transaction()</span>;</span><br><span class=\"line\">                <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_and_display_if_needed()</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer layoutSublayers]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView layoutSubviews]</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::display_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer display]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView drawRect]</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>\n<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>\n<h3 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<h3 id=\"关于GCD\"><a href=\"#关于GCD\" class=\"headerlink\" title=\"关于GCD\"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>\n<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()</strong> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<h2 id=\"整理文章\"><a href=\"#整理文章\" class=\"headerlink\" title=\"整理文章\"></a>整理文章</h2><p><a href=\"http://www.cocoachina.com/ios/20150601/11970.html\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。</p>\n<h2 id=\"RunLoop-的概念\"><a href=\"#RunLoop-的概念\" class=\"headerlink\" title=\"RunLoop 的概念\"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = get_next_message();</span><br><span class=\"line\">        process_message(message);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>\n<h2 id=\"RunLoop-与线程的关系\"><a href=\"#RunLoop-与线程的关系\" class=\"headerlink\" title=\"RunLoop 与线程的关系\"></a>RunLoop 与线程的关系</h2><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> loopsDic;</span><br><span class=\"line\"><span class=\"comment\">/// 访问 loopsDic 时的锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFSpinLock_t</span> loopsLock;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    OSSpinLockLock(&amp;loopsLock);</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loopsDic) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class=\"line\">        loopsDic = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">/// 直接从 Dictionary 里获取。</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 取不到时，创建一个</span></span><br><span class=\"line\">        loop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class=\"line\">        <span class=\"comment\">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h2 id=\"RunLoop-对外的接口\"><a href=\"#RunLoop-对外的接口\" class=\"headerlink\" title=\"RunLoop 对外的接口\"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png\" alt=\"\"></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>\n<ul>\n<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>\n</ul>\n<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>\n<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>), <span class=\"comment\">// 即将进入Loop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>), <span class=\"comment\">// 即将处理 Timer</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 即将处理 Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>), <span class=\"comment\">// 刚从休眠中唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit          = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>), <span class=\"comment\">// 即将退出Loop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>\n<h2 id=\"RunLoop-的-Mode\"><a href=\"#RunLoop-的-Mode\" class=\"headerlink\" title=\"RunLoop 的 Mode\"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>\n<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>\n<h2 id=\"RunLoop-的内部逻辑\"><a href=\"#RunLoop-的内部逻辑\" class=\"headerlink\" title=\"RunLoop 的内部逻辑\"></a>RunLoop 的内部逻辑</h2><p>RunLoop 内部的逻辑大致如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png\" alt=\"\"></p>\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<h2 id=\"苹果用-RunLoop-实现的功能\"><a href=\"#苹果用-RunLoop-实现的功能\" class=\"headerlink\" title=\"苹果用 RunLoop 实现的功能\"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:</p>\n<ol>\n<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>\n<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>\n<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>\n</ol>\n<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    /// <span class=\"number\">1</span>. 通知Observers，即将进入RunLoop</span><br><span class=\"line\">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopEntry</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">2</span>. 通知 Observers: 即将触发 Timer 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeTimers</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        /// <span class=\"number\">3</span>. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeSources</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">4</span>. 触发 Source0 (非基于port的) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(<span class=\"name\">source0</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">6</span>. 通知Observers，即将进入休眠</span><br><span class=\"line\">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">; _objc_autoreleasePoolPush();</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">7</span>. sleep to wait msg.</span><br><span class=\"line\">        mach_msg() -&gt; mach_msg_trap()<span class=\"comment\">;</span></span><br><span class=\"line\">         </span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">8</span>. 通知Observers，线程被唤醒</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopAfterWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被Timer唤醒的，回调Timer</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(<span class=\"name\">timer</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class=\"line\">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class=\"name\">dispatched_block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(<span class=\"name\">source1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125; while (<span class=\"name\">...</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    /// <span class=\"number\">10</span>. 通知Observers，即将退出RunLoop</span><br><span class=\"line\">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopExit</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动释放池-AutoreleasePool\"><a href=\"#自动释放池-AutoreleasePool\" class=\"headerlink\" title=\"自动释放池 AutoreleasePool\"></a>自动释放池 AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<ul>\n<li>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li>\n<li>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>\n</ul>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>\n<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class=\"line\">    <span class=\"selector-tag\">QuartzCore</span><span class=\"selector-pseudo\">:CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::observer_callback</span>:</span><br><span class=\"line\">        <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::commit()</span>;</span><br><span class=\"line\">            <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Context</span><span class=\"selector-pseudo\">::commit_transaction()</span>;</span><br><span class=\"line\">                <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_and_display_if_needed()</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer layoutSublayers]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView layoutSubviews]</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::display_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer display]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView drawRect]</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>\n<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>\n<h3 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<h3 id=\"关于GCD\"><a href=\"#关于GCD\" class=\"headerlink\" title=\"关于GCD\"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>\n<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()</strong> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<h2 id=\"整理文章\"><a href=\"#整理文章\" class=\"headerlink\" title=\"整理文章\"></a>整理文章</h2><p><a href=\"http://www.cocoachina.com/ios/20150601/11970.html\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a></p>\n"},{"title":"Runtime和消息转发(三)","date":"2017-02-14T03:20:28.000Z","description":"之前有学习过Runtime相关知识，但是都是比较零散的积累，有了自己的博客，那就是时候系统的整理学习Runtime的相关知识了。","_content":"\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n# 什么是Runtime\n\n* Runtime简称运行时。OC就是运行时机制，其中最主要的是`消息机制`。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数。\n* 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。\n* Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。\n\n## 消息机制（方法调用的本质）\n* 方法调用的本质，就是让对象发送消息。\n* OC中所有方法的调用都会转化为objc_msgSend来实现。\n\n### SEL\n其定义如下\n\n```\ntypedef struct objc_selector *SEL；     \n```\n\nSEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。\n\n### IMP\n\nIMP实际上是一个函数指针，指向方法实现的地址。\n其定义如下:\n\n```\nid (*IMP)(id, SEL,...)\n```\n\n第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)\n\n第二个参数：是方法选择器(selector)\n\n接下来的参数：方法的参数列表。\n\n### Method\n\nMethod方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：\n\n```\ntypedef struct objc_method *Method\n    struct objc_method{\n        SEL method_name      OBJC2_UNAVAILABLE; // 方法名\n        char *method_types   OBJC2_UNAVAILABLE;\n        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现\n    }\n```\n可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。\n\n**原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法**\n\n![](/img/消息机制.png)\n\n\n下面演示了这样一个消息的基本框架：\n当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。\n如果找到，执行该方法,如未找到继续执行下面的步骤\n\nobjc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。\n如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。\n依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 \n\n## 消息转发\n\n\n### 1、动态方法解析\n\n\n如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用`class_addMethod`函数动态提供相对于的方法实现\n\n```\n/** 如果调用的是实例方法，则会调用该方法 */\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n\n/** 如果调用的是类方法，则会调用该方法 */\n+ (BOOL)resolveClassMethod:(SEL)sel;\n\n```\n\n下面举一个例子：\n\n1. 创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的\n2. 进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（[这里](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)会详细讲解Runtime动态添加方法）\n\n当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）\n\n```\nvoid eat(id self, SEL _cmd, NSString *string){\n    NSLog(@\"add C IMP %@\", string);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    if (sel == @selector(eat)) {\n\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n### 2、消息转发\n\n* 如果不对上面的`resolveInstanceMethod`方法做任何处理，直接调用父类方法，那么，系统会来到了`forwardingTargetForSelector`方法\n\n\n```\n/** 这个方法返回你需要转发消息的对象 */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n\n```\n\n\n接着上面的例子：\n\n1. 不对`resolveInstanceMethod`进行处理，直接调用父类方法。\n2. 新建了一个熊猫类Panda，并且实现了Panda的eat方法。\n\n``` \n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector;{\n    return [[Panda alloc]init];\n}\n```\n\n\n当程序来到`forwardingTargetForSelector`方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。\n\n\n* 如果`forwardingTargetForSelector`方法也不实现的话，那么程序会进入下面两个函数\n\n\n\n```\n/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;\n\n/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n\nunrecognized selector sent to instance这个错误的原因，就是因为`methodSignatureForSelector`这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。\n\n所以我们需要做的是自己新建方法签名，再在`forwardInvocation`中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。\n\n\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    NSString *sel = NSStringFromSelector(aSelector);\n    \n    if ([sel isEqualToString:@\"eat\"]) {\n        \n        /** 为你的转发发放手动生成签名 */\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n    }\n\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    SEL selector = [anInvocation selector];\n    \n    /** 新建需要转发消息的对象 */\n    Panda *panda = [[Panda alloc]init];\n   \n    if ([panda respondsToSelector:selector]) {\n        \n        /** 唤醒这个方法 */\n        [anInvocation invokeWithTarget:panda];\n    }\n}\n\n```\n\n\n### Runtime文章链接\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n","source":"_posts/Runtime.md","raw":"---\ntitle: Runtime和消息转发(三)\ndate: 2017-02-14 11:20:28\n\ndescription: 之前有学习过Runtime相关知识，但是都是比较零散的积累，有了自己的博客，那就是时候系统的整理学习Runtime的相关知识了。\n\ncategories: Runtime\ntags: [Objective-C,Runtime]\n---\n\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n# 什么是Runtime\n\n* Runtime简称运行时。OC就是运行时机制，其中最主要的是`消息机制`。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数。\n* 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。\n* Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。\n\n## 消息机制（方法调用的本质）\n* 方法调用的本质，就是让对象发送消息。\n* OC中所有方法的调用都会转化为objc_msgSend来实现。\n\n### SEL\n其定义如下\n\n```\ntypedef struct objc_selector *SEL；     \n```\n\nSEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。\n\n### IMP\n\nIMP实际上是一个函数指针，指向方法实现的地址。\n其定义如下:\n\n```\nid (*IMP)(id, SEL,...)\n```\n\n第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)\n\n第二个参数：是方法选择器(selector)\n\n接下来的参数：方法的参数列表。\n\n### Method\n\nMethod方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：\n\n```\ntypedef struct objc_method *Method\n    struct objc_method{\n        SEL method_name      OBJC2_UNAVAILABLE; // 方法名\n        char *method_types   OBJC2_UNAVAILABLE;\n        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现\n    }\n```\n可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。\n\n**原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法**\n\n![](/img/消息机制.png)\n\n\n下面演示了这样一个消息的基本框架：\n当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。\n如果找到，执行该方法,如未找到继续执行下面的步骤\n\nobjc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。\n如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。\n依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 \n\n## 消息转发\n\n\n### 1、动态方法解析\n\n\n如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用`class_addMethod`函数动态提供相对于的方法实现\n\n```\n/** 如果调用的是实例方法，则会调用该方法 */\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n\n/** 如果调用的是类方法，则会调用该方法 */\n+ (BOOL)resolveClassMethod:(SEL)sel;\n\n```\n\n下面举一个例子：\n\n1. 创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的\n2. 进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（[这里](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)会详细讲解Runtime动态添加方法）\n\n当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）\n\n```\nvoid eat(id self, SEL _cmd, NSString *string){\n    NSLog(@\"add C IMP %@\", string);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    if (sel == @selector(eat)) {\n\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n### 2、消息转发\n\n* 如果不对上面的`resolveInstanceMethod`方法做任何处理，直接调用父类方法，那么，系统会来到了`forwardingTargetForSelector`方法\n\n\n```\n/** 这个方法返回你需要转发消息的对象 */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n\n```\n\n\n接着上面的例子：\n\n1. 不对`resolveInstanceMethod`进行处理，直接调用父类方法。\n2. 新建了一个熊猫类Panda，并且实现了Panda的eat方法。\n\n``` \n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector;{\n    return [[Panda alloc]init];\n}\n```\n\n\n当程序来到`forwardingTargetForSelector`方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。\n\n\n* 如果`forwardingTargetForSelector`方法也不实现的话，那么程序会进入下面两个函数\n\n\n\n```\n/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;\n\n/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n\nunrecognized selector sent to instance这个错误的原因，就是因为`methodSignatureForSelector`这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。\n\n所以我们需要做的是自己新建方法签名，再在`forwardInvocation`中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。\n\n\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    NSString *sel = NSStringFromSelector(aSelector);\n    \n    if ([sel isEqualToString:@\"eat\"]) {\n        \n        /** 为你的转发发放手动生成签名 */\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n    }\n\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    SEL selector = [anInvocation selector];\n    \n    /** 新建需要转发消息的对象 */\n    Panda *panda = [[Panda alloc]init];\n   \n    if ([panda respondsToSelector:selector]) {\n        \n        /** 唤醒这个方法 */\n        [anInvocation invokeWithTarget:panda];\n    }\n}\n\n```\n\n\n### Runtime文章链接\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n","slug":"Runtime","published":1,"updated":"2018-09-11T08:39:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnh000p66r28zaji05o","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<h1 id=\"什么是Runtime\"><a href=\"#什么是Runtime\" class=\"headerlink\" title=\"什么是Runtime\"></a>什么是Runtime</h1><ul>\n<li>Runtime简称运行时。OC就是运行时机制，其中最主要的是<code>消息机制</code>。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数。</li>\n<li>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>\n<li>Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。</li>\n</ul>\n<h2 id=\"消息机制（方法调用的本质）\"><a href=\"#消息机制（方法调用的本质）\" class=\"headerlink\" title=\"消息机制（方法调用的本质）\"></a>消息机制（方法调用的本质）</h2><ul>\n<li>方法调用的本质，就是让对象发送消息。</li>\n<li>OC中所有方法的调用都会转化为objc_msgSend来实现。</li>\n</ul>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p>其定义如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>；</span></span><br></pre></td></tr></table></figure>\n<p>SEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。</p>\n<h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id (<span class=\"name\">*IMP</span>)(<span class=\"name\">id</span>, SEL,...)</span><br></pre></td></tr></table></figure>\n<p>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)</p>\n<p>第二个参数：是方法选择器(selector)</p>\n<p>接下来的参数：方法的参数列表。</p>\n<h3 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h3><p>Method方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *<span class=\"function\"><span class=\"keyword\">Method</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">struct</span> <span class=\"title\">objc_method</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        char *method_types   OBJC2_UNAVAILABLE;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    &#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>\n<p><strong>原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法</strong></p>\n<p><img src=\"/img/消息机制.png\" alt=\"\"></p>\n<p>下面演示了这样一个消息的基本框架：<br>当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。<br>如果找到，执行该方法,如未找到继续执行下面的步骤</p>\n<p>objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。<br>如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。<br>依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 </p>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><h3 id=\"1、动态方法解析\"><a href=\"#1、动态方法解析\" class=\"headerlink\" title=\"1、动态方法解析\"></a>1、动态方法解析</h3><p>如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用<code>class_addMethod</code>函数动态提供相对于的方法实现</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 如果调用的是实例方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 如果调用的是类方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveClassMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure>\n<p>下面举一个例子：</p>\n<ol>\n<li>创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的</li>\n<li>进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（<a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">这里</a>会详细讲解Runtime动态添加方法）</li>\n</ol>\n<p>当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">eat</span>(id self, SEL _cmd, NSString *string)&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">NSLog</span>(@<span class=\"string\">\"add C IMP %@\"</span>, string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (sel == <span class=\"variable\">@selector</span>(eat)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">class_addMethod</span>(self, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super resolveInstanceMethod:sel]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、消息转发\"><a href=\"#2、消息转发\" class=\"headerlink\" title=\"2、消息转发\"></a>2、消息转发</h3><ul>\n<li>如果不对上面的<code>resolveInstanceMethod</code>方法做任何处理，直接调用父类方法，那么，系统会来到了<code>forwardingTargetForSelector</code>方法</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法返回你需要转发消息的对象 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (id)<span class=\"selector-tag\">forwardingTargetForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br></pre></td></tr></table></figure>\n<p>接着上面的例子：</p>\n<ol>\n<li>不对<code>resolveInstanceMethod</code>进行处理，直接调用父类方法。</li>\n<li>新建了一个熊猫类Panda，并且实现了Panda的eat方法。</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)<span class=\"string\">resolveInstanceMethod:</span>(SEL)sel&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> <span class=\"string\">resolveInstanceMethod:</span>sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)<span class=\"string\">forwardingTargetForSelector:</span>(SEL)aSelector;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[Panda alloc]init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序来到<code>forwardingTargetForSelector</code>方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。</p>\n<ul>\n<li>如果<code>forwardingTargetForSelector</code>方法也不实现的话，那么程序会进入下面两个函数</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSMethodSignature *)<span class=\"selector-tag\">methodSignatureForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">forwardInvocation</span><span class=\"selector-pseudo\">:(NSInvocation</span> *)<span class=\"selector-tag\">anInvocation</span>;</span><br></pre></td></tr></table></figure>\n<p>unrecognized selector sent to instance这个错误的原因，就是因为<code>methodSignatureForSelector</code>这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。</p>\n<p>所以我们需要做的是自己新建方法签名，再在<code>forwardInvocation</code>中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *sel = <span class=\"built_in\">NSStringFromSelector</span>(aSelector);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sel isEqualToString:<span class=\"string\">@\"eat\"</span>]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 为你的转发发放手动生成签名 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SEL selector = [anInvocation selector];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 新建需要转发消息的对象 */</span></span><br><span class=\"line\">    Panda *panda = [[Panda alloc]init];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([panda respondsToSelector:selector]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 唤醒这个方法 */</span></span><br><span class=\"line\">        [anInvocation invokeWithTarget:panda];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Runtime文章链接\"><a href=\"#Runtime文章链接\" class=\"headerlink\" title=\"Runtime文章链接\"></a>Runtime文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<h1 id=\"什么是Runtime\"><a href=\"#什么是Runtime\" class=\"headerlink\" title=\"什么是Runtime\"></a>什么是Runtime</h1><ul>\n<li>Runtime简称运行时。OC就是运行时机制，其中最主要的是<code>消息机制</code>。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数。</li>\n<li>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>\n<li>Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。</li>\n</ul>\n<h2 id=\"消息机制（方法调用的本质）\"><a href=\"#消息机制（方法调用的本质）\" class=\"headerlink\" title=\"消息机制（方法调用的本质）\"></a>消息机制（方法调用的本质）</h2><ul>\n<li>方法调用的本质，就是让对象发送消息。</li>\n<li>OC中所有方法的调用都会转化为objc_msgSend来实现。</li>\n</ul>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p>其定义如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>；</span></span><br></pre></td></tr></table></figure>\n<p>SEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。</p>\n<h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id (<span class=\"name\">*IMP</span>)(<span class=\"name\">id</span>, SEL,...)</span><br></pre></td></tr></table></figure>\n<p>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)</p>\n<p>第二个参数：是方法选择器(selector)</p>\n<p>接下来的参数：方法的参数列表。</p>\n<h3 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h3><p>Method方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *<span class=\"function\"><span class=\"keyword\">Method</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">struct</span> <span class=\"title\">objc_method</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        char *method_types   OBJC2_UNAVAILABLE;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    &#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>\n<p><strong>原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法</strong></p>\n<p><img src=\"/img/消息机制.png\" alt=\"\"></p>\n<p>下面演示了这样一个消息的基本框架：<br>当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。<br>如果找到，执行该方法,如未找到继续执行下面的步骤</p>\n<p>objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。<br>如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。<br>依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 </p>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><h3 id=\"1、动态方法解析\"><a href=\"#1、动态方法解析\" class=\"headerlink\" title=\"1、动态方法解析\"></a>1、动态方法解析</h3><p>如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用<code>class_addMethod</code>函数动态提供相对于的方法实现</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 如果调用的是实例方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 如果调用的是类方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveClassMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure>\n<p>下面举一个例子：</p>\n<ol>\n<li>创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的</li>\n<li>进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（<a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">这里</a>会详细讲解Runtime动态添加方法）</li>\n</ol>\n<p>当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">eat</span>(id self, SEL _cmd, NSString *string)&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">NSLog</span>(@<span class=\"string\">\"add C IMP %@\"</span>, string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (sel == <span class=\"variable\">@selector</span>(eat)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">class_addMethod</span>(self, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super resolveInstanceMethod:sel]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、消息转发\"><a href=\"#2、消息转发\" class=\"headerlink\" title=\"2、消息转发\"></a>2、消息转发</h3><ul>\n<li>如果不对上面的<code>resolveInstanceMethod</code>方法做任何处理，直接调用父类方法，那么，系统会来到了<code>forwardingTargetForSelector</code>方法</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法返回你需要转发消息的对象 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (id)<span class=\"selector-tag\">forwardingTargetForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br></pre></td></tr></table></figure>\n<p>接着上面的例子：</p>\n<ol>\n<li>不对<code>resolveInstanceMethod</code>进行处理，直接调用父类方法。</li>\n<li>新建了一个熊猫类Panda，并且实现了Panda的eat方法。</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)<span class=\"string\">resolveInstanceMethod:</span>(SEL)sel&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> <span class=\"string\">resolveInstanceMethod:</span>sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)<span class=\"string\">forwardingTargetForSelector:</span>(SEL)aSelector;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[Panda alloc]init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序来到<code>forwardingTargetForSelector</code>方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。</p>\n<ul>\n<li>如果<code>forwardingTargetForSelector</code>方法也不实现的话，那么程序会进入下面两个函数</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSMethodSignature *)<span class=\"selector-tag\">methodSignatureForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">forwardInvocation</span><span class=\"selector-pseudo\">:(NSInvocation</span> *)<span class=\"selector-tag\">anInvocation</span>;</span><br></pre></td></tr></table></figure>\n<p>unrecognized selector sent to instance这个错误的原因，就是因为<code>methodSignatureForSelector</code>这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。</p>\n<p>所以我们需要做的是自己新建方法签名，再在<code>forwardInvocation</code>中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *sel = <span class=\"built_in\">NSStringFromSelector</span>(aSelector);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sel isEqualToString:<span class=\"string\">@\"eat\"</span>]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 为你的转发发放手动生成签名 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SEL selector = [anInvocation selector];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 新建需要转发消息的对象 */</span></span><br><span class=\"line\">    Panda *panda = [[Panda alloc]init];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([panda respondsToSelector:selector]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 唤醒这个方法 */</span></span><br><span class=\"line\">        [anInvocation invokeWithTarget:panda];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Runtime文章链接\"><a href=\"#Runtime文章链接\" class=\"headerlink\" title=\"Runtime文章链接\"></a>Runtime文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n"},{"title":"Runtime--Runtime的数据结构(一)","date":"2018-05-03T03:01:18.000Z","description":"Runtime 的基础数据结构：objc_object、objc_class、isa 指针、method_t","_content":"\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n**目录**\n\n* objc_object\n* objc_class\n* isa 指针\n* objc_class 中的成员结构\n* Runtime 的基础数据结构总结图\n\n## objc_object\n\n![](/imag/objc_object.png)\n\n我们平时使用的所有的对象都是 id 类型，对应到 Runtime 中就是 objc_object 的结构体，这个结构体中主要包含以下几个成员部分：\n\n1. isa_t：  isa_t 是一个共用体\n2. 关于 isa 操作的相关方法：提供了 isa 操作相关的一些方法，比如通过 objc_object 这个结构体来获取它的 isa 所指向的类对象，包括通过类对象的 isa 指针获取它的元类对象一些遍历的方法\n3. 弱引用相关方法：比如说，标记一个对象，它是否曾经有过弱指针\n4. 关联对象相关方法：比说，这个对象，为它设置了一些关联属性，关联属性的一些方法也体现在 objc_object 结构体当中\n5. 内存管理相关：比如， 在 MRC 下面经常使用到的 retain，relese，包括 ARC，MRC 下面都可以用到的 艾特aotorelesepool \n\n\n## objc_class\n\n\n![](/img/objc_class.png)\n\n在 OC 当中使用的类对应的是 Runtime 中就是 objc_class 的结构体，objc_class 继承自 objc_object （class 也是一个对象，称类对象）\n\nobjc_class包含：\n\n1. 拥有一个 superClass 指针，对指向的类型也是 class ，如果说是一个类对象的话，那么它的 superClass 指针指向的就是他的父类对象，也就是平时说的类与父类的关系，实际上就是通过 objc_class 中 superClass 这么一个成员变量来定义的\n2. 包含一个cache_t 成员变量，cache_t表达了方法缓存的一个结构，在消息传递的过程中，或使用方法缓存的数据结构\n3. 关于 class_data_bits_t 数据结构：实际上我们关于一个类所定义的一些变量、属性、包括他的一些方法都在 bits 成员结构当中\n\n## isa 指针\n\n### isa指针相关说明\n\n![](/img/isa指针.png)\n\nisa指针是 C++ 当中的一个共用体，在 OC 中是定义成了 isa_t 的名称\n\n对于一个共用体来说，无论是在64位架构上面还是在32位架构上面，实际上都是32个0或者1的数字，或者64个0或者1的数字，大多数及其都是64位的\n\nisa指针分两种类型，一种是指针型的 isa ，一种是非指针型的 isa\n\n1. 指针型的 isa 64位的0或者说1它的整体内容代表的是 Class 的地址（比如对于使用一个 objc_object 这么一个对象的时候，可以通过 isa 的内容来获取到它的类对象的地址）\n2. 非指针型的 isa 的值的部分代表 Class 的地址（比如针对64位架构上面的am（没听清）架构，可能是对应的其中某一部分的33位或者44位所代表的值，意味着是 Class 的地址，不是说整个64位都代表 Class 的地址）这样做的目的是因为在寻址过程当中，实际上只有三四十位的位数就可以保证我们寻找到所有的 Class 的地址，多出的这些位可以用来存储其他的相关内容，来达到节省内存的目的\n\n### isa 指向\n\n![](/img/isa指向.png)\n\n关于对象，它指向的是类对象\n\n* 比如拥有一个实例，实例就是 OC 中对应的 id 类型，表述在 Runtime 中就是 objc_object ，objc_object 当中有一个 isa 指针，对于实例来说它的 isa 指针就指向他对应的 class ，或者说称之为**类对象**\n\n关于类对象，isa 的指向是其元类对象\n\n* class 代表的是 objc_class ,而 objc_class 又继承自 objc_object，所以 class 实际上也是一种对象，称之为类对象，那么class当中由于继承自 objc_object ，所以也有一个 isa 指针，这个 isa 指针指向的是其元类对象，那么在进行方法调用的时候，调用一个实例的实例方法实际上是通过 isa 指针到它的类对象当中去进行方法查找，如果调用的是一个类方法，那么是通过类对象的 isa 指向他的元类对象当中去查找\n\n## objc_class 中的成员结构\n\n### cache_t\n\n* 用于**快速**查找方法执行函数\n\n* 是可**增量扩展**的**嘻哈表**结构\n\n* 是**局部性原理**的最佳应用\n\n1. 实际上是用于快速查找方法执行函数的机构，比如说在调用一个方法的时候，如果有一个缓存，就不用到它对应的方法列表当中去逐一遍历去查找这个方法的具体实现，可以提高方法调用的速度，或者说消息传递的速度\n\n2. 是可增量扩展的哈希表结构。增量扩展体现在，当这个结构存储的量在增大的过程中，他也会逐渐去增量的扩大它的内存空间来支持更多的缓存，用哈希表来实现数据结构主要是为了提高查找效率\n\n3. cache_t 这个数据结构实际上是计算机局部性原理的最佳应用，局部性原理指的是，一般在调用放大的时候，可能往往调用的就那么几个方法，也就是这几个方法是调用频次最高的，这个时候把调用频次最高的方法放到缓存当中，下次的命中率就会更高一些，这个就是局部性原理的一个简单说明\n\n***cache_t 具体的数据结构说明***\n\n![](/img/cache_t具体的数据结构说明.png)\n\n可以理解是由一个数组来实现的，数组中每一个对象都是 bucke_t 这么一个结构体来封装的，对于bucke_t 它有两个主要的成员变量，第一个是 key 第二个是 IMP ，key 对应 OC 当中的 selecter，在调用一个方法的时候，他实际上是一个选择器 SEL ，可以通过方法选择器的名称来寻找一个方法的具体实现，IMP 可以理解为是一个无类型的函数指针\n那么比如说给你一个 key，可以通过哈希查找算法来定位当前这个key所对应的 bucket_t 的数据结构位于数组当中的哪个位置，然后当定位到这个位置之后，就可以提取 bucket_t 里面的具体函数的实现（IMP）来调用函数\n\n\n### class-data-bits-t\n\n* **class-data-bits-t** 主要是对 **class-rw-t** 的封装\n\n* **class-rw-t** 代表了类相关的**读写**信息、对 class_ro_t 的封装\n\n* **class-ro-t** 代表了类相关的**只读**信息\n\nclass-rw-t 代表了类相关的读写信息，比如说给类添加的一些分类当中的一些方法或者说属性，以及协议都在 class-rw-t 当中（rw 是 read write 的简写）\n\n### class-rw-t\n\n![](/img/class_rw_t.png)\n\nclass_rw_t 主要包含第一部分 class_ro_t，第二部分 protocols（协议），第三部分 properties（属性），第四部分methods（方法），在给分类创建的协议属性方法都是在这三个数据结构当中，这三个数据结构是一个二维数组，都继承自 list_array_tt 这么样一个结构，对于二位数组解释：以 methods 为例，数组（一维）当中每一个元素又是一个数组（二维），二维数组当中所装载的内容是 method_t 数据结构 \n\n比说添加了一个分类 A ，那么分类 A 当中的所有的方法以一个列表的形势作为二维数组的其中一个元素，第二个分类当中的方法列表就作为二维数组的第二个元素，以此类推\n\n### class_ro_t\n\n![](/img/class_ro_t.png)\n\nclass_ro_t 主要由以下几个部分组成\n\n1. 第一个是关于这个类的类名\n2. ivars，就是我们声明或者定义的一些类的成员变量\n3. 第三个是类的属性\n4. 第四个是类遵从的一些协议\n5. 最后一个是这个类添加的一些方法列表\n\n关于 ivars ，properties，protocols，methodList 实际上都是一维数组，这里的方法列表等内容和 class_rw_t 中的方法列表等内容是有区别的，前者是一维数组，后者是二维数组，同样的在 class_rw_t 当中，方法列表当中存储的内容一般情况下都是分类当中添加的一些方法内容，关于 class_ro_t 当中这样的一维数组的方法列表当中存储的就是我们原始定义的或者说添加的一些类的方法列表内容\n\n那么 methodList 当中所对应的每一个数组原元素实际上也是 method_t 数据结构 ，method_t 实际上是对一个方法的抽象说明\n\n### method_t\n\n![](/img/method_t.png)\n\n### type Encodings \n\n![](/img/typeEncodings.png)\n\nconst char*类型的 types 成员属性，实际上它的表达结构大致是这样的\n\n首先它是不可变的字符指针，它所指向的字符组成结构大致是这样的，首先第一个位置永远都是函数的返回值（为什么是在第一个位置：在定义一个函数的时候函数的参数可以有多个，但是返回值永远只有一个，没有返回值可以成为 void 类型，所以返回值在 tpye 中占第一个位置）后续可以有参数一，参数二，直到参数n，后面这些就是这个函数每一个参数的参数类型，那么就有返回值类型以及函数每个参数类型所组成的字符串来表达一个函数它的返回值是什么类型的，它的参数有几个，以及每一个参数的类型是什么\n\n举一个例子：比如在 OC 中的一个方法 -（void）aMethod；这个函数它的返回值是 void 类型，没有参数，它对应的 type 值是 v@：，v@：就是 method_t 当中 types 所储存的内容，v 对应的是返回值 @，对应的是参数1，：对应的是参数2 ，它具体代表的含义是 v 对应的是函数的返回值是 void 类型的，@ 对应的是 OC 当中的 id 类型，它表示的是一个对象，在后续的学习当中我们可以知道，我们所调用的一个方法或者说消息传递，到达 Runtime 层面的时候都是转化成 objc_messSend 函数调用，这个函数调用的第一个和第二个参数是固定的并且是不可变的，第一个参数必须是 id 类型的，也就是消息的接收者或者称之为 self ，第二个参数是一个：，：所表达的含义是 SEL，表示这个参数是一个选择器。所以说一个 method_t 当中的 types 成员变量所表达的实际上是函数的返回值类型，以及参数个数，包括每个参数的类型。\n\n## Runtime 的基础数据结构总结图\n\n![](/img/Runtime的基础数据结构总结图.png)\n","source":"_posts/Runtime--Runtime的数据结构.md","raw":"---\ntitle: Runtime--Runtime的数据结构(一)\ndate: 2018-05-03 11:01:18\n\ndescription: Runtime 的基础数据结构：objc_object、objc_class、isa 指针、method_t\n\ncategories: Runtime\ntags: [Objective-C]\n---\n\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n**目录**\n\n* objc_object\n* objc_class\n* isa 指针\n* objc_class 中的成员结构\n* Runtime 的基础数据结构总结图\n\n## objc_object\n\n![](/imag/objc_object.png)\n\n我们平时使用的所有的对象都是 id 类型，对应到 Runtime 中就是 objc_object 的结构体，这个结构体中主要包含以下几个成员部分：\n\n1. isa_t：  isa_t 是一个共用体\n2. 关于 isa 操作的相关方法：提供了 isa 操作相关的一些方法，比如通过 objc_object 这个结构体来获取它的 isa 所指向的类对象，包括通过类对象的 isa 指针获取它的元类对象一些遍历的方法\n3. 弱引用相关方法：比如说，标记一个对象，它是否曾经有过弱指针\n4. 关联对象相关方法：比说，这个对象，为它设置了一些关联属性，关联属性的一些方法也体现在 objc_object 结构体当中\n5. 内存管理相关：比如， 在 MRC 下面经常使用到的 retain，relese，包括 ARC，MRC 下面都可以用到的 艾特aotorelesepool \n\n\n## objc_class\n\n\n![](/img/objc_class.png)\n\n在 OC 当中使用的类对应的是 Runtime 中就是 objc_class 的结构体，objc_class 继承自 objc_object （class 也是一个对象，称类对象）\n\nobjc_class包含：\n\n1. 拥有一个 superClass 指针，对指向的类型也是 class ，如果说是一个类对象的话，那么它的 superClass 指针指向的就是他的父类对象，也就是平时说的类与父类的关系，实际上就是通过 objc_class 中 superClass 这么一个成员变量来定义的\n2. 包含一个cache_t 成员变量，cache_t表达了方法缓存的一个结构，在消息传递的过程中，或使用方法缓存的数据结构\n3. 关于 class_data_bits_t 数据结构：实际上我们关于一个类所定义的一些变量、属性、包括他的一些方法都在 bits 成员结构当中\n\n## isa 指针\n\n### isa指针相关说明\n\n![](/img/isa指针.png)\n\nisa指针是 C++ 当中的一个共用体，在 OC 中是定义成了 isa_t 的名称\n\n对于一个共用体来说，无论是在64位架构上面还是在32位架构上面，实际上都是32个0或者1的数字，或者64个0或者1的数字，大多数及其都是64位的\n\nisa指针分两种类型，一种是指针型的 isa ，一种是非指针型的 isa\n\n1. 指针型的 isa 64位的0或者说1它的整体内容代表的是 Class 的地址（比如对于使用一个 objc_object 这么一个对象的时候，可以通过 isa 的内容来获取到它的类对象的地址）\n2. 非指针型的 isa 的值的部分代表 Class 的地址（比如针对64位架构上面的am（没听清）架构，可能是对应的其中某一部分的33位或者44位所代表的值，意味着是 Class 的地址，不是说整个64位都代表 Class 的地址）这样做的目的是因为在寻址过程当中，实际上只有三四十位的位数就可以保证我们寻找到所有的 Class 的地址，多出的这些位可以用来存储其他的相关内容，来达到节省内存的目的\n\n### isa 指向\n\n![](/img/isa指向.png)\n\n关于对象，它指向的是类对象\n\n* 比如拥有一个实例，实例就是 OC 中对应的 id 类型，表述在 Runtime 中就是 objc_object ，objc_object 当中有一个 isa 指针，对于实例来说它的 isa 指针就指向他对应的 class ，或者说称之为**类对象**\n\n关于类对象，isa 的指向是其元类对象\n\n* class 代表的是 objc_class ,而 objc_class 又继承自 objc_object，所以 class 实际上也是一种对象，称之为类对象，那么class当中由于继承自 objc_object ，所以也有一个 isa 指针，这个 isa 指针指向的是其元类对象，那么在进行方法调用的时候，调用一个实例的实例方法实际上是通过 isa 指针到它的类对象当中去进行方法查找，如果调用的是一个类方法，那么是通过类对象的 isa 指向他的元类对象当中去查找\n\n## objc_class 中的成员结构\n\n### cache_t\n\n* 用于**快速**查找方法执行函数\n\n* 是可**增量扩展**的**嘻哈表**结构\n\n* 是**局部性原理**的最佳应用\n\n1. 实际上是用于快速查找方法执行函数的机构，比如说在调用一个方法的时候，如果有一个缓存，就不用到它对应的方法列表当中去逐一遍历去查找这个方法的具体实现，可以提高方法调用的速度，或者说消息传递的速度\n\n2. 是可增量扩展的哈希表结构。增量扩展体现在，当这个结构存储的量在增大的过程中，他也会逐渐去增量的扩大它的内存空间来支持更多的缓存，用哈希表来实现数据结构主要是为了提高查找效率\n\n3. cache_t 这个数据结构实际上是计算机局部性原理的最佳应用，局部性原理指的是，一般在调用放大的时候，可能往往调用的就那么几个方法，也就是这几个方法是调用频次最高的，这个时候把调用频次最高的方法放到缓存当中，下次的命中率就会更高一些，这个就是局部性原理的一个简单说明\n\n***cache_t 具体的数据结构说明***\n\n![](/img/cache_t具体的数据结构说明.png)\n\n可以理解是由一个数组来实现的，数组中每一个对象都是 bucke_t 这么一个结构体来封装的，对于bucke_t 它有两个主要的成员变量，第一个是 key 第二个是 IMP ，key 对应 OC 当中的 selecter，在调用一个方法的时候，他实际上是一个选择器 SEL ，可以通过方法选择器的名称来寻找一个方法的具体实现，IMP 可以理解为是一个无类型的函数指针\n那么比如说给你一个 key，可以通过哈希查找算法来定位当前这个key所对应的 bucket_t 的数据结构位于数组当中的哪个位置，然后当定位到这个位置之后，就可以提取 bucket_t 里面的具体函数的实现（IMP）来调用函数\n\n\n### class-data-bits-t\n\n* **class-data-bits-t** 主要是对 **class-rw-t** 的封装\n\n* **class-rw-t** 代表了类相关的**读写**信息、对 class_ro_t 的封装\n\n* **class-ro-t** 代表了类相关的**只读**信息\n\nclass-rw-t 代表了类相关的读写信息，比如说给类添加的一些分类当中的一些方法或者说属性，以及协议都在 class-rw-t 当中（rw 是 read write 的简写）\n\n### class-rw-t\n\n![](/img/class_rw_t.png)\n\nclass_rw_t 主要包含第一部分 class_ro_t，第二部分 protocols（协议），第三部分 properties（属性），第四部分methods（方法），在给分类创建的协议属性方法都是在这三个数据结构当中，这三个数据结构是一个二维数组，都继承自 list_array_tt 这么样一个结构，对于二位数组解释：以 methods 为例，数组（一维）当中每一个元素又是一个数组（二维），二维数组当中所装载的内容是 method_t 数据结构 \n\n比说添加了一个分类 A ，那么分类 A 当中的所有的方法以一个列表的形势作为二维数组的其中一个元素，第二个分类当中的方法列表就作为二维数组的第二个元素，以此类推\n\n### class_ro_t\n\n![](/img/class_ro_t.png)\n\nclass_ro_t 主要由以下几个部分组成\n\n1. 第一个是关于这个类的类名\n2. ivars，就是我们声明或者定义的一些类的成员变量\n3. 第三个是类的属性\n4. 第四个是类遵从的一些协议\n5. 最后一个是这个类添加的一些方法列表\n\n关于 ivars ，properties，protocols，methodList 实际上都是一维数组，这里的方法列表等内容和 class_rw_t 中的方法列表等内容是有区别的，前者是一维数组，后者是二维数组，同样的在 class_rw_t 当中，方法列表当中存储的内容一般情况下都是分类当中添加的一些方法内容，关于 class_ro_t 当中这样的一维数组的方法列表当中存储的就是我们原始定义的或者说添加的一些类的方法列表内容\n\n那么 methodList 当中所对应的每一个数组原元素实际上也是 method_t 数据结构 ，method_t 实际上是对一个方法的抽象说明\n\n### method_t\n\n![](/img/method_t.png)\n\n### type Encodings \n\n![](/img/typeEncodings.png)\n\nconst char*类型的 types 成员属性，实际上它的表达结构大致是这样的\n\n首先它是不可变的字符指针，它所指向的字符组成结构大致是这样的，首先第一个位置永远都是函数的返回值（为什么是在第一个位置：在定义一个函数的时候函数的参数可以有多个，但是返回值永远只有一个，没有返回值可以成为 void 类型，所以返回值在 tpye 中占第一个位置）后续可以有参数一，参数二，直到参数n，后面这些就是这个函数每一个参数的参数类型，那么就有返回值类型以及函数每个参数类型所组成的字符串来表达一个函数它的返回值是什么类型的，它的参数有几个，以及每一个参数的类型是什么\n\n举一个例子：比如在 OC 中的一个方法 -（void）aMethod；这个函数它的返回值是 void 类型，没有参数，它对应的 type 值是 v@：，v@：就是 method_t 当中 types 所储存的内容，v 对应的是返回值 @，对应的是参数1，：对应的是参数2 ，它具体代表的含义是 v 对应的是函数的返回值是 void 类型的，@ 对应的是 OC 当中的 id 类型，它表示的是一个对象，在后续的学习当中我们可以知道，我们所调用的一个方法或者说消息传递，到达 Runtime 层面的时候都是转化成 objc_messSend 函数调用，这个函数调用的第一个和第二个参数是固定的并且是不可变的，第一个参数必须是 id 类型的，也就是消息的接收者或者称之为 self ，第二个参数是一个：，：所表达的含义是 SEL，表示这个参数是一个选择器。所以说一个 method_t 当中的 types 成员变量所表达的实际上是函数的返回值类型，以及参数个数，包括每个参数的类型。\n\n## Runtime 的基础数据结构总结图\n\n![](/img/Runtime的基础数据结构总结图.png)\n","slug":"Runtime--Runtime的数据结构","published":1,"updated":"2018-09-11T08:39:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnk000t66r2zqm53fxg","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<p><strong>目录</strong></p>\n<ul>\n<li>objc_object</li>\n<li>objc_class</li>\n<li>isa 指针</li>\n<li>objc_class 中的成员结构</li>\n<li>Runtime 的基础数据结构总结图</li>\n</ul>\n<h2 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h2><p><img src=\"/imag/objc_object.png\" alt=\"\"></p>\n<p>我们平时使用的所有的对象都是 id 类型，对应到 Runtime 中就是 objc_object 的结构体，这个结构体中主要包含以下几个成员部分：</p>\n<ol>\n<li>isa_t：  isa_t 是一个共用体</li>\n<li>关于 isa 操作的相关方法：提供了 isa 操作相关的一些方法，比如通过 objc_object 这个结构体来获取它的 isa 所指向的类对象，包括通过类对象的 isa 指针获取它的元类对象一些遍历的方法</li>\n<li>弱引用相关方法：比如说，标记一个对象，它是否曾经有过弱指针</li>\n<li>关联对象相关方法：比说，这个对象，为它设置了一些关联属性，关联属性的一些方法也体现在 objc_object 结构体当中</li>\n<li>内存管理相关：比如， 在 MRC 下面经常使用到的 retain，relese，包括 ARC，MRC 下面都可以用到的 艾特aotorelesepool </li>\n</ol>\n<h2 id=\"objc-class\"><a href=\"#objc-class\" class=\"headerlink\" title=\"objc_class\"></a>objc_class</h2><p><img src=\"/img/objc_class.png\" alt=\"\"></p>\n<p>在 OC 当中使用的类对应的是 Runtime 中就是 objc_class 的结构体，objc_class 继承自 objc_object （class 也是一个对象，称类对象）</p>\n<p>objc_class包含：</p>\n<ol>\n<li>拥有一个 superClass 指针，对指向的类型也是 class ，如果说是一个类对象的话，那么它的 superClass 指针指向的就是他的父类对象，也就是平时说的类与父类的关系，实际上就是通过 objc_class 中 superClass 这么一个成员变量来定义的</li>\n<li>包含一个cache_t 成员变量，cache_t表达了方法缓存的一个结构，在消息传递的过程中，或使用方法缓存的数据结构</li>\n<li>关于 class_data_bits_t 数据结构：实际上我们关于一个类所定义的一些变量、属性、包括他的一些方法都在 bits 成员结构当中</li>\n</ol>\n<h2 id=\"isa-指针\"><a href=\"#isa-指针\" class=\"headerlink\" title=\"isa 指针\"></a>isa 指针</h2><h3 id=\"isa指针相关说明\"><a href=\"#isa指针相关说明\" class=\"headerlink\" title=\"isa指针相关说明\"></a>isa指针相关说明</h3><p><img src=\"/img/isa指针.png\" alt=\"\"></p>\n<p>isa指针是 C++ 当中的一个共用体，在 OC 中是定义成了 isa_t 的名称</p>\n<p>对于一个共用体来说，无论是在64位架构上面还是在32位架构上面，实际上都是32个0或者1的数字，或者64个0或者1的数字，大多数及其都是64位的</p>\n<p>isa指针分两种类型，一种是指针型的 isa ，一种是非指针型的 isa</p>\n<ol>\n<li>指针型的 isa 64位的0或者说1它的整体内容代表的是 Class 的地址（比如对于使用一个 objc_object 这么一个对象的时候，可以通过 isa 的内容来获取到它的类对象的地址）</li>\n<li>非指针型的 isa 的值的部分代表 Class 的地址（比如针对64位架构上面的am（没听清）架构，可能是对应的其中某一部分的33位或者44位所代表的值，意味着是 Class 的地址，不是说整个64位都代表 Class 的地址）这样做的目的是因为在寻址过程当中，实际上只有三四十位的位数就可以保证我们寻找到所有的 Class 的地址，多出的这些位可以用来存储其他的相关内容，来达到节省内存的目的</li>\n</ol>\n<h3 id=\"isa-指向\"><a href=\"#isa-指向\" class=\"headerlink\" title=\"isa 指向\"></a>isa 指向</h3><p><img src=\"/img/isa指向.png\" alt=\"\"></p>\n<p>关于对象，它指向的是类对象</p>\n<ul>\n<li>比如拥有一个实例，实例就是 OC 中对应的 id 类型，表述在 Runtime 中就是 objc_object ，objc_object 当中有一个 isa 指针，对于实例来说它的 isa 指针就指向他对应的 class ，或者说称之为<strong>类对象</strong></li>\n</ul>\n<p>关于类对象，isa 的指向是其元类对象</p>\n<ul>\n<li>class 代表的是 objc_class ,而 objc_class 又继承自 objc_object，所以 class 实际上也是一种对象，称之为类对象，那么class当中由于继承自 objc_object ，所以也有一个 isa 指针，这个 isa 指针指向的是其元类对象，那么在进行方法调用的时候，调用一个实例的实例方法实际上是通过 isa 指针到它的类对象当中去进行方法查找，如果调用的是一个类方法，那么是通过类对象的 isa 指向他的元类对象当中去查找</li>\n</ul>\n<h2 id=\"objc-class-中的成员结构\"><a href=\"#objc-class-中的成员结构\" class=\"headerlink\" title=\"objc_class 中的成员结构\"></a>objc_class 中的成员结构</h2><h3 id=\"cache-t\"><a href=\"#cache-t\" class=\"headerlink\" title=\"cache_t\"></a>cache_t</h3><ul>\n<li><p>用于<strong>快速</strong>查找方法执行函数</p>\n</li>\n<li><p>是可<strong>增量扩展</strong>的<strong>嘻哈表</strong>结构</p>\n</li>\n<li><p>是<strong>局部性原理</strong>的最佳应用</p>\n</li>\n</ul>\n<ol>\n<li><p>实际上是用于快速查找方法执行函数的机构，比如说在调用一个方法的时候，如果有一个缓存，就不用到它对应的方法列表当中去逐一遍历去查找这个方法的具体实现，可以提高方法调用的速度，或者说消息传递的速度</p>\n</li>\n<li><p>是可增量扩展的哈希表结构。增量扩展体现在，当这个结构存储的量在增大的过程中，他也会逐渐去增量的扩大它的内存空间来支持更多的缓存，用哈希表来实现数据结构主要是为了提高查找效率</p>\n</li>\n<li><p>cache_t 这个数据结构实际上是计算机局部性原理的最佳应用，局部性原理指的是，一般在调用放大的时候，可能往往调用的就那么几个方法，也就是这几个方法是调用频次最高的，这个时候把调用频次最高的方法放到缓存当中，下次的命中率就会更高一些，这个就是局部性原理的一个简单说明</p>\n</li>\n</ol>\n<p><strong><em>cache_t 具体的数据结构说明</em></strong></p>\n<p><img src=\"/img/cache_t具体的数据结构说明.png\" alt=\"\"></p>\n<p>可以理解是由一个数组来实现的，数组中每一个对象都是 bucke_t 这么一个结构体来封装的，对于bucke_t 它有两个主要的成员变量，第一个是 key 第二个是 IMP ，key 对应 OC 当中的 selecter，在调用一个方法的时候，他实际上是一个选择器 SEL ，可以通过方法选择器的名称来寻找一个方法的具体实现，IMP 可以理解为是一个无类型的函数指针<br>那么比如说给你一个 key，可以通过哈希查找算法来定位当前这个key所对应的 bucket_t 的数据结构位于数组当中的哪个位置，然后当定位到这个位置之后，就可以提取 bucket_t 里面的具体函数的实现（IMP）来调用函数</p>\n<h3 id=\"class-data-bits-t\"><a href=\"#class-data-bits-t\" class=\"headerlink\" title=\"class-data-bits-t\"></a>class-data-bits-t</h3><ul>\n<li><p><strong>class-data-bits-t</strong> 主要是对 <strong>class-rw-t</strong> 的封装</p>\n</li>\n<li><p><strong>class-rw-t</strong> 代表了类相关的<strong>读写</strong>信息、对 class_ro_t 的封装</p>\n</li>\n<li><p><strong>class-ro-t</strong> 代表了类相关的<strong>只读</strong>信息</p>\n</li>\n</ul>\n<p>class-rw-t 代表了类相关的读写信息，比如说给类添加的一些分类当中的一些方法或者说属性，以及协议都在 class-rw-t 当中（rw 是 read write 的简写）</p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class-rw-t\"></a>class-rw-t</h3><p><img src=\"/img/class_rw_t.png\" alt=\"\"></p>\n<p>class_rw_t 主要包含第一部分 class_ro_t，第二部分 protocols（协议），第三部分 properties（属性），第四部分methods（方法），在给分类创建的协议属性方法都是在这三个数据结构当中，这三个数据结构是一个二维数组，都继承自 list_array_tt 这么样一个结构，对于二位数组解释：以 methods 为例，数组（一维）当中每一个元素又是一个数组（二维），二维数组当中所装载的内容是 method_t 数据结构 </p>\n<p>比说添加了一个分类 A ，那么分类 A 当中的所有的方法以一个列表的形势作为二维数组的其中一个元素，第二个分类当中的方法列表就作为二维数组的第二个元素，以此类推</p>\n<h3 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t\"></a>class_ro_t</h3><p><img src=\"/img/class_ro_t.png\" alt=\"\"></p>\n<p>class_ro_t 主要由以下几个部分组成</p>\n<ol>\n<li>第一个是关于这个类的类名</li>\n<li>ivars，就是我们声明或者定义的一些类的成员变量</li>\n<li>第三个是类的属性</li>\n<li>第四个是类遵从的一些协议</li>\n<li>最后一个是这个类添加的一些方法列表</li>\n</ol>\n<p>关于 ivars ，properties，protocols，methodList 实际上都是一维数组，这里的方法列表等内容和 class_rw_t 中的方法列表等内容是有区别的，前者是一维数组，后者是二维数组，同样的在 class_rw_t 当中，方法列表当中存储的内容一般情况下都是分类当中添加的一些方法内容，关于 class_ro_t 当中这样的一维数组的方法列表当中存储的就是我们原始定义的或者说添加的一些类的方法列表内容</p>\n<p>那么 methodList 当中所对应的每一个数组原元素实际上也是 method_t 数据结构 ，method_t 实际上是对一个方法的抽象说明</p>\n<h3 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h3><p><img src=\"/img/method_t.png\" alt=\"\"></p>\n<h3 id=\"type-Encodings\"><a href=\"#type-Encodings\" class=\"headerlink\" title=\"type Encodings\"></a>type Encodings</h3><p><img src=\"/img/typeEncodings.png\" alt=\"\"></p>\n<p>const char*类型的 types 成员属性，实际上它的表达结构大致是这样的</p>\n<p>首先它是不可变的字符指针，它所指向的字符组成结构大致是这样的，首先第一个位置永远都是函数的返回值（为什么是在第一个位置：在定义一个函数的时候函数的参数可以有多个，但是返回值永远只有一个，没有返回值可以成为 void 类型，所以返回值在 tpye 中占第一个位置）后续可以有参数一，参数二，直到参数n，后面这些就是这个函数每一个参数的参数类型，那么就有返回值类型以及函数每个参数类型所组成的字符串来表达一个函数它的返回值是什么类型的，它的参数有几个，以及每一个参数的类型是什么</p>\n<p>举一个例子：比如在 OC 中的一个方法 -（void）aMethod；这个函数它的返回值是 void 类型，没有参数，它对应的 type 值是 v@：，v@：就是 method_t 当中 types 所储存的内容，v 对应的是返回值 @，对应的是参数1，：对应的是参数2 ，它具体代表的含义是 v 对应的是函数的返回值是 void 类型的，@ 对应的是 OC 当中的 id 类型，它表示的是一个对象，在后续的学习当中我们可以知道，我们所调用的一个方法或者说消息传递，到达 Runtime 层面的时候都是转化成 objc_messSend 函数调用，这个函数调用的第一个和第二个参数是固定的并且是不可变的，第一个参数必须是 id 类型的，也就是消息的接收者或者称之为 self ，第二个参数是一个：，：所表达的含义是 SEL，表示这个参数是一个选择器。所以说一个 method_t 当中的 types 成员变量所表达的实际上是函数的返回值类型，以及参数个数，包括每个参数的类型。</p>\n<h2 id=\"Runtime-的基础数据结构总结图\"><a href=\"#Runtime-的基础数据结构总结图\" class=\"headerlink\" title=\"Runtime 的基础数据结构总结图\"></a>Runtime 的基础数据结构总结图</h2><p><img src=\"/img/Runtime的基础数据结构总结图.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<p><strong>目录</strong></p>\n<ul>\n<li>objc_object</li>\n<li>objc_class</li>\n<li>isa 指针</li>\n<li>objc_class 中的成员结构</li>\n<li>Runtime 的基础数据结构总结图</li>\n</ul>\n<h2 id=\"objc-object\"><a href=\"#objc-object\" class=\"headerlink\" title=\"objc_object\"></a>objc_object</h2><p><img src=\"/imag/objc_object.png\" alt=\"\"></p>\n<p>我们平时使用的所有的对象都是 id 类型，对应到 Runtime 中就是 objc_object 的结构体，这个结构体中主要包含以下几个成员部分：</p>\n<ol>\n<li>isa_t：  isa_t 是一个共用体</li>\n<li>关于 isa 操作的相关方法：提供了 isa 操作相关的一些方法，比如通过 objc_object 这个结构体来获取它的 isa 所指向的类对象，包括通过类对象的 isa 指针获取它的元类对象一些遍历的方法</li>\n<li>弱引用相关方法：比如说，标记一个对象，它是否曾经有过弱指针</li>\n<li>关联对象相关方法：比说，这个对象，为它设置了一些关联属性，关联属性的一些方法也体现在 objc_object 结构体当中</li>\n<li>内存管理相关：比如， 在 MRC 下面经常使用到的 retain，relese，包括 ARC，MRC 下面都可以用到的 艾特aotorelesepool </li>\n</ol>\n<h2 id=\"objc-class\"><a href=\"#objc-class\" class=\"headerlink\" title=\"objc_class\"></a>objc_class</h2><p><img src=\"/img/objc_class.png\" alt=\"\"></p>\n<p>在 OC 当中使用的类对应的是 Runtime 中就是 objc_class 的结构体，objc_class 继承自 objc_object （class 也是一个对象，称类对象）</p>\n<p>objc_class包含：</p>\n<ol>\n<li>拥有一个 superClass 指针，对指向的类型也是 class ，如果说是一个类对象的话，那么它的 superClass 指针指向的就是他的父类对象，也就是平时说的类与父类的关系，实际上就是通过 objc_class 中 superClass 这么一个成员变量来定义的</li>\n<li>包含一个cache_t 成员变量，cache_t表达了方法缓存的一个结构，在消息传递的过程中，或使用方法缓存的数据结构</li>\n<li>关于 class_data_bits_t 数据结构：实际上我们关于一个类所定义的一些变量、属性、包括他的一些方法都在 bits 成员结构当中</li>\n</ol>\n<h2 id=\"isa-指针\"><a href=\"#isa-指针\" class=\"headerlink\" title=\"isa 指针\"></a>isa 指针</h2><h3 id=\"isa指针相关说明\"><a href=\"#isa指针相关说明\" class=\"headerlink\" title=\"isa指针相关说明\"></a>isa指针相关说明</h3><p><img src=\"/img/isa指针.png\" alt=\"\"></p>\n<p>isa指针是 C++ 当中的一个共用体，在 OC 中是定义成了 isa_t 的名称</p>\n<p>对于一个共用体来说，无论是在64位架构上面还是在32位架构上面，实际上都是32个0或者1的数字，或者64个0或者1的数字，大多数及其都是64位的</p>\n<p>isa指针分两种类型，一种是指针型的 isa ，一种是非指针型的 isa</p>\n<ol>\n<li>指针型的 isa 64位的0或者说1它的整体内容代表的是 Class 的地址（比如对于使用一个 objc_object 这么一个对象的时候，可以通过 isa 的内容来获取到它的类对象的地址）</li>\n<li>非指针型的 isa 的值的部分代表 Class 的地址（比如针对64位架构上面的am（没听清）架构，可能是对应的其中某一部分的33位或者44位所代表的值，意味着是 Class 的地址，不是说整个64位都代表 Class 的地址）这样做的目的是因为在寻址过程当中，实际上只有三四十位的位数就可以保证我们寻找到所有的 Class 的地址，多出的这些位可以用来存储其他的相关内容，来达到节省内存的目的</li>\n</ol>\n<h3 id=\"isa-指向\"><a href=\"#isa-指向\" class=\"headerlink\" title=\"isa 指向\"></a>isa 指向</h3><p><img src=\"/img/isa指向.png\" alt=\"\"></p>\n<p>关于对象，它指向的是类对象</p>\n<ul>\n<li>比如拥有一个实例，实例就是 OC 中对应的 id 类型，表述在 Runtime 中就是 objc_object ，objc_object 当中有一个 isa 指针，对于实例来说它的 isa 指针就指向他对应的 class ，或者说称之为<strong>类对象</strong></li>\n</ul>\n<p>关于类对象，isa 的指向是其元类对象</p>\n<ul>\n<li>class 代表的是 objc_class ,而 objc_class 又继承自 objc_object，所以 class 实际上也是一种对象，称之为类对象，那么class当中由于继承自 objc_object ，所以也有一个 isa 指针，这个 isa 指针指向的是其元类对象，那么在进行方法调用的时候，调用一个实例的实例方法实际上是通过 isa 指针到它的类对象当中去进行方法查找，如果调用的是一个类方法，那么是通过类对象的 isa 指向他的元类对象当中去查找</li>\n</ul>\n<h2 id=\"objc-class-中的成员结构\"><a href=\"#objc-class-中的成员结构\" class=\"headerlink\" title=\"objc_class 中的成员结构\"></a>objc_class 中的成员结构</h2><h3 id=\"cache-t\"><a href=\"#cache-t\" class=\"headerlink\" title=\"cache_t\"></a>cache_t</h3><ul>\n<li><p>用于<strong>快速</strong>查找方法执行函数</p>\n</li>\n<li><p>是可<strong>增量扩展</strong>的<strong>嘻哈表</strong>结构</p>\n</li>\n<li><p>是<strong>局部性原理</strong>的最佳应用</p>\n</li>\n</ul>\n<ol>\n<li><p>实际上是用于快速查找方法执行函数的机构，比如说在调用一个方法的时候，如果有一个缓存，就不用到它对应的方法列表当中去逐一遍历去查找这个方法的具体实现，可以提高方法调用的速度，或者说消息传递的速度</p>\n</li>\n<li><p>是可增量扩展的哈希表结构。增量扩展体现在，当这个结构存储的量在增大的过程中，他也会逐渐去增量的扩大它的内存空间来支持更多的缓存，用哈希表来实现数据结构主要是为了提高查找效率</p>\n</li>\n<li><p>cache_t 这个数据结构实际上是计算机局部性原理的最佳应用，局部性原理指的是，一般在调用放大的时候，可能往往调用的就那么几个方法，也就是这几个方法是调用频次最高的，这个时候把调用频次最高的方法放到缓存当中，下次的命中率就会更高一些，这个就是局部性原理的一个简单说明</p>\n</li>\n</ol>\n<p><strong><em>cache_t 具体的数据结构说明</em></strong></p>\n<p><img src=\"/img/cache_t具体的数据结构说明.png\" alt=\"\"></p>\n<p>可以理解是由一个数组来实现的，数组中每一个对象都是 bucke_t 这么一个结构体来封装的，对于bucke_t 它有两个主要的成员变量，第一个是 key 第二个是 IMP ，key 对应 OC 当中的 selecter，在调用一个方法的时候，他实际上是一个选择器 SEL ，可以通过方法选择器的名称来寻找一个方法的具体实现，IMP 可以理解为是一个无类型的函数指针<br>那么比如说给你一个 key，可以通过哈希查找算法来定位当前这个key所对应的 bucket_t 的数据结构位于数组当中的哪个位置，然后当定位到这个位置之后，就可以提取 bucket_t 里面的具体函数的实现（IMP）来调用函数</p>\n<h3 id=\"class-data-bits-t\"><a href=\"#class-data-bits-t\" class=\"headerlink\" title=\"class-data-bits-t\"></a>class-data-bits-t</h3><ul>\n<li><p><strong>class-data-bits-t</strong> 主要是对 <strong>class-rw-t</strong> 的封装</p>\n</li>\n<li><p><strong>class-rw-t</strong> 代表了类相关的<strong>读写</strong>信息、对 class_ro_t 的封装</p>\n</li>\n<li><p><strong>class-ro-t</strong> 代表了类相关的<strong>只读</strong>信息</p>\n</li>\n</ul>\n<p>class-rw-t 代表了类相关的读写信息，比如说给类添加的一些分类当中的一些方法或者说属性，以及协议都在 class-rw-t 当中（rw 是 read write 的简写）</p>\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class-rw-t\"></a>class-rw-t</h3><p><img src=\"/img/class_rw_t.png\" alt=\"\"></p>\n<p>class_rw_t 主要包含第一部分 class_ro_t，第二部分 protocols（协议），第三部分 properties（属性），第四部分methods（方法），在给分类创建的协议属性方法都是在这三个数据结构当中，这三个数据结构是一个二维数组，都继承自 list_array_tt 这么样一个结构，对于二位数组解释：以 methods 为例，数组（一维）当中每一个元素又是一个数组（二维），二维数组当中所装载的内容是 method_t 数据结构 </p>\n<p>比说添加了一个分类 A ，那么分类 A 当中的所有的方法以一个列表的形势作为二维数组的其中一个元素，第二个分类当中的方法列表就作为二维数组的第二个元素，以此类推</p>\n<h3 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t\"></a>class_ro_t</h3><p><img src=\"/img/class_ro_t.png\" alt=\"\"></p>\n<p>class_ro_t 主要由以下几个部分组成</p>\n<ol>\n<li>第一个是关于这个类的类名</li>\n<li>ivars，就是我们声明或者定义的一些类的成员变量</li>\n<li>第三个是类的属性</li>\n<li>第四个是类遵从的一些协议</li>\n<li>最后一个是这个类添加的一些方法列表</li>\n</ol>\n<p>关于 ivars ，properties，protocols，methodList 实际上都是一维数组，这里的方法列表等内容和 class_rw_t 中的方法列表等内容是有区别的，前者是一维数组，后者是二维数组，同样的在 class_rw_t 当中，方法列表当中存储的内容一般情况下都是分类当中添加的一些方法内容，关于 class_ro_t 当中这样的一维数组的方法列表当中存储的就是我们原始定义的或者说添加的一些类的方法列表内容</p>\n<p>那么 methodList 当中所对应的每一个数组原元素实际上也是 method_t 数据结构 ，method_t 实际上是对一个方法的抽象说明</p>\n<h3 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h3><p><img src=\"/img/method_t.png\" alt=\"\"></p>\n<h3 id=\"type-Encodings\"><a href=\"#type-Encodings\" class=\"headerlink\" title=\"type Encodings\"></a>type Encodings</h3><p><img src=\"/img/typeEncodings.png\" alt=\"\"></p>\n<p>const char*类型的 types 成员属性，实际上它的表达结构大致是这样的</p>\n<p>首先它是不可变的字符指针，它所指向的字符组成结构大致是这样的，首先第一个位置永远都是函数的返回值（为什么是在第一个位置：在定义一个函数的时候函数的参数可以有多个，但是返回值永远只有一个，没有返回值可以成为 void 类型，所以返回值在 tpye 中占第一个位置）后续可以有参数一，参数二，直到参数n，后面这些就是这个函数每一个参数的参数类型，那么就有返回值类型以及函数每个参数类型所组成的字符串来表达一个函数它的返回值是什么类型的，它的参数有几个，以及每一个参数的类型是什么</p>\n<p>举一个例子：比如在 OC 中的一个方法 -（void）aMethod；这个函数它的返回值是 void 类型，没有参数，它对应的 type 值是 v@：，v@：就是 method_t 当中 types 所储存的内容，v 对应的是返回值 @，对应的是参数1，：对应的是参数2 ，它具体代表的含义是 v 对应的是函数的返回值是 void 类型的，@ 对应的是 OC 当中的 id 类型，它表示的是一个对象，在后续的学习当中我们可以知道，我们所调用的一个方法或者说消息传递，到达 Runtime 层面的时候都是转化成 objc_messSend 函数调用，这个函数调用的第一个和第二个参数是固定的并且是不可变的，第一个参数必须是 id 类型的，也就是消息的接收者或者称之为 self ，第二个参数是一个：，：所表达的含义是 SEL，表示这个参数是一个选择器。所以说一个 method_t 当中的 types 成员变量所表达的实际上是函数的返回值类型，以及参数个数，包括每个参数的类型。</p>\n<h2 id=\"Runtime-的基础数据结构总结图\"><a href=\"#Runtime-的基础数据结构总结图\" class=\"headerlink\" title=\"Runtime 的基础数据结构总结图\"></a>Runtime 的基础数据结构总结图</h2><p><img src=\"/img/Runtime的基础数据结构总结图.png\" alt=\"\"></p>\n"},{"title":"Runtime--类对象与元类对象(二)","date":"2018-05-12T17:01:18.000Z","description":"深入理解 对象、类对象、元类对象","_content":"\n\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n\n## 对象、类对象、元类对象\n\n* **类对象**存储实例方法列表等信息\n\n* **元类对象**存储类方法列表等信息\n\n#### 通过一副经典图来了解一下\n\n![](/img/类对象与元类对象.png)\n\n**实例和类对象之间的关系**\n\n* 首先看到的是一个根类（Root class）它的类对象，根类的父类指向的是 nil，对应的就是 OC 中 NSObject 这个类，它实际上是没有父类的，父类是nil\n\n* 对于这个类对象，他有子类（Superclass）以及子类的子类（Subclass），当给定一个实例（instance）的时候，由于这个实例是 id 类型的，也就是 objc_object 数据结构，它当中有一个 isa 成员变量，所指向的就是这个实例所对应的类对象，实例通过 isa 指针找到自己的类对象\n\n**类对象和元类对象之间有什么区别和联系**\n\n* 最右侧的这一部分分别为，根类的元类对象，父类的元类对象和子类的元类对象，他们三个之间同样也是父子关系或者说是继承关系，对于类对象由于它是 objc_class 数据结构，继承与 objc_object，所以他们也分别有 isa 指针，那么对应的根类的类对象它的 isa 指针就指向根元类对象，父类的类对象当中的 isa 指针指向父类的元类对象，子类的 isa 指针指向的是子类的元类对应\n\n阐述问题时不仅要说出，实例对象可以通过 isa 指针找到它的类对象，类对象当中存在方法列表，类对象通过 isa 找到它的元类对象，从而可以访问一些关于类方法列表等信息，还要说出类对象和元类对象都是 objc_class 数据结构的，这个数据结构由于继承了 objc_object，所以他们才有 isa 指针，进而才能实现刚才说描述的联系\n\n**元类对象的 isa 指针指向**\n\n* 类对象和元类对象都是 objc_class 数据结构，objc_class由于继承了 objc_object，所以元类对象也有 isa 指针\n\n* 对于任何一个元类对象，他的 isa 指针都指向根元类对象，包括根元类对象子身\n\n* 根元类对象 superclass 指针指向的是根类对象，这个指向就决定了重要的性质\n\n**如果调用的一个类方法没有实现，但是有同名的实例方法实现，这个时候会不会发生崩溃，会不会产生实际的调用（性质来了）**\n\n* 就是由于根元类对象 superclass 指针指向了根类对象，当在元类对象当中去找类方法列表没有查找到的情况下，就会顺着这个指针去实例方法列表当中查找，如果有同名方法就会执行同名方法的实例方法\n\n\n**消息传递的过程（现在理解是不是很清晰~~~）**\n\n比如说调用了一个实例方法 A\n\n* 首先系统会根据当前实例的 isa 指针找到它的类对象\n* 然后在类对象中遍历方法列表查找同名的方法实现\n* 如果没有查找到的话，就会顺次以 superclass 指针的指向去查找父类类对象的方法列表，然后再顺次查找根类对象的方法列表\n* 如果没有找到就会进入消息转发流程\n\n如果调用了一个类方法 A\n\n* 首先通过类对象的 isa 指针找到元类对象，然后顺次（从当前元类对象到根元类对象）遍历方法列表，然后再到根类对象，再到 nil\n* 所以在遍历类方法的过程当中和遍历实例方法的过程当中有一个区别，区别就在根元类对象 superclass 指针的指向\n\n\n## 思考\n\n\n```\n// .h\n\n#import \"Mobile.h\"\n\n@interface Phone : Mobile\n\n@end\n\n// .m\n\n@implementation Phone\n\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n\n```\n\n会输出什么？\n\n先思考一会儿。。。\n\n解析：\n\n[self class] 消息的接收者是当前对象，从当前类对象的方法列表开始查找，class 这个方法实际上是在 NSObject 当中才有实现的，super 调用它的 class ，实际的接收着仍然是当前对象，也就是仍然是 self，只不过调用 [super class] 的时候是从当前对象的父类对象（跨越了类对象）当中开始查找 class 的方法实现，不论从哪开始查找，最终都是找到 NSObject 当中\n\n代码角度：\n\n[super class]会被转换为下面代码\n\n```\nstruct objc_super objcSuper = {\n    self,\n    class_getSuperclass([self class]),\n};\nid (*sendSuper)(struct objc_super*, SEL) = (void)objc_msgSendSuper;\nsendSuper(&objcSuper, @selector(class));\n\n```\n\nsuper的调用会被转换为objc_msgSendSuper的调用，并传入一个objc_super类型的结构体。结构体有两个参数，第一个就是接受消息的对象，第二个是[super class]对应的父类。\n\n```\nstruct objc_super {\n    __unsafe_unretained _Nonnull id receiver;\n    __unsafe_unretained _Nonnull Class super_class;\n};\n\n```\n\n由此可知，虽然调用的是[super class]，但是接受消息的对象还是self。然后来到父类Father的class方法中，输出self对应的类 Phone。\n\n两个都是输出 Phone ","source":"_posts/Runtime--类对象与元类对象.md","raw":"---\ntitle: Runtime--类对象与元类对象(二)\ndate: 2018-05-13 01:01:18\n\ndescription: 深入理解 对象、类对象、元类对象\n\ncategories: Runtime\ntags: [Objective-C]\n---\n\n\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n\n## 对象、类对象、元类对象\n\n* **类对象**存储实例方法列表等信息\n\n* **元类对象**存储类方法列表等信息\n\n#### 通过一副经典图来了解一下\n\n![](/img/类对象与元类对象.png)\n\n**实例和类对象之间的关系**\n\n* 首先看到的是一个根类（Root class）它的类对象，根类的父类指向的是 nil，对应的就是 OC 中 NSObject 这个类，它实际上是没有父类的，父类是nil\n\n* 对于这个类对象，他有子类（Superclass）以及子类的子类（Subclass），当给定一个实例（instance）的时候，由于这个实例是 id 类型的，也就是 objc_object 数据结构，它当中有一个 isa 成员变量，所指向的就是这个实例所对应的类对象，实例通过 isa 指针找到自己的类对象\n\n**类对象和元类对象之间有什么区别和联系**\n\n* 最右侧的这一部分分别为，根类的元类对象，父类的元类对象和子类的元类对象，他们三个之间同样也是父子关系或者说是继承关系，对于类对象由于它是 objc_class 数据结构，继承与 objc_object，所以他们也分别有 isa 指针，那么对应的根类的类对象它的 isa 指针就指向根元类对象，父类的类对象当中的 isa 指针指向父类的元类对象，子类的 isa 指针指向的是子类的元类对应\n\n阐述问题时不仅要说出，实例对象可以通过 isa 指针找到它的类对象，类对象当中存在方法列表，类对象通过 isa 找到它的元类对象，从而可以访问一些关于类方法列表等信息，还要说出类对象和元类对象都是 objc_class 数据结构的，这个数据结构由于继承了 objc_object，所以他们才有 isa 指针，进而才能实现刚才说描述的联系\n\n**元类对象的 isa 指针指向**\n\n* 类对象和元类对象都是 objc_class 数据结构，objc_class由于继承了 objc_object，所以元类对象也有 isa 指针\n\n* 对于任何一个元类对象，他的 isa 指针都指向根元类对象，包括根元类对象子身\n\n* 根元类对象 superclass 指针指向的是根类对象，这个指向就决定了重要的性质\n\n**如果调用的一个类方法没有实现，但是有同名的实例方法实现，这个时候会不会发生崩溃，会不会产生实际的调用（性质来了）**\n\n* 就是由于根元类对象 superclass 指针指向了根类对象，当在元类对象当中去找类方法列表没有查找到的情况下，就会顺着这个指针去实例方法列表当中查找，如果有同名方法就会执行同名方法的实例方法\n\n\n**消息传递的过程（现在理解是不是很清晰~~~）**\n\n比如说调用了一个实例方法 A\n\n* 首先系统会根据当前实例的 isa 指针找到它的类对象\n* 然后在类对象中遍历方法列表查找同名的方法实现\n* 如果没有查找到的话，就会顺次以 superclass 指针的指向去查找父类类对象的方法列表，然后再顺次查找根类对象的方法列表\n* 如果没有找到就会进入消息转发流程\n\n如果调用了一个类方法 A\n\n* 首先通过类对象的 isa 指针找到元类对象，然后顺次（从当前元类对象到根元类对象）遍历方法列表，然后再到根类对象，再到 nil\n* 所以在遍历类方法的过程当中和遍历实例方法的过程当中有一个区别，区别就在根元类对象 superclass 指针的指向\n\n\n## 思考\n\n\n```\n// .h\n\n#import \"Mobile.h\"\n\n@interface Phone : Mobile\n\n@end\n\n// .m\n\n@implementation Phone\n\n- (id)init\n{\n    self = [super init];\n    if (self) {\n        NSLog(@\"%@\", NSStringFromClass([self class]));\n        NSLog(@\"%@\", NSStringFromClass([super class]));\n    }\n    return self;\n}\n\n```\n\n会输出什么？\n\n先思考一会儿。。。\n\n解析：\n\n[self class] 消息的接收者是当前对象，从当前类对象的方法列表开始查找，class 这个方法实际上是在 NSObject 当中才有实现的，super 调用它的 class ，实际的接收着仍然是当前对象，也就是仍然是 self，只不过调用 [super class] 的时候是从当前对象的父类对象（跨越了类对象）当中开始查找 class 的方法实现，不论从哪开始查找，最终都是找到 NSObject 当中\n\n代码角度：\n\n[super class]会被转换为下面代码\n\n```\nstruct objc_super objcSuper = {\n    self,\n    class_getSuperclass([self class]),\n};\nid (*sendSuper)(struct objc_super*, SEL) = (void)objc_msgSendSuper;\nsendSuper(&objcSuper, @selector(class));\n\n```\n\nsuper的调用会被转换为objc_msgSendSuper的调用，并传入一个objc_super类型的结构体。结构体有两个参数，第一个就是接受消息的对象，第二个是[super class]对应的父类。\n\n```\nstruct objc_super {\n    __unsafe_unretained _Nonnull id receiver;\n    __unsafe_unretained _Nonnull Class super_class;\n};\n\n```\n\n由此可知，虽然调用的是[super class]，但是接受消息的对象还是self。然后来到父类Father的class方法中，输出self对应的类 Phone。\n\n两个都是输出 Phone ","slug":"Runtime--类对象与元类对象","published":1,"updated":"2018-09-11T08:39:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnl000x66r2ubmetk61","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<h2 id=\"对象、类对象、元类对象\"><a href=\"#对象、类对象、元类对象\" class=\"headerlink\" title=\"对象、类对象、元类对象\"></a>对象、类对象、元类对象</h2><ul>\n<li><p><strong>类对象</strong>存储实例方法列表等信息</p>\n</li>\n<li><p><strong>元类对象</strong>存储类方法列表等信息</p>\n</li>\n</ul>\n<h4 id=\"通过一副经典图来了解一下\"><a href=\"#通过一副经典图来了解一下\" class=\"headerlink\" title=\"通过一副经典图来了解一下\"></a>通过一副经典图来了解一下</h4><p><img src=\"/img/类对象与元类对象.png\" alt=\"\"></p>\n<p><strong>实例和类对象之间的关系</strong></p>\n<ul>\n<li><p>首先看到的是一个根类（Root class）它的类对象，根类的父类指向的是 nil，对应的就是 OC 中 NSObject 这个类，它实际上是没有父类的，父类是nil</p>\n</li>\n<li><p>对于这个类对象，他有子类（Superclass）以及子类的子类（Subclass），当给定一个实例（instance）的时候，由于这个实例是 id 类型的，也就是 objc_object 数据结构，它当中有一个 isa 成员变量，所指向的就是这个实例所对应的类对象，实例通过 isa 指针找到自己的类对象</p>\n</li>\n</ul>\n<p><strong>类对象和元类对象之间有什么区别和联系</strong></p>\n<ul>\n<li>最右侧的这一部分分别为，根类的元类对象，父类的元类对象和子类的元类对象，他们三个之间同样也是父子关系或者说是继承关系，对于类对象由于它是 objc_class 数据结构，继承与 objc_object，所以他们也分别有 isa 指针，那么对应的根类的类对象它的 isa 指针就指向根元类对象，父类的类对象当中的 isa 指针指向父类的元类对象，子类的 isa 指针指向的是子类的元类对应</li>\n</ul>\n<p>阐述问题时不仅要说出，实例对象可以通过 isa 指针找到它的类对象，类对象当中存在方法列表，类对象通过 isa 找到它的元类对象，从而可以访问一些关于类方法列表等信息，还要说出类对象和元类对象都是 objc_class 数据结构的，这个数据结构由于继承了 objc_object，所以他们才有 isa 指针，进而才能实现刚才说描述的联系</p>\n<p><strong>元类对象的 isa 指针指向</strong></p>\n<ul>\n<li><p>类对象和元类对象都是 objc_class 数据结构，objc_class由于继承了 objc_object，所以元类对象也有 isa 指针</p>\n</li>\n<li><p>对于任何一个元类对象，他的 isa 指针都指向根元类对象，包括根元类对象子身</p>\n</li>\n<li><p>根元类对象 superclass 指针指向的是根类对象，这个指向就决定了重要的性质</p>\n</li>\n</ul>\n<p><strong>如果调用的一个类方法没有实现，但是有同名的实例方法实现，这个时候会不会发生崩溃，会不会产生实际的调用（性质来了）</strong></p>\n<ul>\n<li>就是由于根元类对象 superclass 指针指向了根类对象，当在元类对象当中去找类方法列表没有查找到的情况下，就会顺着这个指针去实例方法列表当中查找，如果有同名方法就会执行同名方法的实例方法</li>\n</ul>\n<p><strong>消息传递的过程（现在理解是不是很清晰~~~）</strong></p>\n<p>比如说调用了一个实例方法 A</p>\n<ul>\n<li>首先系统会根据当前实例的 isa 指针找到它的类对象</li>\n<li>然后在类对象中遍历方法列表查找同名的方法实现</li>\n<li>如果没有查找到的话，就会顺次以 superclass 指针的指向去查找父类类对象的方法列表，然后再顺次查找根类对象的方法列表</li>\n<li>如果没有找到就会进入消息转发流程</li>\n</ul>\n<p>如果调用了一个类方法 A</p>\n<ul>\n<li>首先通过类对象的 isa 指针找到元类对象，然后顺次（从当前元类对象到根元类对象）遍历方法列表，然后再到根类对象，再到 nil</li>\n<li>所以在遍历类方法的过程当中和遍历实例方法的过程当中有一个区别，区别就在根元类对象 superclass 指针的指向</li>\n</ul>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Mobile.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Phone</span> : <span class=\"title\">Mobile</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .m</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Phone</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出什么？</p>\n<p>先思考一会儿。。。</p>\n<p>解析：</p>\n<p>[self class] 消息的接收者是当前对象，从当前类对象的方法列表开始查找，class 这个方法实际上是在 NSObject 当中才有实现的，super 调用它的 class ，实际的接收着仍然是当前对象，也就是仍然是 self，只不过调用 [super class] 的时候是从当前对象的父类对象（跨越了类对象）当中开始查找 class 的方法实现，不论从哪开始查找，最终都是找到 NSObject 当中</p>\n<p>代码角度：</p>\n<p>[super class]会被转换为下面代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_super objcSuper = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>,</span><br><span class=\"line\">    class_getSuperclass([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">id</span> (*sendSuper)(<span class=\"keyword\">struct</span> objc_super*, SEL) = (<span class=\"keyword\">void</span>)objc_msgSendSuper;</span><br><span class=\"line\">sendSuper(&amp;objcSuper, <span class=\"keyword\">@selector</span>(<span class=\"keyword\">class</span>));</span><br></pre></td></tr></table></figure>\n<p>super的调用会被转换为objc_msgSendSuper的调用，并传入一个objc_super类型的结构体。结构体有两个参数，第一个就是接受消息的对象，第二个是[super class]对应的父类。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_super &#123;</span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _Nonnull <span class=\"keyword\">id</span> receiver;</span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知，虽然调用的是[super class]，但是接受消息的对象还是self。然后来到父类Father的class方法中，输出self对应的类 Phone。</p>\n<p>两个都是输出 Phone </p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<h2 id=\"对象、类对象、元类对象\"><a href=\"#对象、类对象、元类对象\" class=\"headerlink\" title=\"对象、类对象、元类对象\"></a>对象、类对象、元类对象</h2><ul>\n<li><p><strong>类对象</strong>存储实例方法列表等信息</p>\n</li>\n<li><p><strong>元类对象</strong>存储类方法列表等信息</p>\n</li>\n</ul>\n<h4 id=\"通过一副经典图来了解一下\"><a href=\"#通过一副经典图来了解一下\" class=\"headerlink\" title=\"通过一副经典图来了解一下\"></a>通过一副经典图来了解一下</h4><p><img src=\"/img/类对象与元类对象.png\" alt=\"\"></p>\n<p><strong>实例和类对象之间的关系</strong></p>\n<ul>\n<li><p>首先看到的是一个根类（Root class）它的类对象，根类的父类指向的是 nil，对应的就是 OC 中 NSObject 这个类，它实际上是没有父类的，父类是nil</p>\n</li>\n<li><p>对于这个类对象，他有子类（Superclass）以及子类的子类（Subclass），当给定一个实例（instance）的时候，由于这个实例是 id 类型的，也就是 objc_object 数据结构，它当中有一个 isa 成员变量，所指向的就是这个实例所对应的类对象，实例通过 isa 指针找到自己的类对象</p>\n</li>\n</ul>\n<p><strong>类对象和元类对象之间有什么区别和联系</strong></p>\n<ul>\n<li>最右侧的这一部分分别为，根类的元类对象，父类的元类对象和子类的元类对象，他们三个之间同样也是父子关系或者说是继承关系，对于类对象由于它是 objc_class 数据结构，继承与 objc_object，所以他们也分别有 isa 指针，那么对应的根类的类对象它的 isa 指针就指向根元类对象，父类的类对象当中的 isa 指针指向父类的元类对象，子类的 isa 指针指向的是子类的元类对应</li>\n</ul>\n<p>阐述问题时不仅要说出，实例对象可以通过 isa 指针找到它的类对象，类对象当中存在方法列表，类对象通过 isa 找到它的元类对象，从而可以访问一些关于类方法列表等信息，还要说出类对象和元类对象都是 objc_class 数据结构的，这个数据结构由于继承了 objc_object，所以他们才有 isa 指针，进而才能实现刚才说描述的联系</p>\n<p><strong>元类对象的 isa 指针指向</strong></p>\n<ul>\n<li><p>类对象和元类对象都是 objc_class 数据结构，objc_class由于继承了 objc_object，所以元类对象也有 isa 指针</p>\n</li>\n<li><p>对于任何一个元类对象，他的 isa 指针都指向根元类对象，包括根元类对象子身</p>\n</li>\n<li><p>根元类对象 superclass 指针指向的是根类对象，这个指向就决定了重要的性质</p>\n</li>\n</ul>\n<p><strong>如果调用的一个类方法没有实现，但是有同名的实例方法实现，这个时候会不会发生崩溃，会不会产生实际的调用（性质来了）</strong></p>\n<ul>\n<li>就是由于根元类对象 superclass 指针指向了根类对象，当在元类对象当中去找类方法列表没有查找到的情况下，就会顺着这个指针去实例方法列表当中查找，如果有同名方法就会执行同名方法的实例方法</li>\n</ul>\n<p><strong>消息传递的过程（现在理解是不是很清晰~~~）</strong></p>\n<p>比如说调用了一个实例方法 A</p>\n<ul>\n<li>首先系统会根据当前实例的 isa 指针找到它的类对象</li>\n<li>然后在类对象中遍历方法列表查找同名的方法实现</li>\n<li>如果没有查找到的话，就会顺次以 superclass 指针的指向去查找父类类对象的方法列表，然后再顺次查找根类对象的方法列表</li>\n<li>如果没有找到就会进入消息转发流程</li>\n</ul>\n<p>如果调用了一个类方法 A</p>\n<ul>\n<li>首先通过类对象的 isa 指针找到元类对象，然后顺次（从当前元类对象到根元类对象）遍历方法列表，然后再到根类对象，再到 nil</li>\n<li>所以在遍历类方法的过程当中和遍历实例方法的过程当中有一个区别，区别就在根元类对象 superclass 指针的指向</li>\n</ul>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Mobile.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Phone</span> : <span class=\"title\">Mobile</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .m</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Phone</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, <span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">super</span> <span class=\"keyword\">class</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出什么？</p>\n<p>先思考一会儿。。。</p>\n<p>解析：</p>\n<p>[self class] 消息的接收者是当前对象，从当前类对象的方法列表开始查找，class 这个方法实际上是在 NSObject 当中才有实现的，super 调用它的 class ，实际的接收着仍然是当前对象，也就是仍然是 self，只不过调用 [super class] 的时候是从当前对象的父类对象（跨越了类对象）当中开始查找 class 的方法实现，不论从哪开始查找，最终都是找到 NSObject 当中</p>\n<p>代码角度：</p>\n<p>[super class]会被转换为下面代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_super objcSuper = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>,</span><br><span class=\"line\">    class_getSuperclass([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">id</span> (*sendSuper)(<span class=\"keyword\">struct</span> objc_super*, SEL) = (<span class=\"keyword\">void</span>)objc_msgSendSuper;</span><br><span class=\"line\">sendSuper(&amp;objcSuper, <span class=\"keyword\">@selector</span>(<span class=\"keyword\">class</span>));</span><br></pre></td></tr></table></figure>\n<p>super的调用会被转换为objc_msgSendSuper的调用，并传入一个objc_super类型的结构体。结构体有两个参数，第一个就是接受消息的对象，第二个是[super class]对应的父类。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_super &#123;</span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _Nonnull <span class=\"keyword\">id</span> receiver;</span><br><span class=\"line\">    __<span class=\"keyword\">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>由此可知，虽然调用的是[super class]，但是接受消息的对象还是self。然后来到父类Father的class方法中，输出self对应的类 Phone。</p>\n<p>两个都是输出 Phone </p>\n"},{"title":"Runtime之动态添加方法(五)","date":"2017-02-21T10:13:03.000Z","description":"动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻:只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。","toc":false,"_content":"\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n* 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。\n\n* 如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。\n\n* 有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。\n\n## 动态添加方法\n\n以一个示例讲解：\n\n1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。\n\n```\nPanda *pan = [[Panda alloc] init];\n    \n// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。\n// 动态添加方法就不会报错\n    \n/** 无参 */\n//[pan performSelector:@selector(eat)];\n    \n/** 有参 */\n[pan performSelector:@selector(eat:) withObject:@521];\n    \n```\n\n2、在Panda类中添加方法（以有参为例）\n\n```\n#import \"Panda.h\"\n#import <objc/runtime.h>\n\n@implementation Panda\n\n// 默认方法都有两个隐式参数，\n// 定义添加的方法\nvoid eat(id self, SEL sel, NSNumber *meter)\n{\n    NSLog(@\"\\n%@\\n%@\\n%@\",self,NSStringFromSelector(sel),meter);\n}\n\n// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\n// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    \n    if (sel == NSSelectorFromString(@\"eat:\")) {\n        // 动态添加eat方法\n        \n        // 第一个参数：给哪个类添加方法\n        // 第二个参数：添加方法的方法编号\n        // 第三个参数：添加方法的函数实现（函数地址）\n        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n        \n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n@end\n\n```\n\n### 使用场景\n\n一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。\n\n比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n","source":"_posts/Runtime之动态添加方法.md","raw":"---\ntitle: Runtime之动态添加方法(五)\ndate: 2017-2-21 18:13:03\ndescription: 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻:只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。\ncategories: Runtime\ntags: [Objective-C,Runtime]\ntoc: false \n---\n\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n* 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。\n\n* 如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。\n\n* 有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。\n\n## 动态添加方法\n\n以一个示例讲解：\n\n1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。\n\n```\nPanda *pan = [[Panda alloc] init];\n    \n// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。\n// 动态添加方法就不会报错\n    \n/** 无参 */\n//[pan performSelector:@selector(eat)];\n    \n/** 有参 */\n[pan performSelector:@selector(eat:) withObject:@521];\n    \n```\n\n2、在Panda类中添加方法（以有参为例）\n\n```\n#import \"Panda.h\"\n#import <objc/runtime.h>\n\n@implementation Panda\n\n// 默认方法都有两个隐式参数，\n// 定义添加的方法\nvoid eat(id self, SEL sel, NSNumber *meter)\n{\n    NSLog(@\"\\n%@\\n%@\\n%@\",self,NSStringFromSelector(sel),meter);\n}\n\n// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\n// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    \n    if (sel == NSSelectorFromString(@\"eat:\")) {\n        // 动态添加eat方法\n        \n        // 第一个参数：给哪个类添加方法\n        // 第二个参数：添加方法的方法编号\n        // 第三个参数：添加方法的函数实现（函数地址）\n        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n        \n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n@end\n\n```\n\n### 使用场景\n\n一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。\n\n比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n","slug":"Runtime之动态添加方法","published":1,"updated":"2018-09-11T08:38:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnm001166r2oxwehg9u","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<ul>\n<li><p>动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。</p>\n</li>\n<li><p>如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。</p>\n</li>\n<li><p>有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。</p>\n</li>\n</ul>\n<h2 id=\"动态添加方法\"><a href=\"#动态添加方法\" class=\"headerlink\" title=\"动态添加方法\"></a>动态添加方法</h2><p>以一个示例讲解：</p>\n<p>1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panda *pan = [[Panda alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。</span></span><br><span class=\"line\"><span class=\"comment\">// 动态添加方法就不会报错</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 无参 *</span>/</span></span></span><br><span class=\"line\"><span class=\"comment\">//[pan performSelector:@selector(eat)];</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 有参 *</span>/</span></span></span><br><span class=\"line\">[pan performSelector:<span class=\"meta\">@selector</span>(eat:) withObject:@<span class=\"number\">521</span>];</span><br></pre></td></tr></table></figure>\n<p>2、在Panda类中添加方法（以有参为例）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Panda.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Panda</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认方法都有两个隐式参数，</span></span><br><span class=\"line\"><span class=\"comment\">// 定义添加的方法</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> eat(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL sel, <span class=\"built_in\">NSNumber</span> *meter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"\\n%@\\n%@\\n%@\"</span>,<span class=\"keyword\">self</span>,<span class=\"built_in\">NSStringFromSelector</span>(sel),meter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></span><br><span class=\"line\"><span class=\"comment\">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"eat:\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 动态添加eat方法</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数：给哪个类添加方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数：添加方法的方法编号</span></span><br><span class=\"line\">        <span class=\"comment\">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class=\"line\">        <span class=\"comment\">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。</p>\n<p>比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<ul>\n<li><p>动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。</p>\n</li>\n<li><p>如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。</p>\n</li>\n<li><p>有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。</p>\n</li>\n</ul>\n<h2 id=\"动态添加方法\"><a href=\"#动态添加方法\" class=\"headerlink\" title=\"动态添加方法\"></a>动态添加方法</h2><p>以一个示例讲解：</p>\n<p>1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panda *pan = [[Panda alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。</span></span><br><span class=\"line\"><span class=\"comment\">// 动态添加方法就不会报错</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 无参 *</span>/</span></span></span><br><span class=\"line\"><span class=\"comment\">//[pan performSelector:@selector(eat)];</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 有参 *</span>/</span></span></span><br><span class=\"line\">[pan performSelector:<span class=\"meta\">@selector</span>(eat:) withObject:@<span class=\"number\">521</span>];</span><br></pre></td></tr></table></figure>\n<p>2、在Panda类中添加方法（以有参为例）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Panda.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Panda</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认方法都有两个隐式参数，</span></span><br><span class=\"line\"><span class=\"comment\">// 定义添加的方法</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> eat(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL sel, <span class=\"built_in\">NSNumber</span> *meter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"\\n%@\\n%@\\n%@\"</span>,<span class=\"keyword\">self</span>,<span class=\"built_in\">NSStringFromSelector</span>(sel),meter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></span><br><span class=\"line\"><span class=\"comment\">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"eat:\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 动态添加eat方法</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数：给哪个类添加方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数：添加方法的方法编号</span></span><br><span class=\"line\">        <span class=\"comment\">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class=\"line\">        <span class=\"comment\">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。</p>\n<p>比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n"},{"title":"UITableView的优化进阶篇","date":"2018-02-16T09:23:33.000Z","description":"优化方案：异步渲染内容到图片和按需加载内容。","toc":false,"_content":"\n***\n[UITableView的优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)\n[UITableView的优化进阶篇](https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/)\n[APP的优化](https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/)\n***\n\nUITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\n那么优化就势在必得。。。\n\n## 在优化之前 \n\n### 异步渲染内容到图片\n\n这是一张典型的微博页面，这个页面若是采用普通的 View 控件拼凑的话，会需要多少个控件呢？我们这里简单划分一下。粗略划分了一下，我们大概需要 13 个 view 才能完成。\n\n\n![](https://upload-images.jianshu.io/upload_images/656644-ea7cbf59b7b44594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n对 TableView 的优化有时候可以直接考虑对 TableViewCell 的优化。对于复杂 View 的优化，首先考虑减少 View 的布局层级。我们将这个复杂的问题简单化，我们把 TableViewCell 按下图所示分割成三个部分，分别用红色，绿色，蓝色区分开来。 通过和实际的页面对比，我们可以看到红色部分的名字，日期，来源以及蓝色部分相对来说比较简单，布局变化比较小，所以我们可以考虑将这些内容全部绘制到一张图片上，来达到减少 View 的布局层级的目的。\n\n![](https://upload-images.jianshu.io/upload_images/656644-bda7883871b7e11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n我们排除其他干扰控件，使用 Xcode 来查看 TableViewCell 的布局层次，可以清晰的看到红色部分的名字，日期，来源以及整个蓝色蓝色部分都是直接绘制在图片上，图片使用一个 UIImageView 来承载。\n\n![](https://upload-images.jianshu.io/upload_images/656644-9ee28421b61fc161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n```\n// 使用 CoreText 绘制\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    CGRect rect = [_data[@\"frame\"] CGRectValue];\n    UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 最外层的大框\n    // [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];     \n    [[UIColor redColor] set];\n    CGContextFillRect(context, rect);\n    if ([_data valueForKey:@\"subData\"]) {\n        // 第二层框\n        // [[UIColor colorWithRed:243/255.0 green:243/255.0 blue:243/255.0 alpha:1] set];\n        [[UIColor greenColor] set];\n        CGRect subFrame = [_data[@\"subData\"][@\"frame\"] CGRectValue];\n        CGContextFillRect(context, subFrame);\n        // 线\n        [[UIColor colorWithRed:200/255.0 green:200/255.0 blue:200/255.0 alpha:1] set];\n        CGContextFillRect(context, CGRectMake(0, subFrame.origin.y, rect.size.width, 0.5));\n    }\n    {\n        // 名字\n        float leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;\n        float x = leftX;\n        float y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+6))/2-2+SIZE_GAP_TOP+SIZE_GAP_SMALL-5;\n        [_data[@\"name\"] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME) andTextColor:[UIColor colorWithRed:106/255.0 green:140/255.0 blue:181/255.0 alpha:1] andHeight:rect.size.height];\n        y += SIZE_FONT_NAME+5;\n        float fromX = leftX;\n        float size = [UIScreen screenWidth]-leftX;\n        // 时间和来源\n        NSString *from = [NSString stringWithFormat:@\"%@  %@\", _data[@\"time\"], _data[@\"from\"]];\n        NSString *from = [NSString stringWithFormat:@\"%@ %@\", _data[@\"time\"], _data[@\"from\"]]; [from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height andWidth:size];\n    }\n    {\n        CGRect countRect = CGRectMake(0, rect.size.height-30, [UIScreen screenWidth], 30);\n        // [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];\n        [[UIColor blueColor] set];\n        CGContextFillRect(context, countRect);\n        float alpha = 1;\n        // 评论\n        float x = [UIScreen screenWidth]-SIZE_GAP_LEFT-10;\n        NSString *comments = _data[@\"comments\"];\n        if (comments) {\n            CGSize size = [comments sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:5];\n            x -= size.width;\n            [comments drawInContext:context withPosition:CGPointMake(x, 8+countRect.origin.y) andFont:FontWithSize(12) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height];\n            // 图片画到 context\n            [[UIImage imageNamed:@\"t_comments.png\"] drawInRect:CGRectMake(x-5, 10.5+countRect.origin.y, 10, 9) blendMode:kCGBlendModeNormal alpha:alpha]; commentsRect = CGRectMake(x-5, self.height-50, [UIScreen screenWidth]-x+5, 50); x -= 20;\n         }\n         // 转发\n         NSString *reposts = _data[@\"reposts\"];\n         if (reposts) {\n             CGSize size = [reposts sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:5];\n             x -= MAX(size.width, 5)+SIZE_GAP_BIG;\n             [reposts drawInContext:context withPosition:CGPointMake(x, 8+countRect.origin.y) andFont:FontWithSize(12) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height];\n             [[UIImage imageNamed:@\"t_repost.png\"] drawInRect:CGRectMake(x-5, 11+countRect.origin.y, 10, 9) blendMode:kCGBlendModeNormal alpha:alpha]; repostsRect = CGRectMake(x-5, self.height-50, commentsRect.origin.x-x, 50); \n             x -= 20;\n         }\n         // ...\n         [@\"•••\" drawInContext:context withPosition:CGPointMake(SIZE_GAP_LEFT, 8+countRect.origin.y) andFont:FontWithSize(11) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:.5] andHeight:rect.size.height];\n         if ([_data valueForKey:@\"subData\"]) { \n             // 线 \n             [[UIColor colorWithRed:200/255.0 green:200/255.0 blue:200/255.0 alpha:1] set]; CGContextFillRect(context, CGRectMake(0, rect.size.height-30.5, rect.size.width, .5));\n          }\n     }\n     // 获取绘制的图片，然后切换到主线程设置图片\n     UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();\n     UIGraphicsEndImageContext();\n     dispatch_async(dispatch_get_main_queue(), ^{ \n         if (flag==drawColorFlag) { \n              postBGView.frame = rect; \n              postBGView.image = nil; \n              postBGView.image = temp; \n          } \n     }); \n});\n\n```\n\n在上面代码中，除了做到减少 View 的布局层级之外还使用了一个非常重要技术-异步渲染内容到图片。使用 dispatch_async 将绘制工作放到后台操作，减少主线程的计算工作量\n\n```\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{});\n```\n使用 CGContextFillRect 用于填充 View 的背景颜色。\n\n```\n//  [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];\n[[UIColor redColor] set];\nCGContextFillRect(context, rect);\n```\n利用 CoreText 来做文本排版，具体的 CoreText 实现细节可以参考 Demo 代码\n\n```\n{\n        // 名字\n        float leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;\n        float x = leftX;\n        float y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+6))/2-2+SIZE_GAP_TOP+SIZE_GAP_SMALL-5;\n        [_data[@\"name\"] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME) andTextColor:[UIColor colorWithRed:106/255.0 green:140/255.0 blue:181/255.0 alpha:1] andHeight:rect.size.height];\n        y += SIZE_FONT_NAME+5;\n        float fromX = leftX;\n        float size = [UIScreen screenWidth]-leftX;\n        // 时间和来源\n        NSString *from = [NSString stringWithFormat:@\"%@  %@\", _data[@\"time\"], _data[@\"from\"]];\n        NSString *from = [NSString stringWithFormat:@\"%@ %@\", _data[@\"time\"], _data[@\"from\"]]; [from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height andWidth:size];\n}\n```\n异步生成图片之后切换到主线程设置图片\n\n```\ndispatch_async(dispatch_get_main_queue(), ^{ \n         if (flag==drawColorFlag) { \n              postBGView.frame = rect; \n              postBGView.image = nil; \n              postBGView.image = temp; \n          } \n }); \n```\n\n处理好了减少 View 布局层级和异步绘制之后，我们还需要处理一个圆角头像的问题。圆角头像最简单的处理方法就是使用一张圆形镂空的图片来实现，不过这个实现方案有个缺陷就是对 View 的背景颜色有要求。这里采用的处理方案就是这个最简单的处理方法。\n\n![](https://upload-images.jianshu.io/upload_images/656644-6a2080dcdb710dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520)\n\n处理好了背景问题，接下来时候看看微博正文的问题了。微博的正文放在 label 控件里面，而转发的微博详情内容放在 detailLabel 里面。这个 label 是自定义控件 VVeboLabel，里面的 - (void)setText:(NSString *)text 方法具体的实现方式也是采用 CoreText 异步绘制实现的。\n\n```\n//设置文本内容，将文本内容设置在单独的 View 上面\n- (void)drawText{\n\n   if (label==nil||detailLabel==nil) {\n        [self addLabel];\n   }\n   label.frame = [_data[@\"textRect\"] CGRectValue];\n   [label setText:_data[@\"text\"]];\n   if ([_data valueForKey:@\"subData\"]) { \n      detailLabel.frame = [[_data valueForKey:@\"subData\"][@\"textRect\"] CGRectValue]; \n      [detailLabel setText:[_data valueForKey:@\"subData\"][@\"text\"]];\n      detailLabel.hidden = NO;\n   }\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/656644-b5dd6c1ccbe395a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n可能你会问了，使用 CoreText 异步绘制的文本内容如何设置监听事件呢？CoreText 又如何处理点击高亮问题呢？我们通过 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event 方法来获取用户的点击位置。将获取到的用户点击位置与事先保存文本位置比较，若是用户点击位置位于文本区域内，那么说明用户点击了文本。为了能够做出高亮效果，VVeboLabel 控件内部必须维护一个字段 highlighting 和一个用于显示高亮文本图片的 highlightImageView，当 highlighting == YES 的时候，异步绘制高亮文本内容生成图片并使用 highlightImageView 显示该图片，用于表示控件的高亮状态。\n\n```\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\n     CGPoint location = [[touches anyObject] locationInView:self]; \n     for (NSString *key in framesDict.allKeys) { \n          CGRect frame = [[framesDict valueForKey:key] CGRectValue]; \n          // 将获取到的用户点击位置与事先保存文本位置比较 \n          if (CGRectContainsPoint(frame, location)) { \n               NSRange range = NSRangeFromString(key); \n               range = NSMakeRange(range.location, range.length-1); \n               currentRange = range; \n               [self highlightWord]; \n               // *** 省略代码 \n          } \n    } \n}\n```\n\n```\n//  VVeboLabel.m\n// ... 省略代码\nif (highlighting) { \n   if (highlighting) { \n      highlightImageView.image = nil; \n      if (highlightImageView.width!=screenShotimage.size.width) { \n          highlightImageView.width = screenShotimage.size.width; \n      } \n      if (highlightImageView.height!=screenShotimage.size.height) { \n          highlightImageView.height = screenShotimage.size.height;\n      } \n      highlightImageView.image = screenShotimage; \n   } \n   \n} else { \n\n  if ([temp isEqualToString:text]) { \n     if (labelImageView.width!=screenShotimage.size.width) { \n        labelImageView.width = screenShotimage.size.width; \n     } \n     if (labelImageView.height!=screenShotimage.size.height) { \n        labelImageView.height = screenShotimage.size.height; \n     } \n     highlightImageView.image = nil; \n     labelImageView.image = nil; \n     labelImageView.image = screenShotimage;\n   } \n}\n \n // ... 省略代码\n    \n```\n\nVVeboLabel 控件处理高亮情况的 View 结构层次如下图。\n\n![](https://upload-images.jianshu.io/upload_images/656644-45d5d9f65a4b8da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n## 按需加载内容\n\nUITableView 的优化除了在 UITableViewCell 的绘制方面优化之后，还可以在加载数据方面优化，按需加载内容，避免加载暂时无用的数据，从而减少数据量，减少 UITableView 的绘制工作量,达到优化的目的\n\n判断按需加载的 indexPaths , 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。这样可以减少 UITableView 的绘制工作量\n\n```\n    - (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset{\n\n        NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset->y)];\n\n        NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];\n\n        NSInteger skipCount = 8;\n\n         // 目标行与当前行相差超过指定行数\n\n        if (labs(cip.row-ip.row)>skipCount) {\n\n            // 目标位置的行\n\n            NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset->y, self.width, self.height)];\n\n            NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];\n\n            //  velocity.y0 上拉\n\n            if (velocity.y<0) {\n\n                NSIndexPath *indexPath = [temp lastObject];\n\n                if (indexPath.row+33) {\n\n                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];\n\n                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];\n\n                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];\n                }\n            }\n            [needLoadArr addObjectsFromArray:arr];\n        }\n    }\n```\n\n当 UITableView 开始绘制 Cell 的时候，若是 indexpath 包含在按需绘制的 needLoadArr 数组里面，那么就异步绘制该 Cell ，如果没有则跳过该 Cell 。\n\n```\n    - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n\n        VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n\n        if (cell==nil) {\n\n            cell = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault\n\n                                             reuseIdentifier:@\"cell\"];\n\n        }\n\n        // 绘制 Cell\n        [self drawCell:cell withIndexPath:indexPath];\n\n        return cell;\n\n    }\n\n    // 按需绘制 Cell\n    - (void)drawCell:(VVeboTableViewCell *)cell withIndexPath:(NSIndexPath *)indexPath{\n\n        NSDictionary *data = [datas objectAtIndex:indexPath.row];\n\n        cell.selectionStyle = UITableViewCellSelectionStyleNone;\n\n        [cell clear];\n\n        cell.data = data;\n\n        // 按需绘制，只要在 needLoadArr 里面的 indexPath 才需要绘制 Cell\n\n        if (needLoadArr.count>0&&[needLoadArr indexOfObject:indexPath]==NSNotFound) {\n\n            [cell clear];\n\n            return;\n        }\n\n        if (scrollToToping) {\n\n            return;\n        }\n        [cell draw];\n   }\n```\n\n这篇博客文章主要是学习 VVebo 的 UITableView 优化技巧，VVebo 的作者将 VVeboTableViewDemo开源在 GitHub，大家可以查阅代码，感谢作者。这个方案也有存在一个不足，在 TableView 快速滑动的时候，页面会出现空白。\n\n### 文章链接\n\n[UITableView优化](https://www.jianshu.com/p/2d077da3af94)\n\n\n\n","source":"_posts/UITableView的优化进阶篇.md","raw":"---\ntitle: UITableView的优化进阶篇\ndate: 2018-2-16 17:23:33\n\ndescription: 优化方案：异步渲染内容到图片和按需加载内容。\n\ncategories: [性能优化]\ntags: [Objective-C]\ntoc: false \n---\n\n***\n[UITableView的优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)\n[UITableView的优化进阶篇](https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/)\n[APP的优化](https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/)\n***\n\nUITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\n那么优化就势在必得。。。\n\n## 在优化之前 \n\n### 异步渲染内容到图片\n\n这是一张典型的微博页面，这个页面若是采用普通的 View 控件拼凑的话，会需要多少个控件呢？我们这里简单划分一下。粗略划分了一下，我们大概需要 13 个 view 才能完成。\n\n\n![](https://upload-images.jianshu.io/upload_images/656644-ea7cbf59b7b44594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n对 TableView 的优化有时候可以直接考虑对 TableViewCell 的优化。对于复杂 View 的优化，首先考虑减少 View 的布局层级。我们将这个复杂的问题简单化，我们把 TableViewCell 按下图所示分割成三个部分，分别用红色，绿色，蓝色区分开来。 通过和实际的页面对比，我们可以看到红色部分的名字，日期，来源以及蓝色部分相对来说比较简单，布局变化比较小，所以我们可以考虑将这些内容全部绘制到一张图片上，来达到减少 View 的布局层级的目的。\n\n![](https://upload-images.jianshu.io/upload_images/656644-bda7883871b7e11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n我们排除其他干扰控件，使用 Xcode 来查看 TableViewCell 的布局层次，可以清晰的看到红色部分的名字，日期，来源以及整个蓝色蓝色部分都是直接绘制在图片上，图片使用一个 UIImageView 来承载。\n\n![](https://upload-images.jianshu.io/upload_images/656644-9ee28421b61fc161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n```\n// 使用 CoreText 绘制\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    CGRect rect = [_data[@\"frame\"] CGRectValue];\n    UIGraphicsBeginImageContextWithOptions(rect.size, YES, 0);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    // 最外层的大框\n    // [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];     \n    [[UIColor redColor] set];\n    CGContextFillRect(context, rect);\n    if ([_data valueForKey:@\"subData\"]) {\n        // 第二层框\n        // [[UIColor colorWithRed:243/255.0 green:243/255.0 blue:243/255.0 alpha:1] set];\n        [[UIColor greenColor] set];\n        CGRect subFrame = [_data[@\"subData\"][@\"frame\"] CGRectValue];\n        CGContextFillRect(context, subFrame);\n        // 线\n        [[UIColor colorWithRed:200/255.0 green:200/255.0 blue:200/255.0 alpha:1] set];\n        CGContextFillRect(context, CGRectMake(0, subFrame.origin.y, rect.size.width, 0.5));\n    }\n    {\n        // 名字\n        float leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;\n        float x = leftX;\n        float y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+6))/2-2+SIZE_GAP_TOP+SIZE_GAP_SMALL-5;\n        [_data[@\"name\"] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME) andTextColor:[UIColor colorWithRed:106/255.0 green:140/255.0 blue:181/255.0 alpha:1] andHeight:rect.size.height];\n        y += SIZE_FONT_NAME+5;\n        float fromX = leftX;\n        float size = [UIScreen screenWidth]-leftX;\n        // 时间和来源\n        NSString *from = [NSString stringWithFormat:@\"%@  %@\", _data[@\"time\"], _data[@\"from\"]];\n        NSString *from = [NSString stringWithFormat:@\"%@ %@\", _data[@\"time\"], _data[@\"from\"]]; [from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height andWidth:size];\n    }\n    {\n        CGRect countRect = CGRectMake(0, rect.size.height-30, [UIScreen screenWidth], 30);\n        // [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];\n        [[UIColor blueColor] set];\n        CGContextFillRect(context, countRect);\n        float alpha = 1;\n        // 评论\n        float x = [UIScreen screenWidth]-SIZE_GAP_LEFT-10;\n        NSString *comments = _data[@\"comments\"];\n        if (comments) {\n            CGSize size = [comments sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:5];\n            x -= size.width;\n            [comments drawInContext:context withPosition:CGPointMake(x, 8+countRect.origin.y) andFont:FontWithSize(12) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height];\n            // 图片画到 context\n            [[UIImage imageNamed:@\"t_comments.png\"] drawInRect:CGRectMake(x-5, 10.5+countRect.origin.y, 10, 9) blendMode:kCGBlendModeNormal alpha:alpha]; commentsRect = CGRectMake(x-5, self.height-50, [UIScreen screenWidth]-x+5, 50); x -= 20;\n         }\n         // 转发\n         NSString *reposts = _data[@\"reposts\"];\n         if (reposts) {\n             CGSize size = [reposts sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:5];\n             x -= MAX(size.width, 5)+SIZE_GAP_BIG;\n             [reposts drawInContext:context withPosition:CGPointMake(x, 8+countRect.origin.y) andFont:FontWithSize(12) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height];\n             [[UIImage imageNamed:@\"t_repost.png\"] drawInRect:CGRectMake(x-5, 11+countRect.origin.y, 10, 9) blendMode:kCGBlendModeNormal alpha:alpha]; repostsRect = CGRectMake(x-5, self.height-50, commentsRect.origin.x-x, 50); \n             x -= 20;\n         }\n         // ...\n         [@\"•••\" drawInContext:context withPosition:CGPointMake(SIZE_GAP_LEFT, 8+countRect.origin.y) andFont:FontWithSize(11) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:.5] andHeight:rect.size.height];\n         if ([_data valueForKey:@\"subData\"]) { \n             // 线 \n             [[UIColor colorWithRed:200/255.0 green:200/255.0 blue:200/255.0 alpha:1] set]; CGContextFillRect(context, CGRectMake(0, rect.size.height-30.5, rect.size.width, .5));\n          }\n     }\n     // 获取绘制的图片，然后切换到主线程设置图片\n     UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();\n     UIGraphicsEndImageContext();\n     dispatch_async(dispatch_get_main_queue(), ^{ \n         if (flag==drawColorFlag) { \n              postBGView.frame = rect; \n              postBGView.image = nil; \n              postBGView.image = temp; \n          } \n     }); \n});\n\n```\n\n在上面代码中，除了做到减少 View 的布局层级之外还使用了一个非常重要技术-异步渲染内容到图片。使用 dispatch_async 将绘制工作放到后台操作，减少主线程的计算工作量\n\n```\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{});\n```\n使用 CGContextFillRect 用于填充 View 的背景颜色。\n\n```\n//  [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];\n[[UIColor redColor] set];\nCGContextFillRect(context, rect);\n```\n利用 CoreText 来做文本排版，具体的 CoreText 实现细节可以参考 Demo 代码\n\n```\n{\n        // 名字\n        float leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;\n        float x = leftX;\n        float y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+6))/2-2+SIZE_GAP_TOP+SIZE_GAP_SMALL-5;\n        [_data[@\"name\"] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME) andTextColor:[UIColor colorWithRed:106/255.0 green:140/255.0 blue:181/255.0 alpha:1] andHeight:rect.size.height];\n        y += SIZE_FONT_NAME+5;\n        float fromX = leftX;\n        float size = [UIScreen screenWidth]-leftX;\n        // 时间和来源\n        NSString *from = [NSString stringWithFormat:@\"%@  %@\", _data[@\"time\"], _data[@\"from\"]];\n        NSString *from = [NSString stringWithFormat:@\"%@ %@\", _data[@\"time\"], _data[@\"from\"]]; [from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE) andTextColor:[UIColor colorWithRed:178/255.0 green:178/255.0 blue:178/255.0 alpha:1] andHeight:rect.size.height andWidth:size];\n}\n```\n异步生成图片之后切换到主线程设置图片\n\n```\ndispatch_async(dispatch_get_main_queue(), ^{ \n         if (flag==drawColorFlag) { \n              postBGView.frame = rect; \n              postBGView.image = nil; \n              postBGView.image = temp; \n          } \n }); \n```\n\n处理好了减少 View 布局层级和异步绘制之后，我们还需要处理一个圆角头像的问题。圆角头像最简单的处理方法就是使用一张圆形镂空的图片来实现，不过这个实现方案有个缺陷就是对 View 的背景颜色有要求。这里采用的处理方案就是这个最简单的处理方法。\n\n![](https://upload-images.jianshu.io/upload_images/656644-6a2080dcdb710dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520)\n\n处理好了背景问题，接下来时候看看微博正文的问题了。微博的正文放在 label 控件里面，而转发的微博详情内容放在 detailLabel 里面。这个 label 是自定义控件 VVeboLabel，里面的 - (void)setText:(NSString *)text 方法具体的实现方式也是采用 CoreText 异步绘制实现的。\n\n```\n//设置文本内容，将文本内容设置在单独的 View 上面\n- (void)drawText{\n\n   if (label==nil||detailLabel==nil) {\n        [self addLabel];\n   }\n   label.frame = [_data[@\"textRect\"] CGRectValue];\n   [label setText:_data[@\"text\"]];\n   if ([_data valueForKey:@\"subData\"]) { \n      detailLabel.frame = [[_data valueForKey:@\"subData\"][@\"textRect\"] CGRectValue]; \n      [detailLabel setText:[_data valueForKey:@\"subData\"][@\"text\"]];\n      detailLabel.hidden = NO;\n   }\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/656644-b5dd6c1ccbe395a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n可能你会问了，使用 CoreText 异步绘制的文本内容如何设置监听事件呢？CoreText 又如何处理点击高亮问题呢？我们通过 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event 方法来获取用户的点击位置。将获取到的用户点击位置与事先保存文本位置比较，若是用户点击位置位于文本区域内，那么说明用户点击了文本。为了能够做出高亮效果，VVeboLabel 控件内部必须维护一个字段 highlighting 和一个用于显示高亮文本图片的 highlightImageView，当 highlighting == YES 的时候，异步绘制高亮文本内容生成图片并使用 highlightImageView 显示该图片，用于表示控件的高亮状态。\n\n```\n- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{ \n\n     CGPoint location = [[touches anyObject] locationInView:self]; \n     for (NSString *key in framesDict.allKeys) { \n          CGRect frame = [[framesDict valueForKey:key] CGRectValue]; \n          // 将获取到的用户点击位置与事先保存文本位置比较 \n          if (CGRectContainsPoint(frame, location)) { \n               NSRange range = NSRangeFromString(key); \n               range = NSMakeRange(range.location, range.length-1); \n               currentRange = range; \n               [self highlightWord]; \n               // *** 省略代码 \n          } \n    } \n}\n```\n\n```\n//  VVeboLabel.m\n// ... 省略代码\nif (highlighting) { \n   if (highlighting) { \n      highlightImageView.image = nil; \n      if (highlightImageView.width!=screenShotimage.size.width) { \n          highlightImageView.width = screenShotimage.size.width; \n      } \n      if (highlightImageView.height!=screenShotimage.size.height) { \n          highlightImageView.height = screenShotimage.size.height;\n      } \n      highlightImageView.image = screenShotimage; \n   } \n   \n} else { \n\n  if ([temp isEqualToString:text]) { \n     if (labelImageView.width!=screenShotimage.size.width) { \n        labelImageView.width = screenShotimage.size.width; \n     } \n     if (labelImageView.height!=screenShotimage.size.height) { \n        labelImageView.height = screenShotimage.size.height; \n     } \n     highlightImageView.image = nil; \n     labelImageView.image = nil; \n     labelImageView.image = screenShotimage;\n   } \n}\n \n // ... 省略代码\n    \n```\n\nVVeboLabel 控件处理高亮情况的 View 结构层次如下图。\n\n![](https://upload-images.jianshu.io/upload_images/656644-45d5d9f65a4b8da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n## 按需加载内容\n\nUITableView 的优化除了在 UITableViewCell 的绘制方面优化之后，还可以在加载数据方面优化，按需加载内容，避免加载暂时无用的数据，从而减少数据量，减少 UITableView 的绘制工作量,达到优化的目的\n\n判断按需加载的 indexPaths , 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。这样可以减少 UITableView 的绘制工作量\n\n```\n    - (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset{\n\n        NSIndexPath *ip = [self indexPathForRowAtPoint:CGPointMake(0, targetContentOffset->y)];\n\n        NSIndexPath *cip = [[self indexPathsForVisibleRows] firstObject];\n\n        NSInteger skipCount = 8;\n\n         // 目标行与当前行相差超过指定行数\n\n        if (labs(cip.row-ip.row)>skipCount) {\n\n            // 目标位置的行\n\n            NSArray *temp = [self indexPathsForRowsInRect:CGRectMake(0, targetContentOffset->y, self.width, self.height)];\n\n            NSMutableArray *arr = [NSMutableArray arrayWithArray:temp];\n\n            //  velocity.y0 上拉\n\n            if (velocity.y<0) {\n\n                NSIndexPath *indexPath = [temp lastObject];\n\n                if (indexPath.row+33) {\n\n                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-3 inSection:0]];\n\n                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-2 inSection:0]];\n\n                    [arr addObject:[NSIndexPath indexPathForRow:indexPath.row-1 inSection:0]];\n                }\n            }\n            [needLoadArr addObjectsFromArray:arr];\n        }\n    }\n```\n\n当 UITableView 开始绘制 Cell 的时候，若是 indexpath 包含在按需绘制的 needLoadArr 数组里面，那么就异步绘制该 Cell ，如果没有则跳过该 Cell 。\n\n```\n    - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{\n\n        VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\"];\n\n        if (cell==nil) {\n\n            cell = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault\n\n                                             reuseIdentifier:@\"cell\"];\n\n        }\n\n        // 绘制 Cell\n        [self drawCell:cell withIndexPath:indexPath];\n\n        return cell;\n\n    }\n\n    // 按需绘制 Cell\n    - (void)drawCell:(VVeboTableViewCell *)cell withIndexPath:(NSIndexPath *)indexPath{\n\n        NSDictionary *data = [datas objectAtIndex:indexPath.row];\n\n        cell.selectionStyle = UITableViewCellSelectionStyleNone;\n\n        [cell clear];\n\n        cell.data = data;\n\n        // 按需绘制，只要在 needLoadArr 里面的 indexPath 才需要绘制 Cell\n\n        if (needLoadArr.count>0&&[needLoadArr indexOfObject:indexPath]==NSNotFound) {\n\n            [cell clear];\n\n            return;\n        }\n\n        if (scrollToToping) {\n\n            return;\n        }\n        [cell draw];\n   }\n```\n\n这篇博客文章主要是学习 VVebo 的 UITableView 优化技巧，VVebo 的作者将 VVeboTableViewDemo开源在 GitHub，大家可以查阅代码，感谢作者。这个方案也有存在一个不足，在 TableView 快速滑动的时候，页面会出现空白。\n\n### 文章链接\n\n[UITableView优化](https://www.jianshu.com/p/2d077da3af94)\n\n\n\n","slug":"UITableView的优化进阶篇","published":1,"updated":"2018-08-31T03:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnn001466r2moz207gh","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">UITableView的优化进阶篇</a><br><a href=\"https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">APP的优化</a></p>\n<hr>\n<p>UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。</p>\n<p>那么优化就势在必得。。。</p>\n<h2 id=\"在优化之前\"><a href=\"#在优化之前\" class=\"headerlink\" title=\"在优化之前\"></a>在优化之前</h2><h3 id=\"异步渲染内容到图片\"><a href=\"#异步渲染内容到图片\" class=\"headerlink\" title=\"异步渲染内容到图片\"></a>异步渲染内容到图片</h3><p>这是一张典型的微博页面，这个页面若是采用普通的 View 控件拼凑的话，会需要多少个控件呢？我们这里简单划分一下。粗略划分了一下，我们大概需要 13 个 view 才能完成。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-ea7cbf59b7b44594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>对 TableView 的优化有时候可以直接考虑对 TableViewCell 的优化。对于复杂 View 的优化，首先考虑减少 View 的布局层级。我们将这个复杂的问题简单化，我们把 TableViewCell 按下图所示分割成三个部分，分别用红色，绿色，蓝色区分开来。 通过和实际的页面对比，我们可以看到红色部分的名字，日期，来源以及蓝色部分相对来说比较简单，布局变化比较小，所以我们可以考虑将这些内容全部绘制到一张图片上，来达到减少 View 的布局层级的目的。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-bda7883871b7e11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>我们排除其他干扰控件，使用 Xcode 来查看 TableViewCell 的布局层次，可以清晰的看到红色部分的名字，日期，来源以及整个蓝色蓝色部分都是直接绘制在图片上，图片使用一个 UIImageView 来承载。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-9ee28421b61fc161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 CoreText 绘制</span></span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">    CGRect <span class=\"built_in\">rect</span> = [_data[@<span class=\"string\">\"frame\"</span>] CGRectValue];</span><br><span class=\"line\">    UIGraphicsBeginImageContextWithOptions(<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>, YES, <span class=\"number\">0</span>);</span><br><span class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class=\"line\">    <span class=\"comment\">// 最外层的大框</span></span><br><span class=\"line\">    <span class=\"comment\">// [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];     </span></span><br><span class=\"line\">    [[UIColor redColor] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">    CGContextFillRect(context, <span class=\"built_in\">rect</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([_data valueForKey:@<span class=\"string\">\"subData\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第二层框</span></span><br><span class=\"line\">        <span class=\"comment\">// [[UIColor colorWithRed:243/255.0 green:243/255.0 blue:243/255.0 alpha:1] set];</span></span><br><span class=\"line\">        [[UIColor greenColor] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">        CGRect subFrame = [_data[@<span class=\"string\">\"subData\"</span>][@<span class=\"string\">\"frame\"</span>] CGRectValue];</span><br><span class=\"line\">        CGContextFillRect(context, subFrame);</span><br><span class=\"line\">        <span class=\"comment\">// 线</span></span><br><span class=\"line\">        [[UIColor colorWithRed:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">        CGContextFillRect(context, CGRectMake(<span class=\"number\">0</span>, subFrame.origin.y, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>, <span class=\"number\">0.5</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 名字</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> x = leftX;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class=\"number\">6</span>))/<span class=\"number\">2</span><span class=\"number\">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class=\"number\">-5</span>;</span><br><span class=\"line\">        [_data[@<span class=\"string\">\"name\"</span>] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME) andTextColor:[UIColor colorWithRed:<span class=\"number\">106</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">140</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">181</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">        y += SIZE_FONT_NAME+<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> fromX = leftX;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> <span class=\"built_in\">size</span> = [UIScreen screenWidth]-leftX;</span><br><span class=\"line\">        <span class=\"comment\">// 时间和来源</span></span><br><span class=\"line\">        NSString *from = [NSString stringWithFormat:@<span class=\"string\">\"%@  %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]];</span><br><span class=\"line\">        NSString *from = [NSString stringWithFormat:@<span class=\"string\">\"%@ %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]]; [from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span> andWidth:<span class=\"built_in\">size</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CGRect countRect = CGRectMake(<span class=\"number\">0</span>, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span><span class=\"number\">-30</span>, [UIScreen screenWidth], <span class=\"number\">30</span>);</span><br><span class=\"line\">        <span class=\"comment\">// [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];</span></span><br><span class=\"line\">        [[UIColor blueColor] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">        CGContextFillRect(context, countRect);</span><br><span class=\"line\">        <span class=\"built_in\">float</span> <span class=\"built_in\">alpha</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 评论</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> x = [UIScreen screenWidth]-SIZE_GAP_LEFT<span class=\"number\">-10</span>;</span><br><span class=\"line\">        NSString *comments = _data[@<span class=\"string\">\"comments\"</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comments) &#123;</span><br><span class=\"line\">            CGSize <span class=\"built_in\">size</span> = [comments sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class=\"number\">5</span>];</span><br><span class=\"line\">            x -= <span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>;</span><br><span class=\"line\">            [comments drawInContext:context withPosition:CGPointMake(x, <span class=\"number\">8</span>+countRect.origin.y) andFont:FontWithSize(<span class=\"number\">12</span>) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">            <span class=\"comment\">// 图片画到 context</span></span><br><span class=\"line\">            [[UIImage imageNamed:@<span class=\"string\">\"t_comments.png\"</span>] drawInRect:CGRectMake(x<span class=\"number\">-5</span>, <span class=\"number\">10.5</span>+countRect.origin.y, <span class=\"number\">10</span>, <span class=\"number\">9</span>) <span class=\"built_in\">blendMode</span>:kCGBlendModeNormal <span class=\"built_in\">alpha</span>:<span class=\"built_in\">alpha</span>]; commentsRect = CGRectMake(x<span class=\"number\">-5</span>, self.<span class=\"built_in\">height</span><span class=\"number\">-50</span>, [UIScreen screenWidth]-x+<span class=\"number\">5</span>, <span class=\"number\">50</span>); x -= <span class=\"number\">20</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"comment\">// 转发</span></span><br><span class=\"line\">         NSString *reposts = _data[@<span class=\"string\">\"reposts\"</span>];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (reposts) &#123;</span><br><span class=\"line\">             CGSize <span class=\"built_in\">size</span> = [reposts sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class=\"number\">5</span>];</span><br><span class=\"line\">             x -= MAX(<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>, <span class=\"number\">5</span>)+SIZE_GAP_BIG;</span><br><span class=\"line\">             [reposts drawInContext:context withPosition:CGPointMake(x, <span class=\"number\">8</span>+countRect.origin.y) andFont:FontWithSize(<span class=\"number\">12</span>) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">             [[UIImage imageNamed:@<span class=\"string\">\"t_repost.png\"</span>] drawInRect:CGRectMake(x<span class=\"number\">-5</span>, <span class=\"number\">11</span>+countRect.origin.y, <span class=\"number\">10</span>, <span class=\"number\">9</span>) <span class=\"built_in\">blendMode</span>:kCGBlendModeNormal <span class=\"built_in\">alpha</span>:<span class=\"built_in\">alpha</span>]; repostsRect = CGRectMake(x<span class=\"number\">-5</span>, self.<span class=\"built_in\">height</span><span class=\"number\">-50</span>, commentsRect.origin.x-x, <span class=\"number\">50</span>); </span><br><span class=\"line\">             x -= <span class=\"number\">20</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"comment\">// ...</span></span><br><span class=\"line\">         [@<span class=\"string\">\"•••\"</span> drawInContext:context withPosition:CGPointMake(SIZE_GAP_LEFT, <span class=\"number\">8</span>+countRect.origin.y) andFont:FontWithSize(<span class=\"number\">11</span>) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">.5</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ([_data valueForKey:@<span class=\"string\">\"subData\"</span>]) &#123; </span><br><span class=\"line\">             <span class=\"comment\">// 线 </span></span><br><span class=\"line\">             [[UIColor colorWithRed:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] <span class=\"built_in\">set</span>]; CGContextFillRect(context, CGRectMake(<span class=\"number\">0</span>, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span><span class=\"number\">-30.5</span>, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>, <span class=\"number\">.5</span>));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 获取绘制的图片，然后切换到主线程设置图片</span></span><br><span class=\"line\">     UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class=\"line\">     UIGraphicsEndImageContext();</span><br><span class=\"line\">     dispatch_async(dispatch_get_main_queue(), ^&#123; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (flag==drawColorFlag) &#123; </span><br><span class=\"line\">              postBGView.frame = <span class=\"built_in\">rect</span>; </span><br><span class=\"line\">              postBGView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">              postBGView.<span class=\"built_in\">image</span> = temp; </span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">     &#125;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，除了做到减少 View 的布局层级之外还使用了一个非常重要技术-异步渲染内容到图片。使用 dispatch_async 将绘制工作放到后台操作，减少主线程的计算工作量</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_global_queue</span>(<span class=\"name\">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class=\"number\">0</span>), ^&#123;&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>使用 CGContextFillRect 用于填充 View 的背景颜色。</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  <span class=\"comment\">[<span class=\"comment\">[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1]</span> set]</span>;</span><br><span class=\"line\"><span class=\"comment\">[<span class=\"comment\">[UIColor redColor]</span> set]</span>;</span><br><span class=\"line\">CGContextFillRect(context, rect);</span><br></pre></td></tr></table></figure>\n<p>利用 CoreText 来做文本排版，具体的 CoreText 实现细节可以参考 Demo 代码</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 名字</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> x = leftX;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class=\"number\">6</span>))/<span class=\"number\">2</span><span class=\"number\">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class=\"number\">-5</span>;</span><br><span class=\"line\">        [_data[@<span class=\"string\">\"name\"</span>] <span class=\"string\">drawInContext:</span>context <span class=\"string\">withPosition:</span>CGPointMake(x, y) <span class=\"string\">andFont:</span>FontWithSize(SIZE_FONT_NAME) <span class=\"string\">andTextColor:</span>[UIColor <span class=\"string\">colorWithRed:</span><span class=\"number\">106</span><span class=\"regexp\">/255.0 green:140/</span><span class=\"number\">255.0</span> <span class=\"string\">blue:</span><span class=\"number\">181</span>/<span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1</span>] <span class=\"string\">andHeight:</span>rect.size.height];</span><br><span class=\"line\">        y += SIZE_FONT_NAME+<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> fromX = leftX;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> size = [UIScreen screenWidth]-leftX;</span><br><span class=\"line\">        <span class=\"comment\">// 时间和来源</span></span><br><span class=\"line\">        NSString *from = [NSString <span class=\"string\">stringWithFormat:</span>@<span class=\"string\">\"%@  %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]];</span><br><span class=\"line\">        NSString *from = [NSString <span class=\"string\">stringWithFormat:</span>@<span class=\"string\">\"%@ %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]]; [from <span class=\"string\">drawInContext:</span>context <span class=\"string\">withPosition:</span>CGPointMake(fromX, y) <span class=\"string\">andFont:</span>FontWithSize(SIZE_FONT_SUBTITLE) <span class=\"string\">andTextColor:</span>[UIColor <span class=\"string\">colorWithRed:</span><span class=\"number\">178</span><span class=\"regexp\">/255.0 green:178/</span><span class=\"number\">255.0</span> <span class=\"string\">blue:</span><span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1</span>] <span class=\"string\">andHeight:</span>rect.size.height <span class=\"string\">andWidth:</span>size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>异步生成图片之后切换到主线程设置图片</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), ^&#123; </span><br><span class=\"line\">         if (<span class=\"name\">flag==drawColorFlag</span>) &#123; </span><br><span class=\"line\">              postBGView.frame = rect<span class=\"comment\">; </span></span><br><span class=\"line\">              postBGView.image = <span class=\"literal\">nil</span><span class=\"comment\">; </span></span><br><span class=\"line\">              postBGView.image = temp<span class=\"comment\">; </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\"> &#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>处理好了减少 View 布局层级和异步绘制之后，我们还需要处理一个圆角头像的问题。圆角头像最简单的处理方法就是使用一张圆形镂空的图片来实现，不过这个实现方案有个缺陷就是对 View 的背景颜色有要求。这里采用的处理方案就是这个最简单的处理方法。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-6a2080dcdb710dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520\" alt=\"\"></p>\n<p>处理好了背景问题，接下来时候看看微博正文的问题了。微博的正文放在 label 控件里面，而转发的微博详情内容放在 detailLabel 里面。这个 label 是自定义控件 VVeboLabel，里面的 - (void)setText:(NSString *)text 方法具体的实现方式也是采用 CoreText 异步绘制实现的。</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置文本内容，将文本内容设置在单独的 <span class=\"symbol\">View</span> 上面</span><br><span class=\"line\">- (void)drawText&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   if (label==nil||detailLabel==nil) &#123;</span><br><span class=\"line\">        [self addLabel];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   label.frame = [<span class=\"symbol\">_data</span>[@<span class=\"string\">\"textRect\"</span>] <span class=\"symbol\">CGRectValue</span>];</span><br><span class=\"line\">   [label setText:<span class=\"symbol\">_data</span>[@<span class=\"string\">\"text\"</span>]];</span><br><span class=\"line\">   if ([<span class=\"symbol\">_data</span> valueForKey:@<span class=\"string\">\"subData\"</span>]) &#123; </span><br><span class=\"line\">      detailLabel.frame = [[<span class=\"symbol\">_data</span> valueForKey:@<span class=\"string\">\"subData\"</span>][@<span class=\"string\">\"textRect\"</span>] <span class=\"symbol\">CGRectValue</span>]; </span><br><span class=\"line\">      [detailLabel setText:[<span class=\"symbol\">_data</span> valueForKey:@<span class=\"string\">\"subData\"</span>][@<span class=\"string\">\"text\"</span>]];</span><br><span class=\"line\">      detailLabel.hidden = <span class=\"symbol\">NO</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-b5dd6c1ccbe395a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>可能你会问了，使用 CoreText 异步绘制的文本内容如何设置监听事件呢？CoreText 又如何处理点击高亮问题呢？我们通过 - (void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event 方法来获取用户的点击位置。将获取到的用户点击位置与事先保存文本位置比较，若是用户点击位置位于文本区域内，那么说明用户点击了文本。为了能够做出高亮效果，VVeboLabel 控件内部必须维护一个字段 highlighting 和一个用于显示高亮文本图片的 highlightImageView，当 highlighting == YES 的时候，异步绘制高亮文本内容生成图片并使用 highlightImageView 显示该图片，用于表示控件的高亮状态。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">CGPoint</span> location = [[touches anyObject] locationInView:<span class=\"keyword\">self</span>]; </span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> framesDict.allKeys) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">CGRect</span> frame = [[framesDict valueForKey:key] <span class=\"built_in\">CGRectValue</span>]; </span><br><span class=\"line\">          <span class=\"comment\">// 将获取到的用户点击位置与事先保存文本位置比较 </span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">CGRectContainsPoint</span>(frame, location)) &#123; </span><br><span class=\"line\">               <span class=\"built_in\">NSRange</span> range = <span class=\"built_in\">NSRangeFromString</span>(key); </span><br><span class=\"line\">               range = <span class=\"built_in\">NSMakeRange</span>(range.location, range.length<span class=\"number\">-1</span>); </span><br><span class=\"line\">               currentRange = range; </span><br><span class=\"line\">               [<span class=\"keyword\">self</span> highlightWord]; </span><br><span class=\"line\">               <span class=\"comment\">// *** 省略代码 </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  VVeboLabel.m</span></span><br><span class=\"line\"><span class=\"comment\">// ... 省略代码</span></span><br><span class=\"line\"><span class=\"built_in\">if</span> (highlighting) &#123; </span><br><span class=\"line\">   <span class=\"built_in\">if</span> (highlighting) &#123; </span><br><span class=\"line\">      highlightImageView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">      <span class=\"built_in\">if</span> (highlightImageView.<span class=\"built_in\">width</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>) &#123; </span><br><span class=\"line\">          highlightImageView.<span class=\"built_in\">width</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">if</span> (highlightImageView.<span class=\"built_in\">height</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>) &#123; </span><br><span class=\"line\">          highlightImageView.<span class=\"built_in\">height</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      highlightImageView.<span class=\"built_in\">image</span> = screenShotimage; </span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125; <span class=\"built_in\">else</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">if</span> ([temp isEqualToString:<span class=\"built_in\">text</span>]) &#123; </span><br><span class=\"line\">     <span class=\"built_in\">if</span> (labelImageView.<span class=\"built_in\">width</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>) &#123; </span><br><span class=\"line\">        labelImageView.<span class=\"built_in\">width</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"built_in\">if</span> (labelImageView.<span class=\"built_in\">height</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>) &#123; </span><br><span class=\"line\">        labelImageView.<span class=\"built_in\">height</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     highlightImageView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">     labelImageView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">     labelImageView.<span class=\"built_in\">image</span> = screenShotimage;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// ... 省略代码</span></span><br></pre></td></tr></table></figure>\n<p>VVeboLabel 控件处理高亮情况的 View 结构层次如下图。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-45d5d9f65a4b8da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<h2 id=\"按需加载内容\"><a href=\"#按需加载内容\" class=\"headerlink\" title=\"按需加载内容\"></a>按需加载内容</h2><p>UITableView 的优化除了在 UITableViewCell 的绘制方面优化之后，还可以在加载数据方面优化，按需加载内容，避免加载暂时无用的数据，从而减少数据量，减少 UITableView 的绘制工作量,达到优化的目的</p>\n<p>判断按需加载的 indexPaths , 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。这样可以减少 UITableView 的绘制工作量</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *ip = [<span class=\"keyword\">self</span> indexPathForRowAtPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, targetContentOffset-&gt;y)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *cip = [[<span class=\"keyword\">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> skipCount = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 目标行与当前行相差超过指定行数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 目标位置的行</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *temp = [<span class=\"keyword\">self</span> indexPathsForRowsInRect:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, targetContentOffset-&gt;y, <span class=\"keyword\">self</span>.width, <span class=\"keyword\">self</span>.height)];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *arr = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:temp];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  velocity.y0 上拉</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (velocity.y&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indexPath.row+<span class=\"number\">33</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                [arr addObject:[<span class=\"built_in\">NSIndexPath</span> indexPathForRow:indexPath.row<span class=\"number\">-3</span> inSection:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">                [arr addObject:[<span class=\"built_in\">NSIndexPath</span> indexPathForRow:indexPath.row<span class=\"number\">-2</span> inSection:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">                [arr addObject:[<span class=\"built_in\">NSIndexPath</span> indexPathForRow:indexPath.row<span class=\"number\">-1</span> inSection:<span class=\"number\">0</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [needLoadArr addObjectsFromArray:arr];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 UITableView 开始绘制 Cell 的时候，若是 indexpath 包含在按需绘制的 needLoadArr 数组里面，那么就异步绘制该 Cell ，如果没有则跳过该 Cell 。</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     VVeboTableViewCell *<span class=\"keyword\">cell</span> = [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">\"cell\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">cell</span>==nil) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">cell</span> = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault</span><br><span class=\"line\"></span><br><span class=\"line\">                                          reuseIdentifier:@<span class=\"string\">\"cell\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 绘制 Cell</span></span><br><span class=\"line\">     [self drawCell:<span class=\"keyword\">cell</span> withIndexPath:indexPath];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">cell</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 按需绘制 Cell</span></span><br><span class=\"line\"> - (<span class=\"keyword\">void</span>)drawCell:(VVeboTableViewCell *)<span class=\"keyword\">cell</span> withIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     NSDictionary *data = [datas objectAtIndex:indexPath<span class=\"variable\">.row</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">cell</span><span class=\"variable\">.selectionStyle</span> = UITableViewCellSelectionStyleNone;</span><br><span class=\"line\"></span><br><span class=\"line\">     [<span class=\"keyword\">cell</span> clear];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">cell</span><span class=\"variable\">.data</span> = data;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 按需绘制，只要在 needLoadArr 里面的 indexPath 才需要绘制 Cell</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (needLoadArr<span class=\"variable\">.count</span>&gt;<span class=\"number\">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==NSNotFound) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         [<span class=\"keyword\">cell</span> clear];</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (scrollToToping) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     [<span class=\"keyword\">cell</span> draw];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这篇博客文章主要是学习 VVebo 的 UITableView 优化技巧，VVebo 的作者将 VVeboTableViewDemo开源在 GitHub，大家可以查阅代码，感谢作者。这个方案也有存在一个不足，在 TableView 快速滑动的时候，页面会出现空白。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://www.jianshu.com/p/2d077da3af94\" target=\"_blank\" rel=\"noopener\">UITableView优化</a></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">UITableView的优化进阶篇</a><br><a href=\"https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">APP的优化</a></p>\n<hr>\n<p>UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。</p>\n<p>那么优化就势在必得。。。</p>\n<h2 id=\"在优化之前\"><a href=\"#在优化之前\" class=\"headerlink\" title=\"在优化之前\"></a>在优化之前</h2><h3 id=\"异步渲染内容到图片\"><a href=\"#异步渲染内容到图片\" class=\"headerlink\" title=\"异步渲染内容到图片\"></a>异步渲染内容到图片</h3><p>这是一张典型的微博页面，这个页面若是采用普通的 View 控件拼凑的话，会需要多少个控件呢？我们这里简单划分一下。粗略划分了一下，我们大概需要 13 个 view 才能完成。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-ea7cbf59b7b44594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>对 TableView 的优化有时候可以直接考虑对 TableViewCell 的优化。对于复杂 View 的优化，首先考虑减少 View 的布局层级。我们将这个复杂的问题简单化，我们把 TableViewCell 按下图所示分割成三个部分，分别用红色，绿色，蓝色区分开来。 通过和实际的页面对比，我们可以看到红色部分的名字，日期，来源以及蓝色部分相对来说比较简单，布局变化比较小，所以我们可以考虑将这些内容全部绘制到一张图片上，来达到减少 View 的布局层级的目的。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-bda7883871b7e11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>我们排除其他干扰控件，使用 Xcode 来查看 TableViewCell 的布局层次，可以清晰的看到红色部分的名字，日期，来源以及整个蓝色蓝色部分都是直接绘制在图片上，图片使用一个 UIImageView 来承载。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-9ee28421b61fc161.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 CoreText 绘制</span></span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">    CGRect <span class=\"built_in\">rect</span> = [_data[@<span class=\"string\">\"frame\"</span>] CGRectValue];</span><br><span class=\"line\">    UIGraphicsBeginImageContextWithOptions(<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>, YES, <span class=\"number\">0</span>);</span><br><span class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class=\"line\">    <span class=\"comment\">// 最外层的大框</span></span><br><span class=\"line\">    <span class=\"comment\">// [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];     </span></span><br><span class=\"line\">    [[UIColor redColor] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">    CGContextFillRect(context, <span class=\"built_in\">rect</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([_data valueForKey:@<span class=\"string\">\"subData\"</span>]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第二层框</span></span><br><span class=\"line\">        <span class=\"comment\">// [[UIColor colorWithRed:243/255.0 green:243/255.0 blue:243/255.0 alpha:1] set];</span></span><br><span class=\"line\">        [[UIColor greenColor] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">        CGRect subFrame = [_data[@<span class=\"string\">\"subData\"</span>][@<span class=\"string\">\"frame\"</span>] CGRectValue];</span><br><span class=\"line\">        CGContextFillRect(context, subFrame);</span><br><span class=\"line\">        <span class=\"comment\">// 线</span></span><br><span class=\"line\">        [[UIColor colorWithRed:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">        CGContextFillRect(context, CGRectMake(<span class=\"number\">0</span>, subFrame.origin.y, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>, <span class=\"number\">0.5</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 名字</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> x = leftX;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class=\"number\">6</span>))/<span class=\"number\">2</span><span class=\"number\">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class=\"number\">-5</span>;</span><br><span class=\"line\">        [_data[@<span class=\"string\">\"name\"</span>] drawInContext:context withPosition:CGPointMake(x, y) andFont:FontWithSize(SIZE_FONT_NAME) andTextColor:[UIColor colorWithRed:<span class=\"number\">106</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">140</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">181</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">        y += SIZE_FONT_NAME+<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> fromX = leftX;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> <span class=\"built_in\">size</span> = [UIScreen screenWidth]-leftX;</span><br><span class=\"line\">        <span class=\"comment\">// 时间和来源</span></span><br><span class=\"line\">        NSString *from = [NSString stringWithFormat:@<span class=\"string\">\"%@  %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]];</span><br><span class=\"line\">        NSString *from = [NSString stringWithFormat:@<span class=\"string\">\"%@ %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]]; [from drawInContext:context withPosition:CGPointMake(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span> andWidth:<span class=\"built_in\">size</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        CGRect countRect = CGRectMake(<span class=\"number\">0</span>, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span><span class=\"number\">-30</span>, [UIScreen screenWidth], <span class=\"number\">30</span>);</span><br><span class=\"line\">        <span class=\"comment\">// [[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1] set];</span></span><br><span class=\"line\">        [[UIColor blueColor] <span class=\"built_in\">set</span>];</span><br><span class=\"line\">        CGContextFillRect(context, countRect);</span><br><span class=\"line\">        <span class=\"built_in\">float</span> <span class=\"built_in\">alpha</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 评论</span></span><br><span class=\"line\">        <span class=\"built_in\">float</span> x = [UIScreen screenWidth]-SIZE_GAP_LEFT<span class=\"number\">-10</span>;</span><br><span class=\"line\">        NSString *comments = _data[@<span class=\"string\">\"comments\"</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comments) &#123;</span><br><span class=\"line\">            CGSize <span class=\"built_in\">size</span> = [comments sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class=\"number\">5</span>];</span><br><span class=\"line\">            x -= <span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>;</span><br><span class=\"line\">            [comments drawInContext:context withPosition:CGPointMake(x, <span class=\"number\">8</span>+countRect.origin.y) andFont:FontWithSize(<span class=\"number\">12</span>) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">            <span class=\"comment\">// 图片画到 context</span></span><br><span class=\"line\">            [[UIImage imageNamed:@<span class=\"string\">\"t_comments.png\"</span>] drawInRect:CGRectMake(x<span class=\"number\">-5</span>, <span class=\"number\">10.5</span>+countRect.origin.y, <span class=\"number\">10</span>, <span class=\"number\">9</span>) <span class=\"built_in\">blendMode</span>:kCGBlendModeNormal <span class=\"built_in\">alpha</span>:<span class=\"built_in\">alpha</span>]; commentsRect = CGRectMake(x<span class=\"number\">-5</span>, self.<span class=\"built_in\">height</span><span class=\"number\">-50</span>, [UIScreen screenWidth]-x+<span class=\"number\">5</span>, <span class=\"number\">50</span>); x -= <span class=\"number\">20</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"comment\">// 转发</span></span><br><span class=\"line\">         NSString *reposts = _data[@<span class=\"string\">\"reposts\"</span>];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (reposts) &#123;</span><br><span class=\"line\">             CGSize <span class=\"built_in\">size</span> = [reposts sizeWithConstrainedToSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class=\"number\">5</span>];</span><br><span class=\"line\">             x -= MAX(<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>, <span class=\"number\">5</span>)+SIZE_GAP_BIG;</span><br><span class=\"line\">             [reposts drawInContext:context withPosition:CGPointMake(x, <span class=\"number\">8</span>+countRect.origin.y) andFont:FontWithSize(<span class=\"number\">12</span>) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">             [[UIImage imageNamed:@<span class=\"string\">\"t_repost.png\"</span>] drawInRect:CGRectMake(x<span class=\"number\">-5</span>, <span class=\"number\">11</span>+countRect.origin.y, <span class=\"number\">10</span>, <span class=\"number\">9</span>) <span class=\"built_in\">blendMode</span>:kCGBlendModeNormal <span class=\"built_in\">alpha</span>:<span class=\"built_in\">alpha</span>]; repostsRect = CGRectMake(x<span class=\"number\">-5</span>, self.<span class=\"built_in\">height</span><span class=\"number\">-50</span>, commentsRect.origin.x-x, <span class=\"number\">50</span>); </span><br><span class=\"line\">             x -= <span class=\"number\">20</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"comment\">// ...</span></span><br><span class=\"line\">         [@<span class=\"string\">\"•••\"</span> drawInContext:context withPosition:CGPointMake(SIZE_GAP_LEFT, <span class=\"number\">8</span>+countRect.origin.y) andFont:FontWithSize(<span class=\"number\">11</span>) andTextColor:[UIColor colorWithRed:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">.5</span>] andHeight:<span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> ([_data valueForKey:@<span class=\"string\">\"subData\"</span>]) &#123; </span><br><span class=\"line\">             <span class=\"comment\">// 线 </span></span><br><span class=\"line\">             [[UIColor colorWithRed:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">green</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">blue</span>:<span class=\"number\">200</span>/<span class=\"number\">255.0</span> <span class=\"built_in\">alpha</span>:<span class=\"number\">1</span>] <span class=\"built_in\">set</span>]; CGContextFillRect(context, CGRectMake(<span class=\"number\">0</span>, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span><span class=\"number\">-30.5</span>, <span class=\"built_in\">rect</span>.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>, <span class=\"number\">.5</span>));</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 获取绘制的图片，然后切换到主线程设置图片</span></span><br><span class=\"line\">     UIImage *temp = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class=\"line\">     UIGraphicsEndImageContext();</span><br><span class=\"line\">     dispatch_async(dispatch_get_main_queue(), ^&#123; </span><br><span class=\"line\">         <span class=\"keyword\">if</span> (flag==drawColorFlag) &#123; </span><br><span class=\"line\">              postBGView.frame = <span class=\"built_in\">rect</span>; </span><br><span class=\"line\">              postBGView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">              postBGView.<span class=\"built_in\">image</span> = temp; </span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">     &#125;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在上面代码中，除了做到减少 View 的布局层级之外还使用了一个非常重要技术-异步渲染内容到图片。使用 dispatch_async 将绘制工作放到后台操作，减少主线程的计算工作量</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_global_queue</span>(<span class=\"name\">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class=\"number\">0</span>), ^&#123;&#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>使用 CGContextFillRect 用于填充 View 的背景颜色。</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  <span class=\"comment\">[<span class=\"comment\">[UIColor colorWithRed:250/255.0 green:250/255.0 blue:250/255.0 alpha:1]</span> set]</span>;</span><br><span class=\"line\"><span class=\"comment\">[<span class=\"comment\">[UIColor redColor]</span> set]</span>;</span><br><span class=\"line\">CGContextFillRect(context, rect);</span><br></pre></td></tr></table></figure>\n<p>利用 CoreText 来做文本排版，具体的 CoreText 实现细节可以参考 Demo 代码</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 名字</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> x = leftX;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class=\"number\">6</span>))/<span class=\"number\">2</span><span class=\"number\">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class=\"number\">-5</span>;</span><br><span class=\"line\">        [_data[@<span class=\"string\">\"name\"</span>] <span class=\"string\">drawInContext:</span>context <span class=\"string\">withPosition:</span>CGPointMake(x, y) <span class=\"string\">andFont:</span>FontWithSize(SIZE_FONT_NAME) <span class=\"string\">andTextColor:</span>[UIColor <span class=\"string\">colorWithRed:</span><span class=\"number\">106</span><span class=\"regexp\">/255.0 green:140/</span><span class=\"number\">255.0</span> <span class=\"string\">blue:</span><span class=\"number\">181</span>/<span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1</span>] <span class=\"string\">andHeight:</span>rect.size.height];</span><br><span class=\"line\">        y += SIZE_FONT_NAME+<span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> fromX = leftX;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> size = [UIScreen screenWidth]-leftX;</span><br><span class=\"line\">        <span class=\"comment\">// 时间和来源</span></span><br><span class=\"line\">        NSString *from = [NSString <span class=\"string\">stringWithFormat:</span>@<span class=\"string\">\"%@  %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]];</span><br><span class=\"line\">        NSString *from = [NSString <span class=\"string\">stringWithFormat:</span>@<span class=\"string\">\"%@ %@\"</span>, _data[@<span class=\"string\">\"time\"</span>], _data[@<span class=\"string\">\"from\"</span>]]; [from <span class=\"string\">drawInContext:</span>context <span class=\"string\">withPosition:</span>CGPointMake(fromX, y) <span class=\"string\">andFont:</span>FontWithSize(SIZE_FONT_SUBTITLE) <span class=\"string\">andTextColor:</span>[UIColor <span class=\"string\">colorWithRed:</span><span class=\"number\">178</span><span class=\"regexp\">/255.0 green:178/</span><span class=\"number\">255.0</span> <span class=\"string\">blue:</span><span class=\"number\">178</span>/<span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1</span>] <span class=\"string\">andHeight:</span>rect.size.height <span class=\"string\">andWidth:</span>size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>异步生成图片之后切换到主线程设置图片</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), ^&#123; </span><br><span class=\"line\">         if (<span class=\"name\">flag==drawColorFlag</span>) &#123; </span><br><span class=\"line\">              postBGView.frame = rect<span class=\"comment\">; </span></span><br><span class=\"line\">              postBGView.image = <span class=\"literal\">nil</span><span class=\"comment\">; </span></span><br><span class=\"line\">              postBGView.image = temp<span class=\"comment\">; </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\"> &#125;)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>处理好了减少 View 布局层级和异步绘制之后，我们还需要处理一个圆角头像的问题。圆角头像最简单的处理方法就是使用一张圆形镂空的图片来实现，不过这个实现方案有个缺陷就是对 View 的背景颜色有要求。这里采用的处理方案就是这个最简单的处理方法。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-6a2080dcdb710dce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520\" alt=\"\"></p>\n<p>处理好了背景问题，接下来时候看看微博正文的问题了。微博的正文放在 label 控件里面，而转发的微博详情内容放在 detailLabel 里面。这个 label 是自定义控件 VVeboLabel，里面的 - (void)setText:(NSString *)text 方法具体的实现方式也是采用 CoreText 异步绘制实现的。</p>\n<figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//设置文本内容，将文本内容设置在单独的 <span class=\"symbol\">View</span> 上面</span><br><span class=\"line\">- (void)drawText&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   if (label==nil||detailLabel==nil) &#123;</span><br><span class=\"line\">        [self addLabel];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   label.frame = [<span class=\"symbol\">_data</span>[@<span class=\"string\">\"textRect\"</span>] <span class=\"symbol\">CGRectValue</span>];</span><br><span class=\"line\">   [label setText:<span class=\"symbol\">_data</span>[@<span class=\"string\">\"text\"</span>]];</span><br><span class=\"line\">   if ([<span class=\"symbol\">_data</span> valueForKey:@<span class=\"string\">\"subData\"</span>]) &#123; </span><br><span class=\"line\">      detailLabel.frame = [[<span class=\"symbol\">_data</span> valueForKey:@<span class=\"string\">\"subData\"</span>][@<span class=\"string\">\"textRect\"</span>] <span class=\"symbol\">CGRectValue</span>]; </span><br><span class=\"line\">      [detailLabel setText:[<span class=\"symbol\">_data</span> valueForKey:@<span class=\"string\">\"subData\"</span>][@<span class=\"string\">\"text\"</span>]];</span><br><span class=\"line\">      detailLabel.hidden = <span class=\"symbol\">NO</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-b5dd6c1ccbe395a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<p>可能你会问了，使用 CoreText 异步绘制的文本内容如何设置监听事件呢？CoreText 又如何处理点击高亮问题呢？我们通过 - (void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event 方法来获取用户的点击位置。将获取到的用户点击位置与事先保存文本位置比较，若是用户点击位置位于文本区域内，那么说明用户点击了文本。为了能够做出高亮效果，VVeboLabel 控件内部必须维护一个字段 highlighting 和一个用于显示高亮文本图片的 highlightImageView，当 highlighting == YES 的时候，异步绘制高亮文本内容生成图片并使用 highlightImageView 显示该图片，用于表示控件的高亮状态。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span> *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"built_in\">CGPoint</span> location = [[touches anyObject] locationInView:<span class=\"keyword\">self</span>]; </span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *key <span class=\"keyword\">in</span> framesDict.allKeys) &#123; </span><br><span class=\"line\">          <span class=\"built_in\">CGRect</span> frame = [[framesDict valueForKey:key] <span class=\"built_in\">CGRectValue</span>]; </span><br><span class=\"line\">          <span class=\"comment\">// 将获取到的用户点击位置与事先保存文本位置比较 </span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">CGRectContainsPoint</span>(frame, location)) &#123; </span><br><span class=\"line\">               <span class=\"built_in\">NSRange</span> range = <span class=\"built_in\">NSRangeFromString</span>(key); </span><br><span class=\"line\">               range = <span class=\"built_in\">NSMakeRange</span>(range.location, range.length<span class=\"number\">-1</span>); </span><br><span class=\"line\">               currentRange = range; </span><br><span class=\"line\">               [<span class=\"keyword\">self</span> highlightWord]; </span><br><span class=\"line\">               <span class=\"comment\">// *** 省略代码 </span></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  VVeboLabel.m</span></span><br><span class=\"line\"><span class=\"comment\">// ... 省略代码</span></span><br><span class=\"line\"><span class=\"built_in\">if</span> (highlighting) &#123; </span><br><span class=\"line\">   <span class=\"built_in\">if</span> (highlighting) &#123; </span><br><span class=\"line\">      highlightImageView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">      <span class=\"built_in\">if</span> (highlightImageView.<span class=\"built_in\">width</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>) &#123; </span><br><span class=\"line\">          highlightImageView.<span class=\"built_in\">width</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"built_in\">if</span> (highlightImageView.<span class=\"built_in\">height</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>) &#123; </span><br><span class=\"line\">          highlightImageView.<span class=\"built_in\">height</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      highlightImageView.<span class=\"built_in\">image</span> = screenShotimage; </span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   </span><br><span class=\"line\">&#125; <span class=\"built_in\">else</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">if</span> ([temp isEqualToString:<span class=\"built_in\">text</span>]) &#123; </span><br><span class=\"line\">     <span class=\"built_in\">if</span> (labelImageView.<span class=\"built_in\">width</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>) &#123; </span><br><span class=\"line\">        labelImageView.<span class=\"built_in\">width</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">width</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"built_in\">if</span> (labelImageView.<span class=\"built_in\">height</span>!=screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>) &#123; </span><br><span class=\"line\">        labelImageView.<span class=\"built_in\">height</span> = screenShotimage.<span class=\"built_in\">size</span>.<span class=\"built_in\">height</span>; </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     highlightImageView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">     labelImageView.<span class=\"built_in\">image</span> = nil; </span><br><span class=\"line\">     labelImageView.<span class=\"built_in\">image</span> = screenShotimage;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// ... 省略代码</span></span><br></pre></td></tr></table></figure>\n<p>VVeboLabel 控件处理高亮情况的 View 结构层次如下图。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/656644-45d5d9f65a4b8da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"\"></p>\n<h2 id=\"按需加载内容\"><a href=\"#按需加载内容\" class=\"headerlink\" title=\"按需加载内容\"></a>按需加载内容</h2><p>UITableView 的优化除了在 UITableViewCell 的绘制方面优化之后，还可以在加载数据方面优化，按需加载内容，避免加载暂时无用的数据，从而减少数据量，减少 UITableView 的绘制工作量,达到优化的目的</p>\n<p>判断按需加载的 indexPaths , 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。这样可以减少 UITableView 的绘制工作量</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *ip = [<span class=\"keyword\">self</span> indexPathForRowAtPoint:<span class=\"built_in\">CGPointMake</span>(<span class=\"number\">0</span>, targetContentOffset-&gt;y)];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSIndexPath</span> *cip = [[<span class=\"keyword\">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> skipCount = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 目标行与当前行相差超过指定行数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 目标位置的行</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSArray</span> *temp = [<span class=\"keyword\">self</span> indexPathsForRowsInRect:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, targetContentOffset-&gt;y, <span class=\"keyword\">self</span>.width, <span class=\"keyword\">self</span>.height)];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *arr = [<span class=\"built_in\">NSMutableArray</span> arrayWithArray:temp];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  velocity.y0 上拉</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (velocity.y&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indexPath.row+<span class=\"number\">33</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                [arr addObject:[<span class=\"built_in\">NSIndexPath</span> indexPathForRow:indexPath.row<span class=\"number\">-3</span> inSection:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">                [arr addObject:[<span class=\"built_in\">NSIndexPath</span> indexPathForRow:indexPath.row<span class=\"number\">-2</span> inSection:<span class=\"number\">0</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\">                [arr addObject:[<span class=\"built_in\">NSIndexPath</span> indexPathForRow:indexPath.row<span class=\"number\">-1</span> inSection:<span class=\"number\">0</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [needLoadArr addObjectsFromArray:arr];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 UITableView 开始绘制 Cell 的时候，若是 indexpath 包含在按需绘制的 needLoadArr 数组里面，那么就异步绘制该 Cell ，如果没有则跳过该 Cell 。</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     VVeboTableViewCell *<span class=\"keyword\">cell</span> = [tableView dequeueReusableCellWithIdentifier:@<span class=\"string\">\"cell\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (<span class=\"keyword\">cell</span>==nil) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">cell</span> = [[VVeboTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault</span><br><span class=\"line\"></span><br><span class=\"line\">                                          reuseIdentifier:@<span class=\"string\">\"cell\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 绘制 Cell</span></span><br><span class=\"line\">     [self drawCell:<span class=\"keyword\">cell</span> withIndexPath:indexPath];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">cell</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 按需绘制 Cell</span></span><br><span class=\"line\"> - (<span class=\"keyword\">void</span>)drawCell:(VVeboTableViewCell *)<span class=\"keyword\">cell</span> withIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     NSDictionary *data = [datas objectAtIndex:indexPath<span class=\"variable\">.row</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">cell</span><span class=\"variable\">.selectionStyle</span> = UITableViewCellSelectionStyleNone;</span><br><span class=\"line\"></span><br><span class=\"line\">     [<span class=\"keyword\">cell</span> clear];</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">cell</span><span class=\"variable\">.data</span> = data;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 按需绘制，只要在 needLoadArr 里面的 indexPath 才需要绘制 Cell</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (needLoadArr<span class=\"variable\">.count</span>&gt;<span class=\"number\">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==NSNotFound) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         [<span class=\"keyword\">cell</span> clear];</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (scrollToToping) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     [<span class=\"keyword\">cell</span> draw];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这篇博客文章主要是学习 VVebo 的 UITableView 优化技巧，VVebo 的作者将 VVeboTableViewDemo开源在 GitHub，大家可以查阅代码，感谢作者。这个方案也有存在一个不足，在 TableView 快速滑动的时候，页面会出现空白。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://www.jianshu.com/p/2d077da3af94\" target=\"_blank\" rel=\"noopener\">UITableView优化</a></p>\n"},{"title":"Runtime之动态添加属性(四)","date":"2017-02-20T11:17:18.000Z","description":"为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。","toc":false,"_content":"\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。\n\n动态添加方法在后面也会单独写一篇博文。\n\n## 给分类添加属性\n\n* 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。\n\n\n对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：\n\n\n```\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n\n参数1：object 是源对象\n\n参数2：value 是被关联的对象\n\n参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象\n\n参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.\n\n```\n/** 这个也可以取消关联 */\nvoid objc_removeAssociatedObjects(id object)\n```\n\n### 应用情景\n\n* 给NSObject类添加一个name属性\n* 给UIButton或UIView添加一个单击事件回调属性\n* 给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性\n\n下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：\n\n创建一个UIButton的分类\n\n在.h文件：\n\n```\n#import <UIKit/UIKit.h>\n\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (block)\n\n/*\n * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的\n * 实现以及带下划线的成员变量.\n * 所以, 在分类中有两种方式声明一个属性\n */\n\n/** 第一种写法 */\n@property (nonatomic,copy) clickBlock click;\n\n/** 第二种写法 */\n//@property clickBlock click;\n\n@end\n```\n在.m文件：\n\n```\n#import \"UIButton+block.h\"\n#import <objc/runtime.h>\n\n/** 定义关联的key */\nstatic const void *clickKey = \"click\";\n\n@implementation UIButton (block)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    \n    /* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联\n     参数1: id object :表示给哪个对象添加关联\n     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名\n     参数3: id value : 属性值\n     参数4: 策略, 是个枚举(点进去,解释很详细)\n     \n     单词Associated 关联\n     */\n    objc_setAssociatedObject(self, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return objc_getAssociatedObject(self, clickKey);\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n\n```\n\n这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性\n\n使用：\n\n```\nUIButton *button = [[UIButton alloc] init];\n    \nbutton.frame = self.view.bounds;\n    \n[self.view addSubview:button];\n    \nbutton.click = ^{\n    \n    NSLog(@\"点击了button\");\n    \n};\n```\n\n## 疑难杂症\n为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的`clickBlockXP _clickXp;`也可以达到相同的效果，为什么不能那样做呢\n\n就像这样：\n\n```\n#import \"UIButton+block.h\"\n\ntypedef void(^clickBlockXP)(void);\n\n/** 定义的全局block */\nclickBlockXP _clickXp;\n\n@implementation UIButton (block)\n\n-(void)setClick:(clickBlock)click{\n    \n    _clickXp = click;\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return _clickXp;\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n```\n\n**不能这样做的原因**：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。\n\n\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n\n[Runtime全方位装逼指南](http://www.cocoachina.com/ios/20160523/16386.html)\n\n[runtime简单使用之动态添加属性](https://www.jianshu.com/p/e52c17db0aa9)","source":"_posts/Runtime之动态添加属性.md","raw":"---\ntitle: Runtime之动态添加属性(四)\ndate: 2017-02-20 19:17:18\n\ndescription: 为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。\n\ncategories: Runtime\ntags: [Objective-C,Runtime]\ntoc: false \n---\n\n***\n[Runtime--Runtime的数据结构(一)](https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[Runtime--类对象与元类对象(二)](https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/)\n[Runtime和消息转发(三)](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n[Runtime之动态添加属性(四)](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n[Runtime之动态添加方法(五)](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n***\n\n为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。\n\n动态添加方法在后面也会单独写一篇博文。\n\n## 给分类添加属性\n\n* 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。\n\n\n对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：\n\n\n```\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n\n参数1：object 是源对象\n\n参数2：value 是被关联的对象\n\n参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象\n\n参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.\n\n```\n/** 这个也可以取消关联 */\nvoid objc_removeAssociatedObjects(id object)\n```\n\n### 应用情景\n\n* 给NSObject类添加一个name属性\n* 给UIButton或UIView添加一个单击事件回调属性\n* 给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性\n\n下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：\n\n创建一个UIButton的分类\n\n在.h文件：\n\n```\n#import <UIKit/UIKit.h>\n\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (block)\n\n/*\n * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的\n * 实现以及带下划线的成员变量.\n * 所以, 在分类中有两种方式声明一个属性\n */\n\n/** 第一种写法 */\n@property (nonatomic,copy) clickBlock click;\n\n/** 第二种写法 */\n//@property clickBlock click;\n\n@end\n```\n在.m文件：\n\n```\n#import \"UIButton+block.h\"\n#import <objc/runtime.h>\n\n/** 定义关联的key */\nstatic const void *clickKey = \"click\";\n\n@implementation UIButton (block)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    \n    /* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联\n     参数1: id object :表示给哪个对象添加关联\n     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名\n     参数3: id value : 属性值\n     参数4: 策略, 是个枚举(点进去,解释很详细)\n     \n     单词Associated 关联\n     */\n    objc_setAssociatedObject(self, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return objc_getAssociatedObject(self, clickKey);\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n\n```\n\n这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性\n\n使用：\n\n```\nUIButton *button = [[UIButton alloc] init];\n    \nbutton.frame = self.view.bounds;\n    \n[self.view addSubview:button];\n    \nbutton.click = ^{\n    \n    NSLog(@\"点击了button\");\n    \n};\n```\n\n## 疑难杂症\n为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的`clickBlockXP _clickXp;`也可以达到相同的效果，为什么不能那样做呢\n\n就像这样：\n\n```\n#import \"UIButton+block.h\"\n\ntypedef void(^clickBlockXP)(void);\n\n/** 定义的全局block */\nclickBlockXP _clickXp;\n\n@implementation UIButton (block)\n\n-(void)setClick:(clickBlock)click{\n    \n    _clickXp = click;\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return _clickXp;\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n```\n\n**不能这样做的原因**：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。\n\n\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n\n[Runtime全方位装逼指南](http://www.cocoachina.com/ios/20160523/16386.html)\n\n[runtime简单使用之动态添加属性](https://www.jianshu.com/p/e52c17db0aa9)","slug":"Runtime之动态添加属性","published":1,"updated":"2018-09-11T08:38:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fno001866r204rec30r","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<p>为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。</p>\n<p>动态添加方法在后面也会单独写一篇博文。</p>\n<h2 id=\"给分类添加属性\"><a href=\"#给分类添加属性\" class=\"headerlink\" title=\"给分类添加属性\"></a>给分类添加属性</h2><ul>\n<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>\n</ul>\n<p>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">OBJC_EXPORT <span class=\"keyword\">void</span> <span class=\"title\">objc_setAssociatedObject</span>(<span class=\"params\">id <span class=\"keyword\">object</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, id <span class=\"keyword\">value</span>, objc_AssociationPolicy policy</span>) __<span class=\"title\">OSX_AVAILABLE_STARTING</span>(<span class=\"params\">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>参数1：object 是源对象</p>\n<p>参数2：value 是被关联的对象</p>\n<p>参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象</p>\n<p>参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义</p>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个也可以取消关联 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc<span class=\"number\">_</span>removeAssociatedObjects(id <span class=\"keyword\">object</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"应用情景\"><a href=\"#应用情景\" class=\"headerlink\" title=\"应用情景\"></a>应用情景</h3><ul>\n<li>给NSObject类添加一个name属性</li>\n<li>给UIButton或UIView添加一个单击事件回调属性</li>\n<li>给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性</li>\n</ul>\n<p>下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：</p>\n<p>创建一个UIButton的分类</p>\n<p>在.h文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现以及带下划线的成员变量.</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以, 在分类中有两种方式声明一个属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第一种写法 */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第二种写法 */</span></span><br><span class=\"line\"><span class=\"comment\">//@property clickBlock click;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在.m文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义关联的key */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *clickKey = <span class=\"string\">\"click\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数1: id object :表示给哪个对象添加关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     参数3: id value : 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     参数4: 策略, 是个枚举(点进去,解释很详细)</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     单词Associated 关联</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, clickKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性</p>\n<p>使用：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *<span class=\"keyword\">button </span>= [[UIButton alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">button.frame </span>= self.view.<span class=\"keyword\">bounds;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\">[self.view <span class=\"keyword\">addSubview:button];</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\"><span class=\"keyword\">button.click </span>= ^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"点击了button\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><p>为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的<code>clickBlockXP _clickXp;</code>也可以达到相同的效果，为什么不能那样做呢</p>\n<p>就像这样：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlockXP)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义的全局block */</span></span><br><span class=\"line\">clickBlockXP _clickXp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _clickXp = click;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _clickXp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不能这样做的原因</strong>：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20160523/16386.html\" target=\"_blank\" rel=\"noopener\">Runtime全方位装逼指南</a></p>\n<p><a href=\"https://www.jianshu.com/p/e52c17db0aa9\" target=\"_blank\" rel=\"noopener\">runtime简单使用之动态添加属性</a></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/05/03/Runtime--Runtime%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">Runtime–Runtime的数据结构(一)</a><br><a href=\"https://xiaopengmonsters.github.io/2018/05/13/Runtime--%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%83%E7%B1%BB%E5%AF%B9%E8%B1%A1/\" target=\"_blank\" rel=\"noopener\">Runtime–类对象与元类对象(二)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发(三)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性(四)</a><br><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法(五)</a></p>\n<hr>\n<p>为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。</p>\n<p>动态添加方法在后面也会单独写一篇博文。</p>\n<h2 id=\"给分类添加属性\"><a href=\"#给分类添加属性\" class=\"headerlink\" title=\"给分类添加属性\"></a>给分类添加属性</h2><ul>\n<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>\n</ul>\n<p>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">OBJC_EXPORT <span class=\"keyword\">void</span> <span class=\"title\">objc_setAssociatedObject</span>(<span class=\"params\">id <span class=\"keyword\">object</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, id <span class=\"keyword\">value</span>, objc_AssociationPolicy policy</span>) __<span class=\"title\">OSX_AVAILABLE_STARTING</span>(<span class=\"params\">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>参数1：object 是源对象</p>\n<p>参数2：value 是被关联的对象</p>\n<p>参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象</p>\n<p>参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义</p>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个也可以取消关联 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc<span class=\"number\">_</span>removeAssociatedObjects(id <span class=\"keyword\">object</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"应用情景\"><a href=\"#应用情景\" class=\"headerlink\" title=\"应用情景\"></a>应用情景</h3><ul>\n<li>给NSObject类添加一个name属性</li>\n<li>给UIButton或UIView添加一个单击事件回调属性</li>\n<li>给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性</li>\n</ul>\n<p>下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：</p>\n<p>创建一个UIButton的分类</p>\n<p>在.h文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现以及带下划线的成员变量.</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以, 在分类中有两种方式声明一个属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第一种写法 */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第二种写法 */</span></span><br><span class=\"line\"><span class=\"comment\">//@property clickBlock click;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在.m文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义关联的key */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *clickKey = <span class=\"string\">\"click\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数1: id object :表示给哪个对象添加关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     参数3: id value : 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     参数4: 策略, 是个枚举(点进去,解释很详细)</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     单词Associated 关联</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, clickKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性</p>\n<p>使用：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *<span class=\"keyword\">button </span>= [[UIButton alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">button.frame </span>= self.view.<span class=\"keyword\">bounds;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\">[self.view <span class=\"keyword\">addSubview:button];</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\"><span class=\"keyword\">button.click </span>= ^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"点击了button\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><p>为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的<code>clickBlockXP _clickXp;</code>也可以达到相同的效果，为什么不能那样做呢</p>\n<p>就像这样：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlockXP)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义的全局block */</span></span><br><span class=\"line\">clickBlockXP _clickXp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _clickXp = click;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _clickXp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不能这样做的原因</strong>：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20160523/16386.html\" target=\"_blank\" rel=\"noopener\">Runtime全方位装逼指南</a></p>\n<p><a href=\"https://www.jianshu.com/p/e52c17db0aa9\" target=\"_blank\" rel=\"noopener\">runtime简单使用之动态添加属性</a></p>\n"},{"title":"Hello World","date":"2016-12-01T08:23:08.000Z","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","toc":true,"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-12-01 16:23:08\n\ndescription: Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\ncategories: [iOS]\ntags: [Objective-C,Swift]\ntoc: true \n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnq001b66r284q2getl","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"UI视图--图像显示原理与卡顿&掉帧","date":"2018-04-05T06:22:09.000Z","description":"图像显示原理与卡顿&掉帧","_content":"\n***\n[UI视图--图像显示原理与卡顿&掉帧](http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&%E6%8E%89%E5%B8%A7/)\n[UI视图--UI绘制原理&异步绘制](http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/)\n[UI视图--离屏渲染](http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/)\n***\n\n## 图像显示原理\n\n![](/img/图像显示原理.png)\n\n1. CPU和GPU两个硬件是通过总线链接起来的\n2. 在CPU中输出的结果是位图，经由总线在合适的时机上传给GPU\n3. GPU拿到位图之后，会做相应位图的图层渲染，包括文理的合成\n4. 之后会把结果放到帧缓冲区（Frame Buffer）当中\n5. 由视频控制器根据VSync信号在指定时间之前去提取在帧缓存区当中的显示内容，最终显示到手机屏幕上\n\n\n## UIView的显示过程\n\n![](/img/UIView的显示过程.png)\n\n1. 当创建一个UIView控件之后，显示部分是由 [CALayer](https://xiaopengmonsters.github.io/2016/12/18/CAlayer/) 来负责的\n2. CALayer当中有一个contents属性，就是我们最终要绘制到屏幕上的位图\n3. 比如说我们创建的是一个UILable，contents里面最终放置的结果就是关于hello word的文字位图\n4. 然后系统会在合适的时机回调一个drawRect：方法，在此基础上可以绘制一些自定义想要绘制的内容\n5. 绘制好的位图，最终会由Core Animation框架提交给GPU部分的OpenGL（ES）渲染管线进行最终的位图的渲染，包括文理的合成，然后显示到屏幕上面\n\n\n## UI卡顿&掉帧原因\n\n![](/img/UI卡顿&掉帧原因.png)\n\n\n一般60fps为流畅：每一秒钟会有60帧的画面更新\n\n那么每隔 16.7ms（1/60）就要产生一帧画面，那么在这 16.7 毫秒之内，需要 CPU 和 GPU 共同完成产生一帧数据\n\n比如 CPU 花费一定的时间做文本的布局，UI计算，包括一些视图的绘制，以及图片解码，然后把最终产生的位图提交给 GPU，再由 GPU 进行相应的图层的合成，文理渲染，然后准备好下一帧画面，再下一帧 VSync 信号到来的时候就可以显示画面\n\n那假如说 CPU 在做文本布局，UI计算，视图绘制，以及图片解码等工作时长太长的话 ，那么留给 GPU 的时间就非常少，那 GPU 要想把图层的合成，文理渲染全部准备完毕，可能就要总时间超过了 16.7ms，那这样的话在下一帧 VSync 的信号到来的时候，我们没有准备好这一帧当下的画面，那就由此产生了掉帧，我们看到的效果就是滑动卡顿\n\n总之，就是在规定的 16.7ms 之内，在下一帧 VSync 信号到来之前，CPU 和 GPU 并没有共同完成下一帧画面的合成，于是就会导致卡顿或者说掉帧\n\n\n#### 滑动优化方案\n\nCPU\n\n* 对象创建、调整、销毁（可以放在子线程）\n* 预排版（布局计算，文本计算）\n* 预渲染（文本等异步绘制，图片编码等）\n\nGPU\n\n* 纹理渲染（避免离屏渲染、CPU异步绘制机制减轻GPU压力）\n* 视图混合（减轻层级复杂度）","source":"_posts/UI视图--图像显示原理与卡顿&掉帧.md","raw":"---\ntitle: UI视图--图像显示原理与卡顿&掉帧\ndate: 2018-04-05 14:22:09\ndescription: 图像显示原理与卡顿&掉帧\ncategories: UI视图\ntags: [Objective-C]\n---\n\n***\n[UI视图--图像显示原理与卡顿&掉帧](http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&%E6%8E%89%E5%B8%A7/)\n[UI视图--UI绘制原理&异步绘制](http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/)\n[UI视图--离屏渲染](http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/)\n***\n\n## 图像显示原理\n\n![](/img/图像显示原理.png)\n\n1. CPU和GPU两个硬件是通过总线链接起来的\n2. 在CPU中输出的结果是位图，经由总线在合适的时机上传给GPU\n3. GPU拿到位图之后，会做相应位图的图层渲染，包括文理的合成\n4. 之后会把结果放到帧缓冲区（Frame Buffer）当中\n5. 由视频控制器根据VSync信号在指定时间之前去提取在帧缓存区当中的显示内容，最终显示到手机屏幕上\n\n\n## UIView的显示过程\n\n![](/img/UIView的显示过程.png)\n\n1. 当创建一个UIView控件之后，显示部分是由 [CALayer](https://xiaopengmonsters.github.io/2016/12/18/CAlayer/) 来负责的\n2. CALayer当中有一个contents属性，就是我们最终要绘制到屏幕上的位图\n3. 比如说我们创建的是一个UILable，contents里面最终放置的结果就是关于hello word的文字位图\n4. 然后系统会在合适的时机回调一个drawRect：方法，在此基础上可以绘制一些自定义想要绘制的内容\n5. 绘制好的位图，最终会由Core Animation框架提交给GPU部分的OpenGL（ES）渲染管线进行最终的位图的渲染，包括文理的合成，然后显示到屏幕上面\n\n\n## UI卡顿&掉帧原因\n\n![](/img/UI卡顿&掉帧原因.png)\n\n\n一般60fps为流畅：每一秒钟会有60帧的画面更新\n\n那么每隔 16.7ms（1/60）就要产生一帧画面，那么在这 16.7 毫秒之内，需要 CPU 和 GPU 共同完成产生一帧数据\n\n比如 CPU 花费一定的时间做文本的布局，UI计算，包括一些视图的绘制，以及图片解码，然后把最终产生的位图提交给 GPU，再由 GPU 进行相应的图层的合成，文理渲染，然后准备好下一帧画面，再下一帧 VSync 信号到来的时候就可以显示画面\n\n那假如说 CPU 在做文本布局，UI计算，视图绘制，以及图片解码等工作时长太长的话 ，那么留给 GPU 的时间就非常少，那 GPU 要想把图层的合成，文理渲染全部准备完毕，可能就要总时间超过了 16.7ms，那这样的话在下一帧 VSync 的信号到来的时候，我们没有准备好这一帧当下的画面，那就由此产生了掉帧，我们看到的效果就是滑动卡顿\n\n总之，就是在规定的 16.7ms 之内，在下一帧 VSync 信号到来之前，CPU 和 GPU 并没有共同完成下一帧画面的合成，于是就会导致卡顿或者说掉帧\n\n\n#### 滑动优化方案\n\nCPU\n\n* 对象创建、调整、销毁（可以放在子线程）\n* 预排版（布局计算，文本计算）\n* 预渲染（文本等异步绘制，图片编码等）\n\nGPU\n\n* 纹理渲染（避免离屏渲染、CPU异步绘制机制减轻GPU压力）\n* 视图混合（减轻层级复杂度）","slug":"UI视图--图像显示原理与卡顿&掉帧","published":1,"updated":"2018-08-31T03:47:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6fnr001e66r2erxm1o7j","content":"<hr>\n<p><a href=\"http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&amp;%E6%8E%89%E5%B8%A7/\" target=\"_blank\" rel=\"noopener\">UI视图–图像显示原理与卡顿&amp;掉帧</a><br><a href=\"http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&amp;%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">UI视图–UI绘制原理&amp;异步绘制</a><br><a href=\"http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/\" target=\"_blank\" rel=\"noopener\">UI视图–离屏渲染</a></p>\n<hr>\n<h2 id=\"图像显示原理\"><a href=\"#图像显示原理\" class=\"headerlink\" title=\"图像显示原理\"></a>图像显示原理</h2><p><img src=\"/img/图像显示原理.png\" alt=\"\"></p>\n<ol>\n<li>CPU和GPU两个硬件是通过总线链接起来的</li>\n<li>在CPU中输出的结果是位图，经由总线在合适的时机上传给GPU</li>\n<li>GPU拿到位图之后，会做相应位图的图层渲染，包括文理的合成</li>\n<li>之后会把结果放到帧缓冲区（Frame Buffer）当中</li>\n<li>由视频控制器根据VSync信号在指定时间之前去提取在帧缓存区当中的显示内容，最终显示到手机屏幕上</li>\n</ol>\n<h2 id=\"UIView的显示过程\"><a href=\"#UIView的显示过程\" class=\"headerlink\" title=\"UIView的显示过程\"></a>UIView的显示过程</h2><p><img src=\"/img/UIView的显示过程.png\" alt=\"\"></p>\n<ol>\n<li>当创建一个UIView控件之后，显示部分是由 <a href=\"https://xiaopengmonsters.github.io/2016/12/18/CAlayer/\" target=\"_blank\" rel=\"noopener\">CALayer</a> 来负责的</li>\n<li>CALayer当中有一个contents属性，就是我们最终要绘制到屏幕上的位图</li>\n<li>比如说我们创建的是一个UILable，contents里面最终放置的结果就是关于hello word的文字位图</li>\n<li>然后系统会在合适的时机回调一个drawRect：方法，在此基础上可以绘制一些自定义想要绘制的内容</li>\n<li>绘制好的位图，最终会由Core Animation框架提交给GPU部分的OpenGL（ES）渲染管线进行最终的位图的渲染，包括文理的合成，然后显示到屏幕上面</li>\n</ol>\n<h2 id=\"UI卡顿-amp-掉帧原因\"><a href=\"#UI卡顿-amp-掉帧原因\" class=\"headerlink\" title=\"UI卡顿&amp;掉帧原因\"></a>UI卡顿&amp;掉帧原因</h2><p><img src=\"/img/UI卡顿&amp;掉帧原因.png\" alt=\"\"></p>\n<p>一般60fps为流畅：每一秒钟会有60帧的画面更新</p>\n<p>那么每隔 16.7ms（1/60）就要产生一帧画面，那么在这 16.7 毫秒之内，需要 CPU 和 GPU 共同完成产生一帧数据</p>\n<p>比如 CPU 花费一定的时间做文本的布局，UI计算，包括一些视图的绘制，以及图片解码，然后把最终产生的位图提交给 GPU，再由 GPU 进行相应的图层的合成，文理渲染，然后准备好下一帧画面，再下一帧 VSync 信号到来的时候就可以显示画面</p>\n<p>那假如说 CPU 在做文本布局，UI计算，视图绘制，以及图片解码等工作时长太长的话 ，那么留给 GPU 的时间就非常少，那 GPU 要想把图层的合成，文理渲染全部准备完毕，可能就要总时间超过了 16.7ms，那这样的话在下一帧 VSync 的信号到来的时候，我们没有准备好这一帧当下的画面，那就由此产生了掉帧，我们看到的效果就是滑动卡顿</p>\n<p>总之，就是在规定的 16.7ms 之内，在下一帧 VSync 信号到来之前，CPU 和 GPU 并没有共同完成下一帧画面的合成，于是就会导致卡顿或者说掉帧</p>\n<h4 id=\"滑动优化方案\"><a href=\"#滑动优化方案\" class=\"headerlink\" title=\"滑动优化方案\"></a>滑动优化方案</h4><p>CPU</p>\n<ul>\n<li>对象创建、调整、销毁（可以放在子线程）</li>\n<li>预排版（布局计算，文本计算）</li>\n<li>预渲染（文本等异步绘制，图片编码等）</li>\n</ul>\n<p>GPU</p>\n<ul>\n<li>纹理渲染（避免离屏渲染、CPU异步绘制机制减轻GPU压力）</li>\n<li>视图混合（减轻层级复杂度）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&amp;%E6%8E%89%E5%B8%A7/\" target=\"_blank\" rel=\"noopener\">UI视图–图像显示原理与卡顿&amp;掉帧</a><br><a href=\"http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&amp;%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">UI视图–UI绘制原理&amp;异步绘制</a><br><a href=\"http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/\" target=\"_blank\" rel=\"noopener\">UI视图–离屏渲染</a></p>\n<hr>\n<h2 id=\"图像显示原理\"><a href=\"#图像显示原理\" class=\"headerlink\" title=\"图像显示原理\"></a>图像显示原理</h2><p><img src=\"/img/图像显示原理.png\" alt=\"\"></p>\n<ol>\n<li>CPU和GPU两个硬件是通过总线链接起来的</li>\n<li>在CPU中输出的结果是位图，经由总线在合适的时机上传给GPU</li>\n<li>GPU拿到位图之后，会做相应位图的图层渲染，包括文理的合成</li>\n<li>之后会把结果放到帧缓冲区（Frame Buffer）当中</li>\n<li>由视频控制器根据VSync信号在指定时间之前去提取在帧缓存区当中的显示内容，最终显示到手机屏幕上</li>\n</ol>\n<h2 id=\"UIView的显示过程\"><a href=\"#UIView的显示过程\" class=\"headerlink\" title=\"UIView的显示过程\"></a>UIView的显示过程</h2><p><img src=\"/img/UIView的显示过程.png\" alt=\"\"></p>\n<ol>\n<li>当创建一个UIView控件之后，显示部分是由 <a href=\"https://xiaopengmonsters.github.io/2016/12/18/CAlayer/\" target=\"_blank\" rel=\"noopener\">CALayer</a> 来负责的</li>\n<li>CALayer当中有一个contents属性，就是我们最终要绘制到屏幕上的位图</li>\n<li>比如说我们创建的是一个UILable，contents里面最终放置的结果就是关于hello word的文字位图</li>\n<li>然后系统会在合适的时机回调一个drawRect：方法，在此基础上可以绘制一些自定义想要绘制的内容</li>\n<li>绘制好的位图，最终会由Core Animation框架提交给GPU部分的OpenGL（ES）渲染管线进行最终的位图的渲染，包括文理的合成，然后显示到屏幕上面</li>\n</ol>\n<h2 id=\"UI卡顿-amp-掉帧原因\"><a href=\"#UI卡顿-amp-掉帧原因\" class=\"headerlink\" title=\"UI卡顿&amp;掉帧原因\"></a>UI卡顿&amp;掉帧原因</h2><p><img src=\"/img/UI卡顿&amp;掉帧原因.png\" alt=\"\"></p>\n<p>一般60fps为流畅：每一秒钟会有60帧的画面更新</p>\n<p>那么每隔 16.7ms（1/60）就要产生一帧画面，那么在这 16.7 毫秒之内，需要 CPU 和 GPU 共同完成产生一帧数据</p>\n<p>比如 CPU 花费一定的时间做文本的布局，UI计算，包括一些视图的绘制，以及图片解码，然后把最终产生的位图提交给 GPU，再由 GPU 进行相应的图层的合成，文理渲染，然后准备好下一帧画面，再下一帧 VSync 信号到来的时候就可以显示画面</p>\n<p>那假如说 CPU 在做文本布局，UI计算，视图绘制，以及图片解码等工作时长太长的话 ，那么留给 GPU 的时间就非常少，那 GPU 要想把图层的合成，文理渲染全部准备完毕，可能就要总时间超过了 16.7ms，那这样的话在下一帧 VSync 的信号到来的时候，我们没有准备好这一帧当下的画面，那就由此产生了掉帧，我们看到的效果就是滑动卡顿</p>\n<p>总之，就是在规定的 16.7ms 之内，在下一帧 VSync 信号到来之前，CPU 和 GPU 并没有共同完成下一帧画面的合成，于是就会导致卡顿或者说掉帧</p>\n<h4 id=\"滑动优化方案\"><a href=\"#滑动优化方案\" class=\"headerlink\" title=\"滑动优化方案\"></a>滑动优化方案</h4><p>CPU</p>\n<ul>\n<li>对象创建、调整、销毁（可以放在子线程）</li>\n<li>预排版（布局计算，文本计算）</li>\n<li>预渲染（文本等异步绘制，图片编码等）</li>\n</ul>\n<p>GPU</p>\n<ul>\n<li>纹理渲染（避免离屏渲染、CPU异步绘制机制减轻GPU压力）</li>\n<li>视图混合（减轻层级复杂度）</li>\n</ul>\n"},{"title":"UI视图--UI绘制原理&异步绘制","date":"2018-04-13T07:22:09.000Z","description":"UI绘制原理&异步绘制","_content":"\n***\n[UI视图--图像显示原理与卡顿&掉帧](http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&%E6%8E%89%E5%B8%A7/)\n[UI视图--UI绘制原理&异步绘制](http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/)\n[UI视图--离屏渲染](http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/)\n***\n\n\n## UI绘制原理的过程\n\n![](/img/UI绘制原理的过程.png)\n\n当调用 [UIView setNeedsDisplay] 方法时，系统会立即调用它所对应 layer 的同名方法 setNeedsDisplay，之后相当于是 layer 上打了一个脏标记，在当前 runloop 即将要结束的时候，会调用 [CALayer display] 方法，然后进入到视图真正的绘制过程当中\n\n所以当调用 [UIView setNeedsDisplay] 时并没有立刻发生对应视图的绘制工作，视图的绘制时机，是在当前runloop即将结束的时候才会开始\n\n[CALayer display] 方法内部实现中，首先会判断 layer 的 delegate 是否响应 dispLayer：，如果不响应，就会进入到系统的绘制流程中，如果响应，就为我们提供了异步绘制的入口\n\n## 系统的绘制流程\n\n![](img/系统的绘制流程.png)\n\n在 CALayer 内部会创建一个 backing store （CGContextRef）,然后 layer 会判断它是否有代理，如果没有代理的话，会调用 [CALayer drawInContext:] ，如果有代理，会调用 [layer.delegate drawLayer:inContext:] 然后做当前视图的绘制工作，这部分是发生在系统内部的，然后在一个合适的时机给予我们一个回调方法 就是 [UIView drawRect:]， [UIView drawRect:] 的默认实现是什么都不做，给我们开这个口子就允许我们在系统绘制的基础之上做一些其他的相关的绘制工作，最后不论是哪个分支，都是由 CALyer 上传对应的 backing store （可以理解为位图）到GPU\n\n## 异步绘制\n\n[layer.delegate drawLayer:inContext:] 方法实现就可以进入到异步绘制的流程\n\n* 代理负责生产对应的 bitmap\n\n* 设置该 bitmap 作为 layer.contents 属性的值 \n\n#### 异步绘制的机制和流程\n\n![](/img/异步绘制的机制和流程.png)\n\n在调用 setNeedsDisplay 方法之后，在当前 runloop 快要结束的时候，由系统调用视图所对应 CALayer 的 display 方法，然后如果代理实现了 displayLayer：函数时，会调用代理的 displayLayer：函数方法，然后会通过子线程的切换，在子线程中做位图的绘制 ，此时主线程可以做别的事\n\n\n在全局并发队列子线程中：\n\n1. 第一步通过 CGBitmapContextCreat() 函数来创建一个位图的上下文\n2. 然后通过CoreGraphic 的相关API做当前UI控件的绘制工作 \n3. 之后，再通过 CGBitmapContextCreatImage() 函数来根据当前所绘制的上下文，生成一张 CGImage 图片\n4. 然后回到主队列中提交位图，设置给 CALayer 的 contents 属性 ，这样就完成了一个UI控件的异步绘制","source":"_posts/UI视图--UI绘制原理&异步绘制.md","raw":"---\ntitle: UI视图--UI绘制原理&异步绘制\ndate: 2018-04-13 15:22:09\ndescription: UI绘制原理&异步绘制\ncategories: UI视图\ntags: [Objective-C]\n---\n\n***\n[UI视图--图像显示原理与卡顿&掉帧](http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&%E6%8E%89%E5%B8%A7/)\n[UI视图--UI绘制原理&异步绘制](http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/)\n[UI视图--离屏渲染](http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/)\n***\n\n\n## UI绘制原理的过程\n\n![](/img/UI绘制原理的过程.png)\n\n当调用 [UIView setNeedsDisplay] 方法时，系统会立即调用它所对应 layer 的同名方法 setNeedsDisplay，之后相当于是 layer 上打了一个脏标记，在当前 runloop 即将要结束的时候，会调用 [CALayer display] 方法，然后进入到视图真正的绘制过程当中\n\n所以当调用 [UIView setNeedsDisplay] 时并没有立刻发生对应视图的绘制工作，视图的绘制时机，是在当前runloop即将结束的时候才会开始\n\n[CALayer display] 方法内部实现中，首先会判断 layer 的 delegate 是否响应 dispLayer：，如果不响应，就会进入到系统的绘制流程中，如果响应，就为我们提供了异步绘制的入口\n\n## 系统的绘制流程\n\n![](img/系统的绘制流程.png)\n\n在 CALayer 内部会创建一个 backing store （CGContextRef）,然后 layer 会判断它是否有代理，如果没有代理的话，会调用 [CALayer drawInContext:] ，如果有代理，会调用 [layer.delegate drawLayer:inContext:] 然后做当前视图的绘制工作，这部分是发生在系统内部的，然后在一个合适的时机给予我们一个回调方法 就是 [UIView drawRect:]， [UIView drawRect:] 的默认实现是什么都不做，给我们开这个口子就允许我们在系统绘制的基础之上做一些其他的相关的绘制工作，最后不论是哪个分支，都是由 CALyer 上传对应的 backing store （可以理解为位图）到GPU\n\n## 异步绘制\n\n[layer.delegate drawLayer:inContext:] 方法实现就可以进入到异步绘制的流程\n\n* 代理负责生产对应的 bitmap\n\n* 设置该 bitmap 作为 layer.contents 属性的值 \n\n#### 异步绘制的机制和流程\n\n![](/img/异步绘制的机制和流程.png)\n\n在调用 setNeedsDisplay 方法之后，在当前 runloop 快要结束的时候，由系统调用视图所对应 CALayer 的 display 方法，然后如果代理实现了 displayLayer：函数时，会调用代理的 displayLayer：函数方法，然后会通过子线程的切换，在子线程中做位图的绘制 ，此时主线程可以做别的事\n\n\n在全局并发队列子线程中：\n\n1. 第一步通过 CGBitmapContextCreat() 函数来创建一个位图的上下文\n2. 然后通过CoreGraphic 的相关API做当前UI控件的绘制工作 \n3. 之后，再通过 CGBitmapContextCreatImage() 函数来根据当前所绘制的上下文，生成一张 CGImage 图片\n4. 然后回到主队列中提交位图，设置给 CALayer 的 contents 属性 ，这样就完成了一个UI控件的异步绘制","slug":"UI视图--UI绘制原理&异步绘制","published":1,"updated":"2018-08-31T03:47:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6gc1002666r20pt8y1k2","content":"<hr>\n<p><a href=\"http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&amp;%E6%8E%89%E5%B8%A7/\" target=\"_blank\" rel=\"noopener\">UI视图–图像显示原理与卡顿&amp;掉帧</a><br><a href=\"http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&amp;%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">UI视图–UI绘制原理&amp;异步绘制</a><br><a href=\"http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/\" target=\"_blank\" rel=\"noopener\">UI视图–离屏渲染</a></p>\n<hr>\n<h2 id=\"UI绘制原理的过程\"><a href=\"#UI绘制原理的过程\" class=\"headerlink\" title=\"UI绘制原理的过程\"></a>UI绘制原理的过程</h2><p><img src=\"/img/UI绘制原理的过程.png\" alt=\"\"></p>\n<p>当调用 [UIView setNeedsDisplay] 方法时，系统会立即调用它所对应 layer 的同名方法 setNeedsDisplay，之后相当于是 layer 上打了一个脏标记，在当前 runloop 即将要结束的时候，会调用 [CALayer display] 方法，然后进入到视图真正的绘制过程当中</p>\n<p>所以当调用 [UIView setNeedsDisplay] 时并没有立刻发生对应视图的绘制工作，视图的绘制时机，是在当前runloop即将结束的时候才会开始</p>\n<p>[CALayer display] 方法内部实现中，首先会判断 layer 的 delegate 是否响应 dispLayer：，如果不响应，就会进入到系统的绘制流程中，如果响应，就为我们提供了异步绘制的入口</p>\n<h2 id=\"系统的绘制流程\"><a href=\"#系统的绘制流程\" class=\"headerlink\" title=\"系统的绘制流程\"></a>系统的绘制流程</h2><p><img src=\"img/系统的绘制流程.png\" alt=\"\"></p>\n<p>在 CALayer 内部会创建一个 backing store （CGContextRef）,然后 layer 会判断它是否有代理，如果没有代理的话，会调用 [CALayer drawInContext:] ，如果有代理，会调用 [layer.delegate drawLayer:inContext:] 然后做当前视图的绘制工作，这部分是发生在系统内部的，然后在一个合适的时机给予我们一个回调方法 就是 [UIView drawRect:]， [UIView drawRect:] 的默认实现是什么都不做，给我们开这个口子就允许我们在系统绘制的基础之上做一些其他的相关的绘制工作，最后不论是哪个分支，都是由 CALyer 上传对应的 backing store （可以理解为位图）到GPU</p>\n<h2 id=\"异步绘制\"><a href=\"#异步绘制\" class=\"headerlink\" title=\"异步绘制\"></a>异步绘制</h2><p>[layer.delegate drawLayer:inContext:] 方法实现就可以进入到异步绘制的流程</p>\n<ul>\n<li><p>代理负责生产对应的 bitmap</p>\n</li>\n<li><p>设置该 bitmap 作为 layer.contents 属性的值 </p>\n</li>\n</ul>\n<h4 id=\"异步绘制的机制和流程\"><a href=\"#异步绘制的机制和流程\" class=\"headerlink\" title=\"异步绘制的机制和流程\"></a>异步绘制的机制和流程</h4><p><img src=\"/img/异步绘制的机制和流程.png\" alt=\"\"></p>\n<p>在调用 setNeedsDisplay 方法之后，在当前 runloop 快要结束的时候，由系统调用视图所对应 CALayer 的 display 方法，然后如果代理实现了 displayLayer：函数时，会调用代理的 displayLayer：函数方法，然后会通过子线程的切换，在子线程中做位图的绘制 ，此时主线程可以做别的事</p>\n<p>在全局并发队列子线程中：</p>\n<ol>\n<li>第一步通过 CGBitmapContextCreat() 函数来创建一个位图的上下文</li>\n<li>然后通过CoreGraphic 的相关API做当前UI控件的绘制工作 </li>\n<li>之后，再通过 CGBitmapContextCreatImage() 函数来根据当前所绘制的上下文，生成一张 CGImage 图片</li>\n<li>然后回到主队列中提交位图，设置给 CALayer 的 contents 属性 ，这样就完成了一个UI控件的异步绘制</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"http://localhost:4000/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&amp;%E6%8E%89%E5%B8%A7/\" target=\"_blank\" rel=\"noopener\">UI视图–图像显示原理与卡顿&amp;掉帧</a><br><a href=\"http://localhost:4000/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&amp;%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">UI视图–UI绘制原理&amp;异步绘制</a><br><a href=\"http://localhost:4000/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/\" target=\"_blank\" rel=\"noopener\">UI视图–离屏渲染</a></p>\n<hr>\n<h2 id=\"UI绘制原理的过程\"><a href=\"#UI绘制原理的过程\" class=\"headerlink\" title=\"UI绘制原理的过程\"></a>UI绘制原理的过程</h2><p><img src=\"/img/UI绘制原理的过程.png\" alt=\"\"></p>\n<p>当调用 [UIView setNeedsDisplay] 方法时，系统会立即调用它所对应 layer 的同名方法 setNeedsDisplay，之后相当于是 layer 上打了一个脏标记，在当前 runloop 即将要结束的时候，会调用 [CALayer display] 方法，然后进入到视图真正的绘制过程当中</p>\n<p>所以当调用 [UIView setNeedsDisplay] 时并没有立刻发生对应视图的绘制工作，视图的绘制时机，是在当前runloop即将结束的时候才会开始</p>\n<p>[CALayer display] 方法内部实现中，首先会判断 layer 的 delegate 是否响应 dispLayer：，如果不响应，就会进入到系统的绘制流程中，如果响应，就为我们提供了异步绘制的入口</p>\n<h2 id=\"系统的绘制流程\"><a href=\"#系统的绘制流程\" class=\"headerlink\" title=\"系统的绘制流程\"></a>系统的绘制流程</h2><p><img src=\"img/系统的绘制流程.png\" alt=\"\"></p>\n<p>在 CALayer 内部会创建一个 backing store （CGContextRef）,然后 layer 会判断它是否有代理，如果没有代理的话，会调用 [CALayer drawInContext:] ，如果有代理，会调用 [layer.delegate drawLayer:inContext:] 然后做当前视图的绘制工作，这部分是发生在系统内部的，然后在一个合适的时机给予我们一个回调方法 就是 [UIView drawRect:]， [UIView drawRect:] 的默认实现是什么都不做，给我们开这个口子就允许我们在系统绘制的基础之上做一些其他的相关的绘制工作，最后不论是哪个分支，都是由 CALyer 上传对应的 backing store （可以理解为位图）到GPU</p>\n<h2 id=\"异步绘制\"><a href=\"#异步绘制\" class=\"headerlink\" title=\"异步绘制\"></a>异步绘制</h2><p>[layer.delegate drawLayer:inContext:] 方法实现就可以进入到异步绘制的流程</p>\n<ul>\n<li><p>代理负责生产对应的 bitmap</p>\n</li>\n<li><p>设置该 bitmap 作为 layer.contents 属性的值 </p>\n</li>\n</ul>\n<h4 id=\"异步绘制的机制和流程\"><a href=\"#异步绘制的机制和流程\" class=\"headerlink\" title=\"异步绘制的机制和流程\"></a>异步绘制的机制和流程</h4><p><img src=\"/img/异步绘制的机制和流程.png\" alt=\"\"></p>\n<p>在调用 setNeedsDisplay 方法之后，在当前 runloop 快要结束的时候，由系统调用视图所对应 CALayer 的 display 方法，然后如果代理实现了 displayLayer：函数时，会调用代理的 displayLayer：函数方法，然后会通过子线程的切换，在子线程中做位图的绘制 ，此时主线程可以做别的事</p>\n<p>在全局并发队列子线程中：</p>\n<ol>\n<li>第一步通过 CGBitmapContextCreat() 函数来创建一个位图的上下文</li>\n<li>然后通过CoreGraphic 的相关API做当前UI控件的绘制工作 </li>\n<li>之后，再通过 CGBitmapContextCreatImage() 函数来根据当前所绘制的上下文，生成一张 CGImage 图片</li>\n<li>然后回到主队列中提交位图，设置给 CALayer 的 contents 属性 ，这样就完成了一个UI控件的异步绘制</li>\n</ol>\n"},{"title":"iOS中的多线程","date":"2017-11-18T03:11:18.000Z","description":"在 iOS 中其实目前有 4 套多线程方案","toc":true,"_content":"\n在 iOS 中其实目前有 4 套多线程方案，他们分别是：\n\n1. Pthreads\n2. NSThread\n3. GCD\n4. NSOperation & NSOperationQueue\n\n## Pthreads     \n\n**特点：**\n\n* 一套通用的多线程API\n* 适用于Unix\\Linux\\Windows等系统\n* 跨平台\\可移植\n* 使用难度大\n\n**使用语言：**基于 c语言 的框架\n\n**使用频率：**几乎不用\n\n**线程生命周期：**由程序员手动进行管理\n\n## NSThread\n\n**特点：**\n\n* 使用更加面向对象\n* 简单易用，可直接操作线程对象\n\n**使用语言：**OC语言\n\n**使用频率：**偶尔使用\n\n**线程生命周期：**由程序员手动进行管理\n\n\n这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便\n\n### 使用\n\n* 先创建线程类，再启动\n\n```\n// 创建\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];\n\n// 启动\n[thread start];\n\n```\n\n* 创建并自动启动\n\n```\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];\n\n```\n\n* 使用 NSObject 的方法创建并自动启动\n\n```\n[self performSelectorInBackground:@selector(run:) withObject:nil];\n```\n\n\n## GCD\n\n**特点:**\n\n* 旨在替代NSThread等线程技术\n* 充分利用设备的多核（自动）\n\n**使用语言：**C语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\n\n它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。\n\n## NSOperation\n\n**特点:**\n\n* 基于GCD（底层是GCD）\n* 比GCD多了一些更简单实用的功能\n* 使用更加面向对象\n\n**使用语言：**OC语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\nNSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：\n\n1. 将要执行的任务封装到一个 NSOperation 对象中。\n2. 将此任务添加到一个 NSOperationQueue 对象中。\n\n然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：\n\n### 添加任务\n\n值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。\n\n* NSInvocationOperation: 需要传入一个方法名\n\n```\n//1.创建NSInvocationOperation对象\nNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n\n//2.开始执行\n[operation start];\n\n```\n\n* NSBlockOperation\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n      NSLog(@\"%@\", [NSThread currentThread]);\n  }];\n\n//2.开始任务\n[operation start];\n  \n```\n\n之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 **会并发执行**，它会 **在主线程和其它的多个线程** 执行这些任务，注意下面的打印结果：\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//添加多个Block\n//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//2.开始任务\n[operation start];\n\n```\n\n**打印：**\n\n```\n2017-11-18 16:30:29.787013+0800 model[75340:4510678] <NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787049+0800 model[75340:4510790] 第1次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510788] 第0次：<NSThread: 0x60400046f6c0>{number = 3, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510791] 第2次：<NSThread: 0x600000463100>{number = 5, name = (null)}\n\n2017-11-18 16:30:29.787179+0800 model[75340:4510678] 第3次：<NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787181+0800 model[75340:4510790] 第4次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n```\n\n* 自定义Operation\n\n除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。\n\n### 创建队列\n\n看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 **同步执行** 的。就算是 addExecutionBlock 方法，也会在 **当前线程和其他线程 **中执行，也就是说还是会占用当前线程。这是就要用到队列 **NSOperationQueue** 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。**只要添加到队列，会自动调用任务的 start() 方法**\n\n* 主队列\n\n每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。\n\n```\nNSOperationQueue *queue = [NSOperationQueue mainQueue];\n```\n\n\n* 其他队列\n\n因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。\n\n注意：其他队列的任务会在其他线程并行执行。\n\n```\n//1.创建一个其他队列    \nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n//2.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//3.添加多个Block\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//4.队列添加任务\n[queue addOperation:operation];\n\n```\n\n打印\n\n```\n2017-11-18 17:49:25.806408+0800 model[75459:4552310] 第1次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n2017-11-18 17:49:25.806410+0800 model[75459:4552309] 第0次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806417+0800 model[75459:4552317] 第2次：<NSThread: 0x60400027bf00>{number = 4, name = (null)}\n\n2017-11-18 17:49:25.806424+0800 model[75459:4552307] <NSThread: 0x600000271280>{number = 3, name = (null)}\n\n2017-11-18 17:49:25.806668+0800 Runtime[75459:4552309] 第3次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806673+0800 model[75459:4552310] 第4次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n```\n\n**问题：**将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？\n\n**答：**这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛\n\nNSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。\n\nNSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:\n\n```\n//1.任务一：下载图片\nNSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"下载图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//2.任务二：打水印\nNSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"打水印   - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//3.任务三：上传图片\nNSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"上传图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//4.设置依赖\n[operation2 addDependency:operation1];      //任务二依赖任务一\n[operation3 addDependency:operation2];      //任务三依赖任务二\n\n//5.创建队列并加入任务\nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];\n\n```\n\n**打印**\n\n\n```\n2017-11-18 18:01:25.806424+0800 model[19392:4637517] 下载图片 - <NSThread: 0x7fc10ad4d970>{number = 2, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 打水印 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 上传图片 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n```\n\n* 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。\n* 可以使用 removeDependency 来解除依赖关系。\n* 可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。\n\n### 其他方法\n\n以上就是一些主要方法, 下面还有一些常用方法需要大家注意：\n\n* NSOperation\n\n```\nBOOL executing; //判断任务是否正在执行\n\nBOOL finished; //判断任务是否完成\n\nvoid (^completionBlock)(void); //用来设置完成后需要执行的操作\n\n- (void)cancel; //取消任务\n\n- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕\n\n```\n\n* NSOperationQueue\n\n```\nNSUInteger operationCount; //获取队列的任务数\n\n- (void)cancelAllOperations; //取消队列中所有的任务\n\n- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕\n\n[queue setSuspended:YES]; // 暂停queue\n\n[queue setSuspended:NO]; // 继续queue\n\n```\n\n## 多线程的原理\n\n同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。\n\n* **问题：**如果线程非常非常多，会发生什么情况？\n\n* **答：**CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）\n\n\n多线程的优点\n \n* 能适当提高程序的执行效率；\n* 能适当提高资源利用率（CPU、内存利用率）\n\n多线程的缺点\n\n* 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能\n* 线程越多，CPU在调度线程上的开销就越大\n* 程序设计更加复杂：比如线程之间的通信、多线程的数据共享\n\n## 多线程的应用（个别案例）\n\n### 线程同步\n\n线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：\n\n* **互斥锁 ：**给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。\n\n```\n@synchronized(self) {\n  //需要执行的代码块\n}\n\n```\n\n* **同步执行 ：**我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:\n\n```\n//GCD\n//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中\ndispatch_sync(queue, ^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:0.1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n});\n\n\n//NSOperation & NSOperationQueue\n//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中\n//       2. 设置 queue 的 maxConcurrentOperationCount 为 1\n//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！\n\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n}];\n\n[queue addOperation:operation];\n\n[operation waitUntilFinished];\n\n//后续要做的事\n\n```\n\n### 延迟执行\n\n延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。\n\n* perform\n\n```\n// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"\n[self performSelector:@selector(run:) withObject:@\"abc\" afterDelay:3];\n\n```\n\n* GCD\n\n可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用\n\n```\n// 创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n// 设置延时，单位秒\ndouble delay = 3; \n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{\n  // 3秒后需要执行的任务\n});\n\n```\n\n* NSTimer\n\nNSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法\n\n```\n[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@\"abc\" repeats:NO];\n\n```\n\n### 单例模式\n\n```\n@interface HbhNetWorkManager : NSObject <NSCopying>\n\n@property (nonatomic, strong) AFHTTPSessionManager *manager;\n\n/**\n *  单例\n *\n *  @return HbhNetWorkManager\n */\n+(instancetype) shareInstance;\n\n@end\n\nstatic HbhNetWorkManager *shareInstance = nil;\n+(instancetype) shareInstance{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        shareInstance=[[HbhNetWorkManager alloc] init];\n    });\n    return shareInstance;\n}\n```\n\n### 从其他线程回到主线程的方法\n\n* NSThread\n\n```\n//Objective-C\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];\n\n//Swift\n//swift 取消了 performSelector 方法。\n\n```\n\n* GCD\n\n```\n//Objective-C\ndispatch_async(dispatch_get_main_queue(), ^{\n\n});\n\n//Swift\ndispatch_async(dispatch_get_main_queue(), { () -> Void in\n\n})\n\n```\n\n* NSOperationQueue\n\n```\n/Objective-C\n[[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\n}];\n\n//Swift\nNSOperationQueue.mainQueue().addOperationWithBlock { () -> Void in\n\n}\n\n```\n\n## 多线程的选择（更倾向于哪一种？）\n\n倾向于GCD\n\n因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。\n\n## 参考文献\n\n[这里有一篇文章写的非常好，推荐。](https://www.jianshu.com/p/0b0d9b1f1f19)\n","source":"_posts/iOS中的多线程.md","raw":"---\ntitle: iOS中的多线程\ndate: 2017-11-18 11:11:18\n\ndescription: 在 iOS 中其实目前有 4 套多线程方案\n\ncategories: [iOS]\ntags: [Objective-C]\ntoc: true \n---\n\n在 iOS 中其实目前有 4 套多线程方案，他们分别是：\n\n1. Pthreads\n2. NSThread\n3. GCD\n4. NSOperation & NSOperationQueue\n\n## Pthreads     \n\n**特点：**\n\n* 一套通用的多线程API\n* 适用于Unix\\Linux\\Windows等系统\n* 跨平台\\可移植\n* 使用难度大\n\n**使用语言：**基于 c语言 的框架\n\n**使用频率：**几乎不用\n\n**线程生命周期：**由程序员手动进行管理\n\n## NSThread\n\n**特点：**\n\n* 使用更加面向对象\n* 简单易用，可直接操作线程对象\n\n**使用语言：**OC语言\n\n**使用频率：**偶尔使用\n\n**线程生命周期：**由程序员手动进行管理\n\n\n这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便\n\n### 使用\n\n* 先创建线程类，再启动\n\n```\n// 创建\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];\n\n// 启动\n[thread start];\n\n```\n\n* 创建并自动启动\n\n```\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];\n\n```\n\n* 使用 NSObject 的方法创建并自动启动\n\n```\n[self performSelectorInBackground:@selector(run:) withObject:nil];\n```\n\n\n## GCD\n\n**特点:**\n\n* 旨在替代NSThread等线程技术\n* 充分利用设备的多核（自动）\n\n**使用语言：**C语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\n\n它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。\n\n## NSOperation\n\n**特点:**\n\n* 基于GCD（底层是GCD）\n* 比GCD多了一些更简单实用的功能\n* 使用更加面向对象\n\n**使用语言：**OC语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\nNSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：\n\n1. 将要执行的任务封装到一个 NSOperation 对象中。\n2. 将此任务添加到一个 NSOperationQueue 对象中。\n\n然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：\n\n### 添加任务\n\n值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。\n\n* NSInvocationOperation: 需要传入一个方法名\n\n```\n//1.创建NSInvocationOperation对象\nNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n\n//2.开始执行\n[operation start];\n\n```\n\n* NSBlockOperation\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n      NSLog(@\"%@\", [NSThread currentThread]);\n  }];\n\n//2.开始任务\n[operation start];\n  \n```\n\n之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 **会并发执行**，它会 **在主线程和其它的多个线程** 执行这些任务，注意下面的打印结果：\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//添加多个Block\n//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//2.开始任务\n[operation start];\n\n```\n\n**打印：**\n\n```\n2017-11-18 16:30:29.787013+0800 model[75340:4510678] <NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787049+0800 model[75340:4510790] 第1次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510788] 第0次：<NSThread: 0x60400046f6c0>{number = 3, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510791] 第2次：<NSThread: 0x600000463100>{number = 5, name = (null)}\n\n2017-11-18 16:30:29.787179+0800 model[75340:4510678] 第3次：<NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787181+0800 model[75340:4510790] 第4次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n```\n\n* 自定义Operation\n\n除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。\n\n### 创建队列\n\n看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 **同步执行** 的。就算是 addExecutionBlock 方法，也会在 **当前线程和其他线程 **中执行，也就是说还是会占用当前线程。这是就要用到队列 **NSOperationQueue** 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。**只要添加到队列，会自动调用任务的 start() 方法**\n\n* 主队列\n\n每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。\n\n```\nNSOperationQueue *queue = [NSOperationQueue mainQueue];\n```\n\n\n* 其他队列\n\n因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。\n\n注意：其他队列的任务会在其他线程并行执行。\n\n```\n//1.创建一个其他队列    \nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n//2.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//3.添加多个Block\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//4.队列添加任务\n[queue addOperation:operation];\n\n```\n\n打印\n\n```\n2017-11-18 17:49:25.806408+0800 model[75459:4552310] 第1次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n2017-11-18 17:49:25.806410+0800 model[75459:4552309] 第0次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806417+0800 model[75459:4552317] 第2次：<NSThread: 0x60400027bf00>{number = 4, name = (null)}\n\n2017-11-18 17:49:25.806424+0800 model[75459:4552307] <NSThread: 0x600000271280>{number = 3, name = (null)}\n\n2017-11-18 17:49:25.806668+0800 Runtime[75459:4552309] 第3次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806673+0800 model[75459:4552310] 第4次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n```\n\n**问题：**将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？\n\n**答：**这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛\n\nNSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。\n\nNSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:\n\n```\n//1.任务一：下载图片\nNSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"下载图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//2.任务二：打水印\nNSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"打水印   - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//3.任务三：上传图片\nNSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"上传图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//4.设置依赖\n[operation2 addDependency:operation1];      //任务二依赖任务一\n[operation3 addDependency:operation2];      //任务三依赖任务二\n\n//5.创建队列并加入任务\nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];\n\n```\n\n**打印**\n\n\n```\n2017-11-18 18:01:25.806424+0800 model[19392:4637517] 下载图片 - <NSThread: 0x7fc10ad4d970>{number = 2, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 打水印 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 上传图片 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n```\n\n* 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。\n* 可以使用 removeDependency 来解除依赖关系。\n* 可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。\n\n### 其他方法\n\n以上就是一些主要方法, 下面还有一些常用方法需要大家注意：\n\n* NSOperation\n\n```\nBOOL executing; //判断任务是否正在执行\n\nBOOL finished; //判断任务是否完成\n\nvoid (^completionBlock)(void); //用来设置完成后需要执行的操作\n\n- (void)cancel; //取消任务\n\n- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕\n\n```\n\n* NSOperationQueue\n\n```\nNSUInteger operationCount; //获取队列的任务数\n\n- (void)cancelAllOperations; //取消队列中所有的任务\n\n- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕\n\n[queue setSuspended:YES]; // 暂停queue\n\n[queue setSuspended:NO]; // 继续queue\n\n```\n\n## 多线程的原理\n\n同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。\n\n* **问题：**如果线程非常非常多，会发生什么情况？\n\n* **答：**CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）\n\n\n多线程的优点\n \n* 能适当提高程序的执行效率；\n* 能适当提高资源利用率（CPU、内存利用率）\n\n多线程的缺点\n\n* 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能\n* 线程越多，CPU在调度线程上的开销就越大\n* 程序设计更加复杂：比如线程之间的通信、多线程的数据共享\n\n## 多线程的应用（个别案例）\n\n### 线程同步\n\n线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：\n\n* **互斥锁 ：**给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。\n\n```\n@synchronized(self) {\n  //需要执行的代码块\n}\n\n```\n\n* **同步执行 ：**我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:\n\n```\n//GCD\n//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中\ndispatch_sync(queue, ^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:0.1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n});\n\n\n//NSOperation & NSOperationQueue\n//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中\n//       2. 设置 queue 的 maxConcurrentOperationCount 为 1\n//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！\n\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n}];\n\n[queue addOperation:operation];\n\n[operation waitUntilFinished];\n\n//后续要做的事\n\n```\n\n### 延迟执行\n\n延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。\n\n* perform\n\n```\n// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"\n[self performSelector:@selector(run:) withObject:@\"abc\" afterDelay:3];\n\n```\n\n* GCD\n\n可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用\n\n```\n// 创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n// 设置延时，单位秒\ndouble delay = 3; \n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{\n  // 3秒后需要执行的任务\n});\n\n```\n\n* NSTimer\n\nNSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法\n\n```\n[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@\"abc\" repeats:NO];\n\n```\n\n### 单例模式\n\n```\n@interface HbhNetWorkManager : NSObject <NSCopying>\n\n@property (nonatomic, strong) AFHTTPSessionManager *manager;\n\n/**\n *  单例\n *\n *  @return HbhNetWorkManager\n */\n+(instancetype) shareInstance;\n\n@end\n\nstatic HbhNetWorkManager *shareInstance = nil;\n+(instancetype) shareInstance{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        shareInstance=[[HbhNetWorkManager alloc] init];\n    });\n    return shareInstance;\n}\n```\n\n### 从其他线程回到主线程的方法\n\n* NSThread\n\n```\n//Objective-C\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];\n\n//Swift\n//swift 取消了 performSelector 方法。\n\n```\n\n* GCD\n\n```\n//Objective-C\ndispatch_async(dispatch_get_main_queue(), ^{\n\n});\n\n//Swift\ndispatch_async(dispatch_get_main_queue(), { () -> Void in\n\n})\n\n```\n\n* NSOperationQueue\n\n```\n/Objective-C\n[[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\n}];\n\n//Swift\nNSOperationQueue.mainQueue().addOperationWithBlock { () -> Void in\n\n}\n\n```\n\n## 多线程的选择（更倾向于哪一种？）\n\n倾向于GCD\n\n因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。\n\n## 参考文献\n\n[这里有一篇文章写的非常好，推荐。](https://www.jianshu.com/p/0b0d9b1f1f19)\n","slug":"iOS中的多线程","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6gc4002866r2u1aefjae","content":"<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>\n<ol>\n<li>Pthreads</li>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation &amp; NSOperationQueue</li>\n</ol>\n<h2 id=\"Pthreads\"><a href=\"#Pthreads\" class=\"headerlink\" title=\"Pthreads\"></a>Pthreads</h2><p><strong>特点：</strong></p>\n<ul>\n<li>一套通用的多线程API</li>\n<li>适用于Unix\\Linux\\Windows等系统</li>\n<li>跨平台\\可移植</li>\n<li>使用难度大</li>\n</ul>\n<p><strong>使用语言：</strong>基于 c语言 的框架</p>\n<p><strong>使用频率：</strong>几乎不用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<h2 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h2><p><strong>特点：</strong></p>\n<ul>\n<li>使用更加面向对象</li>\n<li>简单易用，可直接操作线程对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>偶尔使用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>先创建线程类，再启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\">NSThread *thread = [[NSThread alloc] <span class=\"string\">initWithTarget:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">object:</span>nil];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动</span></span><br><span class=\"line\">[thread start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSThread <span class=\"string\">detachNewThreadSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">toTarget:</span>self <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 NSObject 的方法创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self <span class=\"string\">performSelectorInBackground:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p><strong>特点:</strong></p>\n<ul>\n<li>旨在替代NSThread等线程技术</li>\n<li>充分利用设备的多核（自动）</li>\n</ul>\n<p><strong>使用语言：</strong>C语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。</p>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p><strong>特点:</strong></p>\n<ul>\n<li>基于GCD（底层是GCD）</li>\n<li>比GCD多了一些更简单实用的功能</li>\n<li>使用更加面向对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>\n<ol>\n<li>将要执行的任务封装到一个 NSOperation 对象中。</li>\n<li>将此任务添加到一个 NSOperationQueue 对象中。</li>\n</ol>\n<p>然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>\n<h3 id=\"添加任务\"><a href=\"#添加任务\" class=\"headerlink\" title=\"添加任务\"></a>添加任务</h3><p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>\n<ul>\n<li>NSInvocationOperation: 需要传入一个方法名</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSInvocationOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSInvocationOperation</span> *operation = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始执行</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSBlockOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">  &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 <strong>会并发执行</strong>，它会 <strong>在主线程和其它的多个线程</strong> 执行这些任务，注意下面的打印结果：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加多个Block</span></span><br><span class=\"line\"><span class=\"comment\">//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p><strong>打印：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787013</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787049</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510788</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f6c0</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510791</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x<span class=\"number\">600000463100</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787179</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787181</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义Operation</li>\n</ul>\n<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。</p>\n<h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 <strong>同步执行</strong> 的。就算是 addExecutionBlock 方法，也会在 <strong>当前线程和其他线程 </strong>中执行，也就是说还是会占用当前线程。这是就要用到队列 <strong>NSOperationQueue</strong> 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。<strong>只要添加到队列，会自动调用任务的 start() 方法</strong></p>\n<ul>\n<li>主队列</li>\n</ul>\n<p>每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [<span class=\"built_in\">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他队列</li>\n</ul>\n<p>因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>\n<p>注意：其他队列的任务会在其他线程并行执行。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建一个其他队列    </span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.添加多个Block</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.队列添加任务</span></span><br><span class=\"line\">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n<p>打印</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806408</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806410</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806417</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552317</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x60400027bf00&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552307</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271280</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806668</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806673</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题：</strong>将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>\n<p><strong>答：</strong>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛</p>\n<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>\n<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.任务一：下载图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.任务二：打水印</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打水印   - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.任务三：上传图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"上传图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.设置依赖</span></span><br><span class=\"line\">[operation2 addDependency:operation1];      <span class=\"comment\">//任务二依赖任务一</span></span><br><span class=\"line\">[operation3 addDependency:operation2];      <span class=\"comment\">//任务三依赖任务二</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5.创建队列并加入任务</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>打印</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637517</span>] 下载图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10ad4d970&gt;&#123;number = <span class=\"number\">2</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 打水印 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 上传图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。</li>\n<li>可以使用 removeDependency 来解除依赖关系。</li>\n<li>可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</li>\n</ul>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>\n<ul>\n<li>NSOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> executing; <span class=\"comment\">//判断任务是否正在执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> finished; <span class=\"comment\">//判断任务是否完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> (^completionBlock)(<span class=\"keyword\">void</span>); <span class=\"comment\">//用来设置完成后需要执行的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel; <span class=\"comment\">//取消任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilFinished; <span class=\"comment\">//阻塞当前线程直到此任务执行完毕</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUInteger</span> operationCount; <span class=\"comment\">//获取队列的任务数</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancelAllOperations; <span class=\"comment\">//取消队列中所有的任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilAllOperationsAreFinished; <span class=\"comment\">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">YES</span>]; <span class=\"comment\">// 暂停queue</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">NO</span>]; <span class=\"comment\">// 继续queue</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的原理\"><a href=\"#多线程的原理\" class=\"headerlink\" title=\"多线程的原理\"></a>多线程的原理</h2><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>\n<ul>\n<li><p><strong>问题：</strong>如果线程非常非常多，会发生什么情况？</p>\n</li>\n<li><p><strong>答：</strong>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）</p>\n</li>\n</ul>\n<p>多线程的优点</p>\n<ul>\n<li>能适当提高程序的执行效率；</li>\n<li>能适当提高资源利用率（CPU、内存利用率）</li>\n</ul>\n<p>多线程的缺点</p>\n<ul>\n<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>\n<li>线程越多，CPU在调度线程上的开销就越大</li>\n<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>\n</ul>\n<h2 id=\"多线程的应用（个别案例）\"><a href=\"#多线程的应用（个别案例）\" class=\"headerlink\" title=\"多线程的应用（个别案例）\"></a>多线程的应用（个别案例）</h2><h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><p>线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>\n<ul>\n<li><strong>互斥锁 ：</strong>给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">  /<span class=\"regexp\">/需要执行的代码块</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>同步执行 ：</strong>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GCD</span></span><br><span class=\"line\"><span class=\"comment\">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">0.1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NSOperation &amp; NSOperationQueue</span></span><br><span class=\"line\"><span class=\"comment\">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中</span></span><br><span class=\"line\"><span class=\"comment\">//       2. 设置 queue 的 maxConcurrentOperationCount 为 1</span></span><br><span class=\"line\"><span class=\"comment\">//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[queue addOperation:operation];</span><br><span class=\"line\"></span><br><span class=\"line\">[operation waitUntilFinished];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后续要做的事</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><p>延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>\n<ul>\n<li>perform</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// <span class=\"number\">3</span>秒后自动调用self的<span class=\"keyword\">run</span><span class=\"bash\">:方法，并且传递参数：@<span class=\"string\">\"abc\"</span></span></span><br><span class=\"line\"><span class=\"bash\">[self performSelector:@selector(run:) withObject:@<span class=\"string\">\"abc\"</span> afterDelay:3];</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列</span></span><br><span class=\"line\"><span class=\"keyword\">dispatch_queue_t</span> <span class=\"built_in\">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置延时，单位秒</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> delay = <span class=\"number\">3</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class=\"keyword\">int64_t</span>)(delay * NSEC_PER_SEC)), <span class=\"built_in\">queue</span>, ^&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 3秒后需要执行的任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSTimer</li>\n</ul>\n<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">3.0</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">userInfo:</span>@<span class=\"string\">\"abc\"</span> <span class=\"string\">repeats:</span>NO];</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface HbhNetWorkManager : NSObject &lt;NSCopying&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) AFHTTPSessionManager *manager<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  单例</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return HbhNetWorkManager</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static </span>HbhNetWorkManager *<span class=\"keyword\">shareInstance </span>= nil<span class=\"comment\">;</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance&#123;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   static <span class=\"keyword\">dispatch_once_t </span>onceToken<span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"keyword\">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">shareInstance=[[HbhNetWorkManager </span>alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;)<span class=\"comment\">;</span></span><br><span class=\"line\">    return <span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从其他线程回到主线程的方法\"><a href=\"#从其他线程回到主线程的方法\" class=\"headerlink\" title=\"从其他线程回到主线程的方法\"></a>从其他线程回到主线程的方法</h3><ul>\n<li>NSThread</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Objective-C</span></span><br><span class=\"line\">[self <span class=\"string\">performSelectorOnMainThread:</span><span class=\"meta\">@selector</span>(run) <span class=\"string\">withObject:</span>nil <span class=\"string\">waitUntilDone:</span>NO];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"comment\">//swift 取消了 performSelector 方法。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Objective-C</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//Swift</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), &#123; () -&gt; Void in</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Objective-C</span><br><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span>.mainQueue().addOperationWithBlock &#123; () -&gt; Void <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的选择（更倾向于哪一种？）\"><a href=\"#多线程的选择（更倾向于哪一种？）\" class=\"headerlink\" title=\"多线程的选择（更倾向于哪一种？）\"></a>多线程的选择（更倾向于哪一种？）</h2><p>倾向于GCD</p>\n<p>因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jianshu.com/p/0b0d9b1f1f19\" target=\"_blank\" rel=\"noopener\">这里有一篇文章写的非常好，推荐。</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>\n<ol>\n<li>Pthreads</li>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation &amp; NSOperationQueue</li>\n</ol>\n<h2 id=\"Pthreads\"><a href=\"#Pthreads\" class=\"headerlink\" title=\"Pthreads\"></a>Pthreads</h2><p><strong>特点：</strong></p>\n<ul>\n<li>一套通用的多线程API</li>\n<li>适用于Unix\\Linux\\Windows等系统</li>\n<li>跨平台\\可移植</li>\n<li>使用难度大</li>\n</ul>\n<p><strong>使用语言：</strong>基于 c语言 的框架</p>\n<p><strong>使用频率：</strong>几乎不用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<h2 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h2><p><strong>特点：</strong></p>\n<ul>\n<li>使用更加面向对象</li>\n<li>简单易用，可直接操作线程对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>偶尔使用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>先创建线程类，再启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\">NSThread *thread = [[NSThread alloc] <span class=\"string\">initWithTarget:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">object:</span>nil];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动</span></span><br><span class=\"line\">[thread start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSThread <span class=\"string\">detachNewThreadSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">toTarget:</span>self <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 NSObject 的方法创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self <span class=\"string\">performSelectorInBackground:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p><strong>特点:</strong></p>\n<ul>\n<li>旨在替代NSThread等线程技术</li>\n<li>充分利用设备的多核（自动）</li>\n</ul>\n<p><strong>使用语言：</strong>C语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。</p>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p><strong>特点:</strong></p>\n<ul>\n<li>基于GCD（底层是GCD）</li>\n<li>比GCD多了一些更简单实用的功能</li>\n<li>使用更加面向对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>\n<ol>\n<li>将要执行的任务封装到一个 NSOperation 对象中。</li>\n<li>将此任务添加到一个 NSOperationQueue 对象中。</li>\n</ol>\n<p>然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>\n<h3 id=\"添加任务\"><a href=\"#添加任务\" class=\"headerlink\" title=\"添加任务\"></a>添加任务</h3><p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>\n<ul>\n<li>NSInvocationOperation: 需要传入一个方法名</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSInvocationOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSInvocationOperation</span> *operation = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始执行</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSBlockOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">  &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 <strong>会并发执行</strong>，它会 <strong>在主线程和其它的多个线程</strong> 执行这些任务，注意下面的打印结果：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加多个Block</span></span><br><span class=\"line\"><span class=\"comment\">//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p><strong>打印：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787013</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787049</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510788</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f6c0</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510791</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x<span class=\"number\">600000463100</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787179</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787181</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义Operation</li>\n</ul>\n<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。</p>\n<h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 <strong>同步执行</strong> 的。就算是 addExecutionBlock 方法，也会在 <strong>当前线程和其他线程 </strong>中执行，也就是说还是会占用当前线程。这是就要用到队列 <strong>NSOperationQueue</strong> 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。<strong>只要添加到队列，会自动调用任务的 start() 方法</strong></p>\n<ul>\n<li>主队列</li>\n</ul>\n<p>每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [<span class=\"built_in\">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他队列</li>\n</ul>\n<p>因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>\n<p>注意：其他队列的任务会在其他线程并行执行。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建一个其他队列    </span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.添加多个Block</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.队列添加任务</span></span><br><span class=\"line\">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n<p>打印</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806408</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806410</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806417</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552317</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x60400027bf00&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552307</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271280</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806668</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806673</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题：</strong>将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>\n<p><strong>答：</strong>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛</p>\n<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>\n<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.任务一：下载图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.任务二：打水印</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打水印   - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.任务三：上传图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"上传图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.设置依赖</span></span><br><span class=\"line\">[operation2 addDependency:operation1];      <span class=\"comment\">//任务二依赖任务一</span></span><br><span class=\"line\">[operation3 addDependency:operation2];      <span class=\"comment\">//任务三依赖任务二</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5.创建队列并加入任务</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>打印</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637517</span>] 下载图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10ad4d970&gt;&#123;number = <span class=\"number\">2</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 打水印 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 上传图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。</li>\n<li>可以使用 removeDependency 来解除依赖关系。</li>\n<li>可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</li>\n</ul>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>\n<ul>\n<li>NSOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> executing; <span class=\"comment\">//判断任务是否正在执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> finished; <span class=\"comment\">//判断任务是否完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> (^completionBlock)(<span class=\"keyword\">void</span>); <span class=\"comment\">//用来设置完成后需要执行的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel; <span class=\"comment\">//取消任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilFinished; <span class=\"comment\">//阻塞当前线程直到此任务执行完毕</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUInteger</span> operationCount; <span class=\"comment\">//获取队列的任务数</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancelAllOperations; <span class=\"comment\">//取消队列中所有的任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilAllOperationsAreFinished; <span class=\"comment\">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">YES</span>]; <span class=\"comment\">// 暂停queue</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">NO</span>]; <span class=\"comment\">// 继续queue</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的原理\"><a href=\"#多线程的原理\" class=\"headerlink\" title=\"多线程的原理\"></a>多线程的原理</h2><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>\n<ul>\n<li><p><strong>问题：</strong>如果线程非常非常多，会发生什么情况？</p>\n</li>\n<li><p><strong>答：</strong>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）</p>\n</li>\n</ul>\n<p>多线程的优点</p>\n<ul>\n<li>能适当提高程序的执行效率；</li>\n<li>能适当提高资源利用率（CPU、内存利用率）</li>\n</ul>\n<p>多线程的缺点</p>\n<ul>\n<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>\n<li>线程越多，CPU在调度线程上的开销就越大</li>\n<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>\n</ul>\n<h2 id=\"多线程的应用（个别案例）\"><a href=\"#多线程的应用（个别案例）\" class=\"headerlink\" title=\"多线程的应用（个别案例）\"></a>多线程的应用（个别案例）</h2><h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><p>线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>\n<ul>\n<li><strong>互斥锁 ：</strong>给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">  /<span class=\"regexp\">/需要执行的代码块</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>同步执行 ：</strong>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GCD</span></span><br><span class=\"line\"><span class=\"comment\">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">0.1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NSOperation &amp; NSOperationQueue</span></span><br><span class=\"line\"><span class=\"comment\">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中</span></span><br><span class=\"line\"><span class=\"comment\">//       2. 设置 queue 的 maxConcurrentOperationCount 为 1</span></span><br><span class=\"line\"><span class=\"comment\">//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[queue addOperation:operation];</span><br><span class=\"line\"></span><br><span class=\"line\">[operation waitUntilFinished];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后续要做的事</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><p>延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>\n<ul>\n<li>perform</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// <span class=\"number\">3</span>秒后自动调用self的<span class=\"keyword\">run</span><span class=\"bash\">:方法，并且传递参数：@<span class=\"string\">\"abc\"</span></span></span><br><span class=\"line\"><span class=\"bash\">[self performSelector:@selector(run:) withObject:@<span class=\"string\">\"abc\"</span> afterDelay:3];</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列</span></span><br><span class=\"line\"><span class=\"keyword\">dispatch_queue_t</span> <span class=\"built_in\">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置延时，单位秒</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> delay = <span class=\"number\">3</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class=\"keyword\">int64_t</span>)(delay * NSEC_PER_SEC)), <span class=\"built_in\">queue</span>, ^&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 3秒后需要执行的任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSTimer</li>\n</ul>\n<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">3.0</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">userInfo:</span>@<span class=\"string\">\"abc\"</span> <span class=\"string\">repeats:</span>NO];</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface HbhNetWorkManager : NSObject &lt;NSCopying&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) AFHTTPSessionManager *manager<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  单例</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return HbhNetWorkManager</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static </span>HbhNetWorkManager *<span class=\"keyword\">shareInstance </span>= nil<span class=\"comment\">;</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance&#123;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   static <span class=\"keyword\">dispatch_once_t </span>onceToken<span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"keyword\">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">shareInstance=[[HbhNetWorkManager </span>alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;)<span class=\"comment\">;</span></span><br><span class=\"line\">    return <span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从其他线程回到主线程的方法\"><a href=\"#从其他线程回到主线程的方法\" class=\"headerlink\" title=\"从其他线程回到主线程的方法\"></a>从其他线程回到主线程的方法</h3><ul>\n<li>NSThread</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Objective-C</span></span><br><span class=\"line\">[self <span class=\"string\">performSelectorOnMainThread:</span><span class=\"meta\">@selector</span>(run) <span class=\"string\">withObject:</span>nil <span class=\"string\">waitUntilDone:</span>NO];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"comment\">//swift 取消了 performSelector 方法。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Objective-C</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//Swift</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), &#123; () -&gt; Void in</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Objective-C</span><br><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span>.mainQueue().addOperationWithBlock &#123; () -&gt; Void <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的选择（更倾向于哪一种？）\"><a href=\"#多线程的选择（更倾向于哪一种？）\" class=\"headerlink\" title=\"多线程的选择（更倾向于哪一种？）\"></a>多线程的选择（更倾向于哪一种？）</h2><p>倾向于GCD</p>\n<p>因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jianshu.com/p/0b0d9b1f1f19\" target=\"_blank\" rel=\"noopener\">这里有一篇文章写的非常好，推荐。</a></p>\n"},{"title":"iOS Delegate 引发的血案","date":"2018-02-18T09:23:33.000Z","description":"优化方案：异步渲染内容到图片和按需加载内容。","toc":false,"_content":"\n今天在项目重构过程中遇到一个很神奇的 bug，和同组的小伙伴一起研究了好久终于排查出问题所在，当然大家应该已经猜到了这个问题是因为 Delegate 的使用所导致的。接下来我先简单的将这个问题描述一下\n\n## 问题描述 \n\n![](/img/iOSDelegate引发的血案.png)\n\n* 矩形框1里面的每个标签对应一个 tableView, 该 tableView 都是由同一个类实例化所得。\n* 矩形框2是一个音频播放器，初始化是在 tableView 内的，UI在 tableViewCell 内实现的一个按钮。\n* 点击矩形框2内的按钮的时候，tableViewCell 通过代理通知 tableView 执行播放器播放操作并把相关数据字典dic传递给tableView。\n* tableView 接收到代理后执行播放器的播放代理，同时会用到cell传递回来的数据\n\n操作描述\n\n* 进入到上图所示界面，默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签\n* 点击播放按钮，排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放\n\n## 代码贴出来\n```\nYDLTalkTableView.m\n\n#pragma mark - lify cycle\n#pragma mark - DFPlayer为播放器\n- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style withTab:(NSString *)tab{\n    self = [super initWithFrame:frame style:style];\n    if (self) {\n        [DFPlayer shareInstance].category = DFPlayerAudioSessionCategorySoloAmbient;\n        [DFPlayer shareInstance].playMode = DFPlayerModeOnlyOnce;\n        [DFPlayer shareInstance].isObserveWWAN = NO;\n        [DFPlayer shareInstance].dataSource = self;\n        [DFPlayer shareInstance].delegate = self;\n        [[DFPlayer shareInstance] df_audioPause];\n        self.delegate = self;\n        self.dataSource  = self;\n        if (@available(iOS 11.0, *)) {\n            UIScrollView.appearance.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;\n            self.estimatedRowHeight = 0;\n            self.estimatedSectionHeaderHeight = 0;\n            self.estimatedSectionFooterHeight = 0;\n        } else {\n            // Fallback on earlier versions\n        }\n        [self registerClass:[YDLTalkTableViewCell class] forCellReuseIdentifier:NSStringFromClass([YDLTalkTableViewCell class])];\n        [self setSeparatorStyle:UITableViewCellSeparatorStyleNone];\n        [self setBackgroundColor:kBackGroundColor];\n        self.tableFooterView = [UIView new];\n        __weak typeof(self) weakSelf = self;\n        [self loadHeaderRefreshWithHeaderRefreshingBlock:^{\n            [weakSelf onHeader];\n        }];\n        [self loadFooterRefreshWithFootRefreshingBlock:^{\n            [weakSelf onFooter];\n        }];\n    }\n    return self;\n}\n\n#pragma mark - cell的代理方法\n-(void)bofangTalk:(NSDictionary*)dict{\n    _dict = dict;//此处dict值为正常的\n    [MBProgressHUD showError:_dict[@\"expert_name\"] toView:_viewController.view];\n    [[DFPlayer shareInstance] df_reloadData];\n}\n\n#pragma mark - DFPLayer dataSource\n- (NSArray<DFPlayerModel *> *)df_playerModelArray{\n    NSLog(@\"%@\", _dict);//此处dict值为nil\n    NSMutableArray *_df_ModelArray;\n    return _df_ModelArray;\n}\n\n```\n## 问题解决\n\n我们都知道代理是属于一对一的关系，请看下面这段代码：\n\n```\n- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style withTab:(NSString *)tab{\n    self = [super initWithFrame:frame style:style];\n    if (self) {\n        [DFPlayer shareInstance].dataSource = self;\n        [DFPlayer shareInstance].delegate = self;\n}\n```\n\n当我们进入这个页面的时候首先创建的是“全部”标签下对应的tableView,这个时候播放器的代理是“全部”标签对应的tableView，当我们点击任意其他一个标签的时候，播放器的代理就会变成该标签对应的tableView，然后等我们回到“全部”标签的时候，是不会调用上面方法的，所以这个时候播放器的代理其实还是我们上次点击的标签所对应的tableView。所以我们就可以理解为什么执行cell的delegate的时候dict的值是正常的，而到执行播放器代理的时候dict的值就变为了nil了。\n\n\n为什么会出现这种情况呢，有些人可能会说了：我平时这么写也没发现有问题啊。这就是我们这个案例特殊的一点，因为我们的播放器是通过单例来创建的，也就是说全局只会存在着一个实例，那么他的代理也应该是只对应一个的，以最后一个设置的为准，如果在上面的方法中我们的播放器通过[[DFPlayer alloc] init]来创建的话，那就没有问题了\n\n## 总结\n\n遇到问题很兴奋，解决问题更兴奋。\n\n首先遇到 bug 不要慌，是时候展现自己真正的技术了（简单的排查思路）\n\n* 解决问题一定要思路清晰，先根据 bug 现象判断出问题的大体可能，然后验证你的假想（我的项目播放是利用代理来回传进行播放的，所以大致定位到 delegate 出现相关问题）\n* 然后用自己的经验和掌握的技能（断点、排除法、逐步分析法等等）找到出现问题的具体代码行（一顿操作操作排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放）\n* 最后分析导致问题的可能，逐步更正（这里是有必要联系场景分析的）\n\n默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签出现问题，综上\n\n* 你可能就会想到，标签切换回来的时候代理失效了（想的不错，当然需要一些时间）\n* 思考代理为什么会失效？（找到关键了，让代理不失效就ok了）\n* 思考怎么让代理不失效？（又找到关键了，发现在标签切换的时候代理指向别处了，结合代理一对一的特性）\n* 思考怎么将代理重新指向当前控制器（哎呀，又想到关键了，在播放事件中重新改变代理的指向而不是之前的在初始化时指向代理）\n* 问题解决，完美\n\n以此篇记录关于 delegate（设置单例的代理）引发的 bug\n\n\n\n","source":"_posts/iOS Delegate 引发的血案.md","raw":"---\ntitle: iOS Delegate 引发的血案\ndate: 2018-2-18 17:23:33\n\ndescription: 优化方案：异步渲染内容到图片和按需加载内容。\n\ncategories: 问题记录\ntags: [Objective-C]\ntoc: false \n---\n\n今天在项目重构过程中遇到一个很神奇的 bug，和同组的小伙伴一起研究了好久终于排查出问题所在，当然大家应该已经猜到了这个问题是因为 Delegate 的使用所导致的。接下来我先简单的将这个问题描述一下\n\n## 问题描述 \n\n![](/img/iOSDelegate引发的血案.png)\n\n* 矩形框1里面的每个标签对应一个 tableView, 该 tableView 都是由同一个类实例化所得。\n* 矩形框2是一个音频播放器，初始化是在 tableView 内的，UI在 tableViewCell 内实现的一个按钮。\n* 点击矩形框2内的按钮的时候，tableViewCell 通过代理通知 tableView 执行播放器播放操作并把相关数据字典dic传递给tableView。\n* tableView 接收到代理后执行播放器的播放代理，同时会用到cell传递回来的数据\n\n操作描述\n\n* 进入到上图所示界面，默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签\n* 点击播放按钮，排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放\n\n## 代码贴出来\n```\nYDLTalkTableView.m\n\n#pragma mark - lify cycle\n#pragma mark - DFPlayer为播放器\n- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style withTab:(NSString *)tab{\n    self = [super initWithFrame:frame style:style];\n    if (self) {\n        [DFPlayer shareInstance].category = DFPlayerAudioSessionCategorySoloAmbient;\n        [DFPlayer shareInstance].playMode = DFPlayerModeOnlyOnce;\n        [DFPlayer shareInstance].isObserveWWAN = NO;\n        [DFPlayer shareInstance].dataSource = self;\n        [DFPlayer shareInstance].delegate = self;\n        [[DFPlayer shareInstance] df_audioPause];\n        self.delegate = self;\n        self.dataSource  = self;\n        if (@available(iOS 11.0, *)) {\n            UIScrollView.appearance.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;\n            self.estimatedRowHeight = 0;\n            self.estimatedSectionHeaderHeight = 0;\n            self.estimatedSectionFooterHeight = 0;\n        } else {\n            // Fallback on earlier versions\n        }\n        [self registerClass:[YDLTalkTableViewCell class] forCellReuseIdentifier:NSStringFromClass([YDLTalkTableViewCell class])];\n        [self setSeparatorStyle:UITableViewCellSeparatorStyleNone];\n        [self setBackgroundColor:kBackGroundColor];\n        self.tableFooterView = [UIView new];\n        __weak typeof(self) weakSelf = self;\n        [self loadHeaderRefreshWithHeaderRefreshingBlock:^{\n            [weakSelf onHeader];\n        }];\n        [self loadFooterRefreshWithFootRefreshingBlock:^{\n            [weakSelf onFooter];\n        }];\n    }\n    return self;\n}\n\n#pragma mark - cell的代理方法\n-(void)bofangTalk:(NSDictionary*)dict{\n    _dict = dict;//此处dict值为正常的\n    [MBProgressHUD showError:_dict[@\"expert_name\"] toView:_viewController.view];\n    [[DFPlayer shareInstance] df_reloadData];\n}\n\n#pragma mark - DFPLayer dataSource\n- (NSArray<DFPlayerModel *> *)df_playerModelArray{\n    NSLog(@\"%@\", _dict);//此处dict值为nil\n    NSMutableArray *_df_ModelArray;\n    return _df_ModelArray;\n}\n\n```\n## 问题解决\n\n我们都知道代理是属于一对一的关系，请看下面这段代码：\n\n```\n- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style withTab:(NSString *)tab{\n    self = [super initWithFrame:frame style:style];\n    if (self) {\n        [DFPlayer shareInstance].dataSource = self;\n        [DFPlayer shareInstance].delegate = self;\n}\n```\n\n当我们进入这个页面的时候首先创建的是“全部”标签下对应的tableView,这个时候播放器的代理是“全部”标签对应的tableView，当我们点击任意其他一个标签的时候，播放器的代理就会变成该标签对应的tableView，然后等我们回到“全部”标签的时候，是不会调用上面方法的，所以这个时候播放器的代理其实还是我们上次点击的标签所对应的tableView。所以我们就可以理解为什么执行cell的delegate的时候dict的值是正常的，而到执行播放器代理的时候dict的值就变为了nil了。\n\n\n为什么会出现这种情况呢，有些人可能会说了：我平时这么写也没发现有问题啊。这就是我们这个案例特殊的一点，因为我们的播放器是通过单例来创建的，也就是说全局只会存在着一个实例，那么他的代理也应该是只对应一个的，以最后一个设置的为准，如果在上面的方法中我们的播放器通过[[DFPlayer alloc] init]来创建的话，那就没有问题了\n\n## 总结\n\n遇到问题很兴奋，解决问题更兴奋。\n\n首先遇到 bug 不要慌，是时候展现自己真正的技术了（简单的排查思路）\n\n* 解决问题一定要思路清晰，先根据 bug 现象判断出问题的大体可能，然后验证你的假想（我的项目播放是利用代理来回传进行播放的，所以大致定位到 delegate 出现相关问题）\n* 然后用自己的经验和掌握的技能（断点、排除法、逐步分析法等等）找到出现问题的具体代码行（一顿操作操作排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放）\n* 最后分析导致问题的可能，逐步更正（这里是有必要联系场景分析的）\n\n默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签出现问题，综上\n\n* 你可能就会想到，标签切换回来的时候代理失效了（想的不错，当然需要一些时间）\n* 思考代理为什么会失效？（找到关键了，让代理不失效就ok了）\n* 思考怎么让代理不失效？（又找到关键了，发现在标签切换的时候代理指向别处了，结合代理一对一的特性）\n* 思考怎么将代理重新指向当前控制器（哎呀，又想到关键了，在播放事件中重新改变代理的指向而不是之前的在初始化时指向代理）\n* 问题解决，完美\n\n以此篇记录关于 delegate（设置单例的代理）引发的 bug\n\n\n\n","slug":"iOS Delegate 引发的血案","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6gc5002a66r2sruty54q","content":"<p>今天在项目重构过程中遇到一个很神奇的 bug，和同组的小伙伴一起研究了好久终于排查出问题所在，当然大家应该已经猜到了这个问题是因为 Delegate 的使用所导致的。接下来我先简单的将这个问题描述一下</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><img src=\"/img/iOSDelegate引发的血案.png\" alt=\"\"></p>\n<ul>\n<li>矩形框1里面的每个标签对应一个 tableView, 该 tableView 都是由同一个类实例化所得。</li>\n<li>矩形框2是一个音频播放器，初始化是在 tableView 内的，UI在 tableViewCell 内实现的一个按钮。</li>\n<li>点击矩形框2内的按钮的时候，tableViewCell 通过代理通知 tableView 执行播放器播放操作并把相关数据字典dic传递给tableView。</li>\n<li>tableView 接收到代理后执行播放器的播放代理，同时会用到cell传递回来的数据</li>\n</ul>\n<p>操作描述</p>\n<ul>\n<li>进入到上图所示界面，默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签</li>\n<li>点击播放按钮，排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放</li>\n</ul>\n<h2 id=\"代码贴出来\"><a href=\"#代码贴出来\" class=\"headerlink\" title=\"代码贴出来\"></a>代码贴出来</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YDLTalkTableView.m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - lify cycle</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - DFPlayer为播放器</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame style:(<span class=\"built_in\">UITableViewStyle</span>)style withTab:(<span class=\"built_in\">NSString</span> *)tab&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame style:style];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        [DFPlayer shareInstance].category = DFPlayerAudioSessionCategorySoloAmbient;</span><br><span class=\"line\">        [DFPlayer shareInstance].playMode = DFPlayerModeOnlyOnce;</span><br><span class=\"line\">        [DFPlayer shareInstance].isObserveWWAN = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        [DFPlayer shareInstance].dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [DFPlayer shareInstance].delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [[DFPlayer shareInstance] df_audioPause];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.dataSource  = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (@available(iOS <span class=\"number\">11.0</span>, *)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">UIScrollView</span>.appearance.contentInsetAdjustmentBehavior = <span class=\"built_in\">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.estimatedRowHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.estimatedSectionHeaderHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.estimatedSectionFooterHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Fallback on earlier versions</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> registerClass:[YDLTalkTableViewCell <span class=\"keyword\">class</span>] forCellReuseIdentifier:<span class=\"built_in\">NSStringFromClass</span>([YDLTalkTableViewCell <span class=\"keyword\">class</span>])];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setSeparatorStyle:<span class=\"built_in\">UITableViewCellSeparatorStyleNone</span>];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setBackgroundColor:kBackGroundColor];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tableFooterView = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">        __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> loadHeaderRefreshWithHeaderRefreshingBlock:^&#123;</span><br><span class=\"line\">            [weakSelf onHeader];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> loadFooterRefreshWithFootRefreshingBlock:^&#123;</span><br><span class=\"line\">            [weakSelf onFooter];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - cell的代理方法</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)bofangTalk:(<span class=\"built_in\">NSDictionary</span>*)dict&#123;</span><br><span class=\"line\">    _dict = dict;<span class=\"comment\">//此处dict值为正常的</span></span><br><span class=\"line\">    [MBProgressHUD showError:_dict[<span class=\"string\">@\"expert_name\"</span>] toView:_viewController.view];</span><br><span class=\"line\">    [[DFPlayer shareInstance] df_reloadData];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - DFPLayer dataSource</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;DFPlayerModel *&gt; *)df_playerModelArray&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, _dict);<span class=\"comment\">//此处dict值为nil</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *_df_ModelArray;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _df_ModelArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>我们都知道代理是属于一对一的关系，请看下面这段代码：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instance<span class=\"keyword\">type</span>)initWithFrame:(<span class=\"type\">CGRect</span>)frame style:(<span class=\"type\">UITableViewStyle</span>)style withTab:(<span class=\"type\">NSString</span> *)tab&#123;</span><br><span class=\"line\">    self = [super initWithFrame:frame style:style];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        [<span class=\"type\">DFPlayer</span> shareInstance].dataSource = self;</span><br><span class=\"line\">        [<span class=\"type\">DFPlayer</span> shareInstance].delegate = self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们进入这个页面的时候首先创建的是“全部”标签下对应的tableView,这个时候播放器的代理是“全部”标签对应的tableView，当我们点击任意其他一个标签的时候，播放器的代理就会变成该标签对应的tableView，然后等我们回到“全部”标签的时候，是不会调用上面方法的，所以这个时候播放器的代理其实还是我们上次点击的标签所对应的tableView。所以我们就可以理解为什么执行cell的delegate的时候dict的值是正常的，而到执行播放器代理的时候dict的值就变为了nil了。</p>\n<p>为什么会出现这种情况呢，有些人可能会说了：我平时这么写也没发现有问题啊。这就是我们这个案例特殊的一点，因为我们的播放器是通过单例来创建的，也就是说全局只会存在着一个实例，那么他的代理也应该是只对应一个的，以最后一个设置的为准，如果在上面的方法中我们的播放器通过[[DFPlayer alloc] init]来创建的话，那就没有问题了</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>遇到问题很兴奋，解决问题更兴奋。</p>\n<p>首先遇到 bug 不要慌，是时候展现自己真正的技术了（简单的排查思路）</p>\n<ul>\n<li>解决问题一定要思路清晰，先根据 bug 现象判断出问题的大体可能，然后验证你的假想（我的项目播放是利用代理来回传进行播放的，所以大致定位到 delegate 出现相关问题）</li>\n<li>然后用自己的经验和掌握的技能（断点、排除法、逐步分析法等等）找到出现问题的具体代码行（一顿操作操作排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放）</li>\n<li>最后分析导致问题的可能，逐步更正（这里是有必要联系场景分析的）</li>\n</ul>\n<p>默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签出现问题，综上</p>\n<ul>\n<li>你可能就会想到，标签切换回来的时候代理失效了（想的不错，当然需要一些时间）</li>\n<li>思考代理为什么会失效？（找到关键了，让代理不失效就ok了）</li>\n<li>思考怎么让代理不失效？（又找到关键了，发现在标签切换的时候代理指向别处了，结合代理一对一的特性）</li>\n<li>思考怎么将代理重新指向当前控制器（哎呀，又想到关键了，在播放事件中重新改变代理的指向而不是之前的在初始化时指向代理）</li>\n<li>问题解决，完美</li>\n</ul>\n<p>以此篇记录关于 delegate（设置单例的代理）引发的 bug</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在项目重构过程中遇到一个很神奇的 bug，和同组的小伙伴一起研究了好久终于排查出问题所在，当然大家应该已经猜到了这个问题是因为 Delegate 的使用所导致的。接下来我先简单的将这个问题描述一下</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p><img src=\"/img/iOSDelegate引发的血案.png\" alt=\"\"></p>\n<ul>\n<li>矩形框1里面的每个标签对应一个 tableView, 该 tableView 都是由同一个类实例化所得。</li>\n<li>矩形框2是一个音频播放器，初始化是在 tableView 内的，UI在 tableViewCell 内实现的一个按钮。</li>\n<li>点击矩形框2内的按钮的时候，tableViewCell 通过代理通知 tableView 执行播放器播放操作并把相关数据字典dic传递给tableView。</li>\n<li>tableView 接收到代理后执行播放器的播放代理，同时会用到cell传递回来的数据</li>\n</ul>\n<p>操作描述</p>\n<ul>\n<li>进入到上图所示界面，默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签</li>\n<li>点击播放按钮，排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放</li>\n</ul>\n<h2 id=\"代码贴出来\"><a href=\"#代码贴出来\" class=\"headerlink\" title=\"代码贴出来\"></a>代码贴出来</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YDLTalkTableView.m</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - lify cycle</span></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - DFPlayer为播放器</span></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithFrame:(<span class=\"built_in\">CGRect</span>)frame style:(<span class=\"built_in\">UITableViewStyle</span>)style withTab:(<span class=\"built_in\">NSString</span> *)tab&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithFrame:frame style:style];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        [DFPlayer shareInstance].category = DFPlayerAudioSessionCategorySoloAmbient;</span><br><span class=\"line\">        [DFPlayer shareInstance].playMode = DFPlayerModeOnlyOnce;</span><br><span class=\"line\">        [DFPlayer shareInstance].isObserveWWAN = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        [DFPlayer shareInstance].dataSource = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [DFPlayer shareInstance].delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [[DFPlayer shareInstance] df_audioPause];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.dataSource  = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (@available(iOS <span class=\"number\">11.0</span>, *)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">UIScrollView</span>.appearance.contentInsetAdjustmentBehavior = <span class=\"built_in\">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.estimatedRowHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.estimatedSectionHeaderHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.estimatedSectionFooterHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Fallback on earlier versions</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> registerClass:[YDLTalkTableViewCell <span class=\"keyword\">class</span>] forCellReuseIdentifier:<span class=\"built_in\">NSStringFromClass</span>([YDLTalkTableViewCell <span class=\"keyword\">class</span>])];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setSeparatorStyle:<span class=\"built_in\">UITableViewCellSeparatorStyleNone</span>];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> setBackgroundColor:kBackGroundColor];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tableFooterView = [<span class=\"built_in\">UIView</span> new];</span><br><span class=\"line\">        __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> loadHeaderRefreshWithHeaderRefreshingBlock:^&#123;</span><br><span class=\"line\">            [weakSelf onHeader];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> loadFooterRefreshWithFootRefreshingBlock:^&#123;</span><br><span class=\"line\">            [weakSelf onFooter];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - cell的代理方法</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)bofangTalk:(<span class=\"built_in\">NSDictionary</span>*)dict&#123;</span><br><span class=\"line\">    _dict = dict;<span class=\"comment\">//此处dict值为正常的</span></span><br><span class=\"line\">    [MBProgressHUD showError:_dict[<span class=\"string\">@\"expert_name\"</span>] toView:_viewController.view];</span><br><span class=\"line\">    [[DFPlayer shareInstance] df_reloadData];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#pragma mark - DFPLayer dataSource</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span>&lt;DFPlayerModel *&gt; *)df_playerModelArray&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, _dict);<span class=\"comment\">//此处dict值为nil</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *_df_ModelArray;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _df_ModelArray;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><p>我们都知道代理是属于一对一的关系，请看下面这段代码：</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instance<span class=\"keyword\">type</span>)initWithFrame:(<span class=\"type\">CGRect</span>)frame style:(<span class=\"type\">UITableViewStyle</span>)style withTab:(<span class=\"type\">NSString</span> *)tab&#123;</span><br><span class=\"line\">    self = [super initWithFrame:frame style:style];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        [<span class=\"type\">DFPlayer</span> shareInstance].dataSource = self;</span><br><span class=\"line\">        [<span class=\"type\">DFPlayer</span> shareInstance].delegate = self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当我们进入这个页面的时候首先创建的是“全部”标签下对应的tableView,这个时候播放器的代理是“全部”标签对应的tableView，当我们点击任意其他一个标签的时候，播放器的代理就会变成该标签对应的tableView，然后等我们回到“全部”标签的时候，是不会调用上面方法的，所以这个时候播放器的代理其实还是我们上次点击的标签所对应的tableView。所以我们就可以理解为什么执行cell的delegate的时候dict的值是正常的，而到执行播放器代理的时候dict的值就变为了nil了。</p>\n<p>为什么会出现这种情况呢，有些人可能会说了：我平时这么写也没发现有问题啊。这就是我们这个案例特殊的一点，因为我们的播放器是通过单例来创建的，也就是说全局只会存在着一个实例，那么他的代理也应该是只对应一个的，以最后一个设置的为准，如果在上面的方法中我们的播放器通过[[DFPlayer alloc] init]来创建的话，那就没有问题了</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>遇到问题很兴奋，解决问题更兴奋。</p>\n<p>首先遇到 bug 不要慌，是时候展现自己真正的技术了（简单的排查思路）</p>\n<ul>\n<li>解决问题一定要思路清晰，先根据 bug 现象判断出问题的大体可能，然后验证你的假想（我的项目播放是利用代理来回传进行播放的，所以大致定位到 delegate 出现相关问题）</li>\n<li>然后用自己的经验和掌握的技能（断点、排除法、逐步分析法等等）找到出现问题的具体代码行（一顿操作操作排查到 tableView 中 cell 的代理内数据dic值正常，播放器代理中数据dic值为空，导致无法播放）</li>\n<li>最后分析导致问题的可能，逐步更正（这里是有必要联系场景分析的）</li>\n</ul>\n<p>默认选中的是全部标签，直接点击其余任意一个标签，然后再切换回到全部标签出现问题，综上</p>\n<ul>\n<li>你可能就会想到，标签切换回来的时候代理失效了（想的不错，当然需要一些时间）</li>\n<li>思考代理为什么会失效？（找到关键了，让代理不失效就ok了）</li>\n<li>思考怎么让代理不失效？（又找到关键了，发现在标签切换的时候代理指向别处了，结合代理一对一的特性）</li>\n<li>思考怎么将代理重新指向当前控制器（哎呀，又想到关键了，在播放事件中重新改变代理的指向而不是之前的在初始化时指向代理）</li>\n<li>问题解决，完美</li>\n</ul>\n<p>以此篇记录关于 delegate（设置单例的代理）引发的 bug</p>\n"},{"title":"UI视图--离屏渲染","date":"2018-04-16T05:11:19.000Z","description":"离屏渲染","_content":"***\n[UI视图--图像显示原理与卡顿&掉帧](https://xiaopengmonsters.github.io/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&%E6%8E%89%E5%B8%A7/)\n[UI视图--UI绘制原理&异步绘制](https://xiaopengmonsters.github.io/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/)\n[UI视图--离屏渲染](https://xiaopengmonsters.github.io/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/)\n***\n\n#### 离屏渲染\n\n* On-Screen Rendering ：意为当前屏幕渲染，指的是 GPU 的渲染操作是在当期用于显示的屏幕缓冲区进行的\n\n* Off-Screen Rendering ：意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓存区进行渲染操作\n\n#### 何时触发\n\n* 圆角（当和 makeToBounds 一起使用时）\n\n* 图层蒙版\n\n* 阴影\n\n* 光栅化\n\n* 光栅化（Rasterization）是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。（应用：较为广泛的应用于深度学习卷积神经网络的结构中）\n\n#### 为何要避免离屏渲染\n\n* 创建新的渲染缓冲区\n\n* 上下文切换\n\n离屏渲染是发生在 GPU 层面上的，由于离屏渲染使 GPU 层面上面触发了 openGL 的多通道渲染管线，产生了额外的开销\n\n在触发离屏渲染的时候，会增加 GPU 的工作量，GPU 的工作量的增加很有可能导致 CPU 和 GPU 工作的总耗时超出了 16.7 毫秒，那么可能就会导致UI的卡顿和掉帧\n\n离屏渲染会创建新的渲染缓冲区，导致内存上的开销，有多通道渲染管线，最终要把多通道的渲染结果进行合成，所有会有上下文的切换，就有 GPU 的额外开销，那么可能就会导致 UI 的卡顿和掉帧\n","source":"_posts/UI视图--离屏渲染.md","raw":"---\ntitle: UI视图--离屏渲染\ndate: 2018-04-16 13:11:19\ndescription: 离屏渲染\ncategories: UI视图\ntags: [Objective-C]\n---\n***\n[UI视图--图像显示原理与卡顿&掉帧](https://xiaopengmonsters.github.io/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&%E6%8E%89%E5%B8%A7/)\n[UI视图--UI绘制原理&异步绘制](https://xiaopengmonsters.github.io/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/)\n[UI视图--离屏渲染](https://xiaopengmonsters.github.io/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/)\n***\n\n#### 离屏渲染\n\n* On-Screen Rendering ：意为当前屏幕渲染，指的是 GPU 的渲染操作是在当期用于显示的屏幕缓冲区进行的\n\n* Off-Screen Rendering ：意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓存区进行渲染操作\n\n#### 何时触发\n\n* 圆角（当和 makeToBounds 一起使用时）\n\n* 图层蒙版\n\n* 阴影\n\n* 光栅化\n\n* 光栅化（Rasterization）是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。（应用：较为广泛的应用于深度学习卷积神经网络的结构中）\n\n#### 为何要避免离屏渲染\n\n* 创建新的渲染缓冲区\n\n* 上下文切换\n\n离屏渲染是发生在 GPU 层面上的，由于离屏渲染使 GPU 层面上面触发了 openGL 的多通道渲染管线，产生了额外的开销\n\n在触发离屏渲染的时候，会增加 GPU 的工作量，GPU 的工作量的增加很有可能导致 CPU 和 GPU 工作的总耗时超出了 16.7 毫秒，那么可能就会导致UI的卡顿和掉帧\n\n离屏渲染会创建新的渲染缓冲区，导致内存上的开销，有多通道渲染管线，最终要把多通道的渲染结果进行合成，所有会有上下文的切换，就有 GPU 的额外开销，那么可能就会导致 UI 的卡顿和掉帧\n","slug":"UI视图--离屏渲染","published":1,"updated":"2018-08-31T03:52:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6gc7002c66r2bkrim5vr","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&amp;%E6%8E%89%E5%B8%A7/\" target=\"_blank\" rel=\"noopener\">UI视图–图像显示原理与卡顿&amp;掉帧</a><br><a href=\"https://xiaopengmonsters.github.io/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&amp;%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">UI视图–UI绘制原理&amp;异步绘制</a><br><a href=\"https://xiaopengmonsters.github.io/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/\" target=\"_blank\" rel=\"noopener\">UI视图–离屏渲染</a></p>\n<hr>\n<h4 id=\"离屏渲染\"><a href=\"#离屏渲染\" class=\"headerlink\" title=\"离屏渲染\"></a>离屏渲染</h4><ul>\n<li><p>On-Screen Rendering ：意为当前屏幕渲染，指的是 GPU 的渲染操作是在当期用于显示的屏幕缓冲区进行的</p>\n</li>\n<li><p>Off-Screen Rendering ：意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓存区进行渲染操作</p>\n</li>\n</ul>\n<h4 id=\"何时触发\"><a href=\"#何时触发\" class=\"headerlink\" title=\"何时触发\"></a>何时触发</h4><ul>\n<li><p>圆角（当和 makeToBounds 一起使用时）</p>\n</li>\n<li><p>图层蒙版</p>\n</li>\n<li><p>阴影</p>\n</li>\n<li><p>光栅化</p>\n</li>\n<li><p>光栅化（Rasterization）是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。（应用：较为广泛的应用于深度学习卷积神经网络的结构中）</p>\n</li>\n</ul>\n<h4 id=\"为何要避免离屏渲染\"><a href=\"#为何要避免离屏渲染\" class=\"headerlink\" title=\"为何要避免离屏渲染\"></a>为何要避免离屏渲染</h4><ul>\n<li><p>创建新的渲染缓冲区</p>\n</li>\n<li><p>上下文切换</p>\n</li>\n</ul>\n<p>离屏渲染是发生在 GPU 层面上的，由于离屏渲染使 GPU 层面上面触发了 openGL 的多通道渲染管线，产生了额外的开销</p>\n<p>在触发离屏渲染的时候，会增加 GPU 的工作量，GPU 的工作量的增加很有可能导致 CPU 和 GPU 工作的总耗时超出了 16.7 毫秒，那么可能就会导致UI的卡顿和掉帧</p>\n<p>离屏渲染会创建新的渲染缓冲区，导致内存上的开销，有多通道渲染管线，最终要把多通道的渲染结果进行合成，所有会有上下文的切换，就有 GPU 的额外开销，那么可能就会导致 UI 的卡顿和掉帧</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/04/05/UI%E8%A7%86%E5%9B%BE--%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8D%A1%E9%A1%BF&amp;%E6%8E%89%E5%B8%A7/\" target=\"_blank\" rel=\"noopener\">UI视图–图像显示原理与卡顿&amp;掉帧</a><br><a href=\"https://xiaopengmonsters.github.io/2018/04/13/UI%E8%A7%86%E5%9B%BE--UI%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86&amp;%E5%BC%82%E6%AD%A5%E7%BB%98%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">UI视图–UI绘制原理&amp;异步绘制</a><br><a href=\"https://xiaopengmonsters.github.io/2018/04/16/UI%E8%A7%86%E5%9B%BE--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/\" target=\"_blank\" rel=\"noopener\">UI视图–离屏渲染</a></p>\n<hr>\n<h4 id=\"离屏渲染\"><a href=\"#离屏渲染\" class=\"headerlink\" title=\"离屏渲染\"></a>离屏渲染</h4><ul>\n<li><p>On-Screen Rendering ：意为当前屏幕渲染，指的是 GPU 的渲染操作是在当期用于显示的屏幕缓冲区进行的</p>\n</li>\n<li><p>Off-Screen Rendering ：意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓存区进行渲染操作</p>\n</li>\n</ul>\n<h4 id=\"何时触发\"><a href=\"#何时触发\" class=\"headerlink\" title=\"何时触发\"></a>何时触发</h4><ul>\n<li><p>圆角（当和 makeToBounds 一起使用时）</p>\n</li>\n<li><p>图层蒙版</p>\n</li>\n<li><p>阴影</p>\n</li>\n<li><p>光栅化</p>\n</li>\n<li><p>光栅化（Rasterization）是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。（应用：较为广泛的应用于深度学习卷积神经网络的结构中）</p>\n</li>\n</ul>\n<h4 id=\"为何要避免离屏渲染\"><a href=\"#为何要避免离屏渲染\" class=\"headerlink\" title=\"为何要避免离屏渲染\"></a>为何要避免离屏渲染</h4><ul>\n<li><p>创建新的渲染缓冲区</p>\n</li>\n<li><p>上下文切换</p>\n</li>\n</ul>\n<p>离屏渲染是发生在 GPU 层面上的，由于离屏渲染使 GPU 层面上面触发了 openGL 的多通道渲染管线，产生了额外的开销</p>\n<p>在触发离屏渲染的时候，会增加 GPU 的工作量，GPU 的工作量的增加很有可能导致 CPU 和 GPU 工作的总耗时超出了 16.7 毫秒，那么可能就会导致UI的卡顿和掉帧</p>\n<p>离屏渲染会创建新的渲染缓冲区，导致内存上的开销，有多通道渲染管线，最终要把多通道的渲染结果进行合成，所有会有上下文的切换，就有 GPU 的额外开销，那么可能就会导致 UI 的卡顿和掉帧</p>\n"},{"title":"UITableView的优化","date":"2017-12-26T09:23:33.000Z","description":"UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。","toc":false,"_content":"\n***\n[UITableView的优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)\n[UITableView的优化进阶篇](https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/)\n[APP的优化](https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/)\n***\n\nUITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\n那么优化就势在必得。。。\n\n## 在优化之前 \n\n### UITableView的cell重用机制\n\nUITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。\n\n简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。\n\n这种机制下系统默认有一个可变数组`NSMutableArray *visiableCells`，用来保存当前显示的cell。一个可变字典`NSMutableDictnery *reusableTableCells`，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。\n\n\n### UITableView的代理方法\n\n 必须实现的两个数据源回调方法:\n\n```\n/** 返回每个分区的行数 */\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\n\n调用最频繁的两个回调方法：\n\n```\n/** 返回cell的高度 */\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\nUITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。\n\n因此，优化UITableView的首要任务就是优化上面这两个回调方法。\n\n## 优化\n\n### 1. Cell重用\n\n**数据源优化方案：**首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：\n\n```\n//调用次数太多，static 保证只创建一次reuseID，提高性能\nstatic NSString *reuseID = “reuseCellID”;\n```\n```\n//缓存池中取已经创建的cell\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];\n```\n\n\n**缓存池的实现：**当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。\n\n### 2. 提前计算并缓存Cell的高度\n\n调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。\n\n* UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。\n\n* 滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell\n\n**方案：**创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。\n\n**示例：**如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）\n\n```\n/**\n *  根据纳信模型数组 转成 纳信frame模型数据\n *\n *  @param statuses 纳信模型数组\n *\n */\n- (NSArray *)statusFramesWithStatuses:(NSArray *)statuses\n{\n    NSMutableArray *frames = [NSMutableArray array];\n    for (NXStatusModel *status in statuses) {\n        NXStatusFrame *frame = [[NXStatusFrame alloc] init];\n        // 传递纳信模型数据，计算所有子控件的frame\n        frame.isMask = NO;\n        frame.status = status;\n        [frames addObject:frame];\n    }\n    return frames;\n}\n```\n\n### 3. 避免cell的重新布局\n\ncell的布局填充等操作 比较耗时，一般创建时就布局好，\n如可以将cell单独放到一个自定义类，初始化时就布局好。\n\n* 尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。\n\n* 只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。\n\n### 4. 滑动时，按需加载\n\n开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。\n\n```\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n```\n\n思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。\n\n```\n//获取可见部分的Cell\nNSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];\n        for (NSIndexPath *indexPath in visiblePaths)\n        {\n        //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载\n             <code>\n        }\n```\n\n记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：\n\n```\n// tableView 停止滑动的时候异步加载图片\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n         if (self.tableView.dragging == NO && self.tableView.decelerating == NO)\n            {\n               //开始异步加载图片\n                <code>\n            }\n```\n    \n### 5. 渲染\n\n不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长\n\n**1、**减少subviews的个数和层级\n \n 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示\n\n**2、**少用subviews的透明图层\n\n 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）\n\n**3、**避免CALayer特效（shadowPath）\n\n给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：\n\n```\nview.layer.shadowColor = color.CGColor;\nview.layer.shadowOffset = offset;\nview.layer.shadowOpacity = 1;\nview.layer.shadowRadius = radius;\n```\n\n### 6. 使用局部更新\n如果只是更新某组的话，使用reloadSection进行局部更新\n\n\n## 总结\n\n[这里](http://www.cocoachina.com/ios/20150602/11968.html)有位大佬，可以去看看哦\n\n UITableView的优化主要从三个方面入手:\n\n* 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；\n* 滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage\n* 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）\n\n除了上面最主要的三个方面外，还有很多熟知的优化点：\n\n* 正确使用reuseIdentifier来重用Cells\n* 尽量使所有的view opaque，包括Cell自身\n* 尽量少用或不用透明图层\n* 如果Cell内现实的内容来自web，使用异步加载，缓存请求结果\n* 减少subviews的数量\n* 在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果\n* 尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示\n\n### 文章链接\n\n[优化UITableViewCell高度计算的那些事](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)\n\n[UITableView优化技巧](http://www.cocoachina.com/ios/20150602/11968.html)\n\n[UITableView性能优化](http://blog.csdn.net/u011452278/article/details/60961350)\n\n\n","source":"_posts/UITableView的优化.md","raw":"---\ntitle: UITableView的优化\ndate: 2017-12-26 17:23:33\n\ndescription: UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\ncategories: [性能优化]\ntags: [Objective-C]\ntoc: false \n---\n\n***\n[UITableView的优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)\n[UITableView的优化进阶篇](https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/)\n[APP的优化](https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/)\n***\n\nUITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\n那么优化就势在必得。。。\n\n## 在优化之前 \n\n### UITableView的cell重用机制\n\nUITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。\n\n简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。\n\n这种机制下系统默认有一个可变数组`NSMutableArray *visiableCells`，用来保存当前显示的cell。一个可变字典`NSMutableDictnery *reusableTableCells`，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。\n\n\n### UITableView的代理方法\n\n 必须实现的两个数据源回调方法:\n\n```\n/** 返回每个分区的行数 */\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\n\n调用最频繁的两个回调方法：\n\n```\n/** 返回cell的高度 */\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\nUITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。\n\n因此，优化UITableView的首要任务就是优化上面这两个回调方法。\n\n## 优化\n\n### 1. Cell重用\n\n**数据源优化方案：**首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：\n\n```\n//调用次数太多，static 保证只创建一次reuseID，提高性能\nstatic NSString *reuseID = “reuseCellID”;\n```\n```\n//缓存池中取已经创建的cell\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];\n```\n\n\n**缓存池的实现：**当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。\n\n### 2. 提前计算并缓存Cell的高度\n\n调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。\n\n* UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。\n\n* 滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell\n\n**方案：**创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。\n\n**示例：**如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）\n\n```\n/**\n *  根据纳信模型数组 转成 纳信frame模型数据\n *\n *  @param statuses 纳信模型数组\n *\n */\n- (NSArray *)statusFramesWithStatuses:(NSArray *)statuses\n{\n    NSMutableArray *frames = [NSMutableArray array];\n    for (NXStatusModel *status in statuses) {\n        NXStatusFrame *frame = [[NXStatusFrame alloc] init];\n        // 传递纳信模型数据，计算所有子控件的frame\n        frame.isMask = NO;\n        frame.status = status;\n        [frames addObject:frame];\n    }\n    return frames;\n}\n```\n\n### 3. 避免cell的重新布局\n\ncell的布局填充等操作 比较耗时，一般创建时就布局好，\n如可以将cell单独放到一个自定义类，初始化时就布局好。\n\n* 尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。\n\n* 只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。\n\n### 4. 滑动时，按需加载\n\n开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。\n\n```\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n```\n\n思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。\n\n```\n//获取可见部分的Cell\nNSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];\n        for (NSIndexPath *indexPath in visiblePaths)\n        {\n        //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载\n             <code>\n        }\n```\n\n记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：\n\n```\n// tableView 停止滑动的时候异步加载图片\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n         if (self.tableView.dragging == NO && self.tableView.decelerating == NO)\n            {\n               //开始异步加载图片\n                <code>\n            }\n```\n    \n### 5. 渲染\n\n不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长\n\n**1、**减少subviews的个数和层级\n \n 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示\n\n**2、**少用subviews的透明图层\n\n 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）\n\n**3、**避免CALayer特效（shadowPath）\n\n给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：\n\n```\nview.layer.shadowColor = color.CGColor;\nview.layer.shadowOffset = offset;\nview.layer.shadowOpacity = 1;\nview.layer.shadowRadius = radius;\n```\n\n### 6. 使用局部更新\n如果只是更新某组的话，使用reloadSection进行局部更新\n\n\n## 总结\n\n[这里](http://www.cocoachina.com/ios/20150602/11968.html)有位大佬，可以去看看哦\n\n UITableView的优化主要从三个方面入手:\n\n* 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；\n* 滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage\n* 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）\n\n除了上面最主要的三个方面外，还有很多熟知的优化点：\n\n* 正确使用reuseIdentifier来重用Cells\n* 尽量使所有的view opaque，包括Cell自身\n* 尽量少用或不用透明图层\n* 如果Cell内现实的内容来自web，使用异步加载，缓存请求结果\n* 减少subviews的数量\n* 在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果\n* 尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示\n\n### 文章链接\n\n[优化UITableViewCell高度计算的那些事](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)\n\n[UITableView优化技巧](http://www.cocoachina.com/ios/20150602/11968.html)\n\n[UITableView性能优化](http://blog.csdn.net/u011452278/article/details/60961350)\n\n\n","slug":"UITableView的优化","published":1,"updated":"2018-08-31T03:51:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6gc9002f66r2nqvk0pgs","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">UITableView的优化进阶篇</a><br><a href=\"https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">APP的优化</a></p>\n<hr>\n<p>UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。</p>\n<p>那么优化就势在必得。。。</p>\n<h2 id=\"在优化之前\"><a href=\"#在优化之前\" class=\"headerlink\" title=\"在优化之前\"></a>在优化之前</h2><h3 id=\"UITableView的cell重用机制\"><a href=\"#UITableView的cell重用机制\" class=\"headerlink\" title=\"UITableView的cell重用机制\"></a>UITableView的cell重用机制</h3><p>UITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。</p>\n<p>简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。</p>\n<p>这种机制下系统默认有一个可变数组<code>NSMutableArray *visiableCells</code>，用来保存当前显示的cell。一个可变字典<code>NSMutableDictnery *reusableTableCells</code>，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。</p>\n<h3 id=\"UITableView的代理方法\"><a href=\"#UITableView的代理方法\" class=\"headerlink\" title=\"UITableView的代理方法\"></a>UITableView的代理方法</h3><p> 必须实现的两个数据源回调方法:</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回每个分区的行数 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSInteger)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">numberOfRowsInSection</span><span class=\"selector-pseudo\">:(NSInteger)section</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>调用最频繁的两个回调方法：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回cell的高度 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (CGFloat)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">heightForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>UITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。</p>\n<p>因此，优化UITableView的首要任务就是优化上面这两个回调方法。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"1-Cell重用\"><a href=\"#1-Cell重用\" class=\"headerlink\" title=\"1. Cell重用\"></a>1. Cell重用</h3><p><strong>数据源优化方案：</strong>首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用次数太多，static 保证只创建一次reuseID，提高性能</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *reuseID = “reuseCellID”;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//缓存池中取已经创建的<span class=\"built_in\">cell</span></span><br><span class=\"line\">UITableViewCell *<span class=\"built_in\">cell</span> = [tableView dequeueReusableCellWithIdentifi<span class=\"symbol\">er:re</span>useID];</span><br></pre></td></tr></table></figure>\n<p><strong>缓存池的实现：</strong>当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。</p>\n<h3 id=\"2-提前计算并缓存Cell的高度\"><a href=\"#2-提前计算并缓存Cell的高度\" class=\"headerlink\" title=\"2. 提前计算并缓存Cell的高度\"></a>2. 提前计算并缓存Cell的高度</h3><p>调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。</p>\n<ul>\n<li><p>UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。</p>\n</li>\n<li><p>滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>\n</li>\n</ul>\n<p><strong>方案：</strong>创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。</p>\n<p><strong>示例：</strong>如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据纳信模型数组 转成 纳信frame模型数据</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param statuses 纳信模型数组</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)statusFramesWithStatuses:(<span class=\"built_in\">NSArray</span> *)statuses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *frames = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (NXStatusModel *status <span class=\"keyword\">in</span> statuses) &#123;</span><br><span class=\"line\">        NXStatusFrame *frame = [[NXStatusFrame alloc] init];</span><br><span class=\"line\">        <span class=\"comment\">// 传递纳信模型数据，计算所有子控件的frame</span></span><br><span class=\"line\">        frame.isMask = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        frame.status = status;</span><br><span class=\"line\">        [frames addObject:frame];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frames;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-避免cell的重新布局\"><a href=\"#3-避免cell的重新布局\" class=\"headerlink\" title=\"3. 避免cell的重新布局\"></a>3. 避免cell的重新布局</h3><p>cell的布局填充等操作 比较耗时，一般创建时就布局好，<br>如可以将cell单独放到一个自定义类，初始化时就布局好。</p>\n<ul>\n<li><p>尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。</p>\n</li>\n<li><p>只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>\n</li>\n</ul>\n<h3 id=\"4-滑动时，按需加载\"><a href=\"#4-滑动时，按需加载\" class=\"headerlink\" title=\"4. 滑动时，按需加载\"></a>4. 滑动时，按需加载</h3><p>开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDragging:<span class=\"params\">(UIScrollView *)</span>scrollView willDecelerate:<span class=\"params\">(BOOL)</span>decelerate</span><br><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDecelerating:<span class=\"params\">(UIScrollView *)</span>scrollView</span><br></pre></td></tr></table></figure>\n<p>思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取可见部分的Cell</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *visiblePaths = [<span class=\"keyword\">self</span>.tableView indexPathsForVisibleRows];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSIndexPath</span> *indexPath <span class=\"keyword\">in</span> visiblePaths)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载</span></span><br><span class=\"line\">             &lt;code&gt;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tableView 停止滑动的时候异步加载图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.tableView.dragging == <span class=\"literal\">NO</span> &amp;&amp; <span class=\"keyword\">self</span>.tableView.decelerating == <span class=\"literal\">NO</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"comment\">//开始异步加载图片</span></span><br><span class=\"line\">                &lt;code&gt;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-渲染\"><a href=\"#5-渲染\" class=\"headerlink\" title=\"5. 渲染\"></a>5. 渲染</h3><p>不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长</p>\n<p><strong>1、</strong>减少subviews的个数和层级</p>\n<p> 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示</p>\n<p><strong>2、</strong>少用subviews的透明图层</p>\n<p> 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）</p>\n<p><strong>3、</strong>避免CALayer特效（shadowPath）</p>\n<p>给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.<span class=\"keyword\">shadowColor </span>= color.CGColor<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOffset </span>= offset<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOpacity </span>= <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowRadius </span>= radius<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-使用局部更新\"><a href=\"#6-使用局部更新\" class=\"headerlink\" title=\"6. 使用局部更新\"></a>6. 使用局部更新</h3><p>如果只是更新某组的话，使用reloadSection进行局部更新</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">这里</a>有位大佬，可以去看看哦</p>\n<p> UITableView的优化主要从三个方面入手:</p>\n<ul>\n<li>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</li>\n<li>滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage</li>\n<li>异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）</li>\n</ul>\n<p>除了上面最主要的三个方面外，还有很多熟知的优化点：</p>\n<ul>\n<li>正确使用reuseIdentifier来重用Cells</li>\n<li>尽量使所有的view opaque，包括Cell自身</li>\n<li>尽量少用或不用透明图层</li>\n<li>如果Cell内现实的内容来自web，使用异步加载，缓存请求结果</li>\n<li>减少subviews的数量</li>\n<li>在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li>\n<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</li>\n</ul>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">UITableView优化技巧</a></p>\n<p><a href=\"http://blog.csdn.net/u011452278/article/details/60961350\" target=\"_blank\" rel=\"noopener\">UITableView性能优化</a></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/02/16/UITableView%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E7%AF%87/\" target=\"_blank\" rel=\"noopener\">UITableView的优化进阶篇</a><br><a href=\"https://xiaopengmonsters.github.io/2018/01/08/APP%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">APP的优化</a></p>\n<hr>\n<p>UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。</p>\n<p>那么优化就势在必得。。。</p>\n<h2 id=\"在优化之前\"><a href=\"#在优化之前\" class=\"headerlink\" title=\"在优化之前\"></a>在优化之前</h2><h3 id=\"UITableView的cell重用机制\"><a href=\"#UITableView的cell重用机制\" class=\"headerlink\" title=\"UITableView的cell重用机制\"></a>UITableView的cell重用机制</h3><p>UITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。</p>\n<p>简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。</p>\n<p>这种机制下系统默认有一个可变数组<code>NSMutableArray *visiableCells</code>，用来保存当前显示的cell。一个可变字典<code>NSMutableDictnery *reusableTableCells</code>，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。</p>\n<h3 id=\"UITableView的代理方法\"><a href=\"#UITableView的代理方法\" class=\"headerlink\" title=\"UITableView的代理方法\"></a>UITableView的代理方法</h3><p> 必须实现的两个数据源回调方法:</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回每个分区的行数 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSInteger)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">numberOfRowsInSection</span><span class=\"selector-pseudo\">:(NSInteger)section</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>调用最频繁的两个回调方法：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回cell的高度 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (CGFloat)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">heightForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>UITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。</p>\n<p>因此，优化UITableView的首要任务就是优化上面这两个回调方法。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"1-Cell重用\"><a href=\"#1-Cell重用\" class=\"headerlink\" title=\"1. Cell重用\"></a>1. Cell重用</h3><p><strong>数据源优化方案：</strong>首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用次数太多，static 保证只创建一次reuseID，提高性能</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *reuseID = “reuseCellID”;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//缓存池中取已经创建的<span class=\"built_in\">cell</span></span><br><span class=\"line\">UITableViewCell *<span class=\"built_in\">cell</span> = [tableView dequeueReusableCellWithIdentifi<span class=\"symbol\">er:re</span>useID];</span><br></pre></td></tr></table></figure>\n<p><strong>缓存池的实现：</strong>当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。</p>\n<h3 id=\"2-提前计算并缓存Cell的高度\"><a href=\"#2-提前计算并缓存Cell的高度\" class=\"headerlink\" title=\"2. 提前计算并缓存Cell的高度\"></a>2. 提前计算并缓存Cell的高度</h3><p>调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。</p>\n<ul>\n<li><p>UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。</p>\n</li>\n<li><p>滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>\n</li>\n</ul>\n<p><strong>方案：</strong>创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。</p>\n<p><strong>示例：</strong>如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据纳信模型数组 转成 纳信frame模型数据</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param statuses 纳信模型数组</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)statusFramesWithStatuses:(<span class=\"built_in\">NSArray</span> *)statuses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *frames = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (NXStatusModel *status <span class=\"keyword\">in</span> statuses) &#123;</span><br><span class=\"line\">        NXStatusFrame *frame = [[NXStatusFrame alloc] init];</span><br><span class=\"line\">        <span class=\"comment\">// 传递纳信模型数据，计算所有子控件的frame</span></span><br><span class=\"line\">        frame.isMask = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        frame.status = status;</span><br><span class=\"line\">        [frames addObject:frame];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frames;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-避免cell的重新布局\"><a href=\"#3-避免cell的重新布局\" class=\"headerlink\" title=\"3. 避免cell的重新布局\"></a>3. 避免cell的重新布局</h3><p>cell的布局填充等操作 比较耗时，一般创建时就布局好，<br>如可以将cell单独放到一个自定义类，初始化时就布局好。</p>\n<ul>\n<li><p>尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。</p>\n</li>\n<li><p>只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>\n</li>\n</ul>\n<h3 id=\"4-滑动时，按需加载\"><a href=\"#4-滑动时，按需加载\" class=\"headerlink\" title=\"4. 滑动时，按需加载\"></a>4. 滑动时，按需加载</h3><p>开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDragging:<span class=\"params\">(UIScrollView *)</span>scrollView willDecelerate:<span class=\"params\">(BOOL)</span>decelerate</span><br><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDecelerating:<span class=\"params\">(UIScrollView *)</span>scrollView</span><br></pre></td></tr></table></figure>\n<p>思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取可见部分的Cell</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *visiblePaths = [<span class=\"keyword\">self</span>.tableView indexPathsForVisibleRows];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSIndexPath</span> *indexPath <span class=\"keyword\">in</span> visiblePaths)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载</span></span><br><span class=\"line\">             &lt;code&gt;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tableView 停止滑动的时候异步加载图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.tableView.dragging == <span class=\"literal\">NO</span> &amp;&amp; <span class=\"keyword\">self</span>.tableView.decelerating == <span class=\"literal\">NO</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"comment\">//开始异步加载图片</span></span><br><span class=\"line\">                &lt;code&gt;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-渲染\"><a href=\"#5-渲染\" class=\"headerlink\" title=\"5. 渲染\"></a>5. 渲染</h3><p>不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长</p>\n<p><strong>1、</strong>减少subviews的个数和层级</p>\n<p> 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示</p>\n<p><strong>2、</strong>少用subviews的透明图层</p>\n<p> 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）</p>\n<p><strong>3、</strong>避免CALayer特效（shadowPath）</p>\n<p>给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.<span class=\"keyword\">shadowColor </span>= color.CGColor<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOffset </span>= offset<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOpacity </span>= <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowRadius </span>= radius<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-使用局部更新\"><a href=\"#6-使用局部更新\" class=\"headerlink\" title=\"6. 使用局部更新\"></a>6. 使用局部更新</h3><p>如果只是更新某组的话，使用reloadSection进行局部更新</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">这里</a>有位大佬，可以去看看哦</p>\n<p> UITableView的优化主要从三个方面入手:</p>\n<ul>\n<li>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</li>\n<li>滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage</li>\n<li>异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）</li>\n</ul>\n<p>除了上面最主要的三个方面外，还有很多熟知的优化点：</p>\n<ul>\n<li>正确使用reuseIdentifier来重用Cells</li>\n<li>尽量使所有的view opaque，包括Cell自身</li>\n<li>尽量少用或不用透明图层</li>\n<li>如果Cell内现实的内容来自web，使用异步加载，缓存请求结果</li>\n<li>减少subviews的数量</li>\n<li>在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li>\n<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</li>\n</ul>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">UITableView优化技巧</a></p>\n<p><a href=\"http://blog.csdn.net/u011452278/article/details/60961350\" target=\"_blank\" rel=\"noopener\">UITableView性能优化</a></p>\n"},{"title":"iOS应用架构谈：网络层框架的设计","date":"2018-03-10T09:23:33.000Z","description":"学习 casa 关于网层的架构设计思想，已应用于公司重构项目中","toc":false,"_content":"\n***\n[iOS应用架构谈：网络层框架的设计](https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/)\n[iOS应用架构谈：网络层框架的优化](https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/)\n[iOS应用架构谈：本地持久化方案](https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/)\n***\n\n\n# 网络层跟业务对接部分的设计：\n\n1. 使用哪种交互模式来跟业务层做对接？\n2. 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n3. 使用集约化调用方式还是离散型调用方式去调用API？\n\n### 一、使用哪种交互模式来跟业务层做对接？\n\n以什么方式将数据交付给业务层？\n\n* 以Delegate为主，Notification为辅。原因如下\n    1. 尽可能减少跨层数据交流的可能，限制耦合\n    2. 统一回调方法，便于调试和维护\n    3. 在跟业务层对接的部分只采用一种对接手段（在我这儿就是只采用delegate这一个手段）限制灵活性，以此来交换应用的可维护性\n    4. Notification也不是完全不能使用，当需求要求跨层时，我们就可以使用Notification，比如前面提到的网络条件切换，而且这个需求也是需要满足一对多的\n\n    \n交付什么样的数据给业务层？\n\n* 在设计网络层数据交付这部分时，添加了reformer（改革者）这个对象用于封装数据转化的逻辑，这个对象是一个独立对象，事实上，它是作为Adaptor（适配器）模式存在的。我们可以这么理解：想象一下我们洗澡时候使用的莲蓬头，水管里出来的水是API下发的原始数据。reformer就是莲蓬头上的不同水流挡板，需要什么模式，就拨到什么模式。\n* （reformer本质上就是一个符合某个protocol的对象，在controller需要从api manager中获得数据的时候，顺便把reformer传进去，于是就能获得经过reformer重新洗过的数据，然后就可以直接使用了。）\n* （reformer事实上是把转化的代码封装之后再从主体业务中拆分了出来，拆分出来之后不光降低了原有业务的复杂度，更重要的是，它提高了数据交付的灵活性。另外，由于Controller负责调度Manager和View，因此它是知道Manager和View之间的关系的，Controller知道了这个关系之后，就有了充要条件来为不同的View选择不同的Reformer，并用这个Reformer去改造Mananger的数据，然后ViewController获得了经过reformer处理过的数据之后，就可以直接交付给view去使用。Controller因此得到瘦身，负责业务数据转化的这部分代码也不用写在Controller里面，提高了可维护性。）\n\n1. 要点1：reformer是一个符合ReformerProtocol的对象，它提供了通用的方法供Manager使用。\n2. 要点2：API的原始数据（JSON对象）由Manager实例保管，reformer方法里面取Manager的原始数据(manager.rawData)做转换，然后交付出去。莲蓬头的水管部分是Manager，负责提供原始水流（数据流），reformer就是不同的模式，换什么reformer就能出来什么水流。\n3. 要点3：例子中举的场景是一个API数据被多个View使用的情况，体现了reformer的一个特点：可以根据需要改变同一数据来源的展示方式。比如API数据展示的是“附近的小区”，那么这个数据可以被列表（XXXView）和地图（YYYView）共用，不同的view使用的数据的转化方式不一样，这就通过不同的reformer解决了。\n4. 要点4：在一个view用来同一展示不同API数据的情况，reformer是绝佳利器。比如安居客的列表view的数据来源可能有三个：二手房列表API，租房列表API，新房列表API。这些API返回来的数据的value可能一致，但是key都是不一致的。这时候就可以通过同一个reformer来做数据的标准化输出，这样就使得view代码复用成为可能。这体现了reformer另外一个特点：同一个reformer出来的数据是高度标准化的。形象点说就是：只要莲蓬头不换，哪怕水管的水变成海水或者污水了，也依旧能够输出符合洗澡要求的淡水水流。\n5. 要点5：有没有发现，使用reformer之后，Controller的代码简洁了很多？而且，数据原型在这种情况下就没有必要存在了，随之而来的成本也就被我们绕过了。\n\n在不使用特定对象表征数据的情况下，如何保持数据可读性？\n保持reformer代码的可读性\n不使用对象来表征数据的时候，事实上就是使用NSDictionary的时候。事实上，这个问题就是，如何在NSDictionary表征数据的情况下保持良好的可读性？\n苹果已经给出了非常好的做法，用固定字符串做key，比如你在接收到KeyBoardWillShow的Notification时，带了一个userInfo，他的key就都是类似UIKeyboardAnimationCurveUserInfoKey这样的，所以我们采用这样的方案来维持可读性。 \n关于交付的NSDictionary，其实具体还是看view的需求，reformer的设计初衷是：通过reformer转化出来的可以直接是View，或者是view直接可以使用的对象（包括NSDictionary）。\n综上，我对交付什么样的数据给业务层？这个问题的回答就是这样：\n对于业务层而言，由Controller根据View和APIManager之间的关系，选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成view）转化好之后交付给View。对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型。然后数据采用NSDictionary加Const字符串key来表征，避免了使用对象来表征带来的迁移困难，同时不失去可读性。 \n\n### 二、集约型API调用方式和离散型API调用方式的选择？\n\n集约型API调用其实就是所有API的调用只有一个类，然后这个类接收API名字，API参数，以及回调着陆点（可以是target-action，或者block，或者delegate等各种模式的着陆点）作为参数。然后执行类似startRequest这样的方法，它就会去根据这些参数起飞去调用API了，然后获得API数据之后再根据指定的着陆点去着陆。比如这样：\n\n```\n[APIRequest startRequestWithApiName:@\"itemList.v1\" params:params success:@selector(success:) fail:@selector(fail:) target:self];\n\n离散型API调用是这样的，一个API对应于一个APIManager，然后这个APIManager只需要提供参数就能起飞，API名字、着陆方式都已经集成入APIManager中。\n```\n\n\n集约型API调用和离散型API调用这两者实现方案不是互斥的，单看下层，大家都是集约型。因为发起一个API请求之后，除去业务相关的部分（比如参数和API名字等），剩下的都是要统一处理的：加密，URL拼接，API请求的起飞和着陆，这些处理如果不用集约化的方式来实现，作者非癫即痴。然而对于整个网络层来说，尤其是业务方使用的那部分，我倾向于提供离散型的API调用方式，并不建议在业务层的代码直接使用集约型的API调用方式。原因如下：（业务部门为什么使用离散型API）\n\n1. 原因1：当前请求正在外面飞着的时候，根据不同的业务需求存在两种不同的请求起飞策略：一个是取消新发起的请求，等待外面飞着的请求着陆。另一个是取消外面飞着的请求，让新发起的请求起飞。集约化的API调用方式如果要满足这样的需求，那么每次要调用的时候都要多写一部分判断和取消的代码，手段就做不到很干净。 ---------------------------------前者的业务场景举个例子就是刷新页面的请求，刷新详情，刷新列表等。后者的业务场景举个例子是列表多维度筛选，比如你先筛选了商品类型，然后筛选了价格区间。当然，后者的情况不一定每次筛选都要调用API，我们先假设这种筛选每次都必须要通过调用API才能获得数据。\n如果是离散型的API调用，在编写不同的APIManager时候就可以针对不同的API设置不同的起飞策略，在实际使用的时候，就可以不必关心起飞策略了，因为APIMananger里面已经写好了。\n2. 原因2：便于针对某个API请求来进行AOP。在集约型的API调用方式下，如果要针对某个API请求的起飞和着陆过程进行AOP，这代码得写成什么样。。。噢，尼玛这画面太美别说看了，我都不敢想。\n3. 原因3：当API请求的着陆点消失时，离散型的API调用方式能够更加透明地处理这种情况。--------------------------------当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。一般来说处理这个情况都是在dealloc的时候取消当前页面所有的请求。如果是集约型的API调用，这个代码就要写到ViewController的dealloc里面，但如果是离散型的API调用，这个代码写到APIManager里面就可以了，然后随着ViewController的回收进程，APIManager也会被跟着回收，这部分代码就得到了调用的机会。这样业务方在使用的时候就可以不必关心着陆点消失的情况了，从而更加关注业务。\n4. 原因4：离散型的API调用方式能够最大程度地给业务方提供灵活性，比如reformer机制就是基于离散型的API调用方式的。另外，如果是针对提供翻页机制的API，APIManager就能简单地提供loadNextPage方法去加载下一页，页码的管理就不用业务方去管理了。还有就是，如果要针对业务请求参数进行验证，比如用户填写注册信息，在离散型的APIManager里面实现就会非常轻松。\n\n**综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求**\n\n怎么做APIManager的继承？\n\n如果要做成离散型的API调用，那么使用继承是逃不掉的。BaseAPIManager里面负责集约化的部分，外部派生的XXXAPIManager负责离散的部分，对于BaseAPIManager来说，离散的部分有一些是必要的，比如API名字等，而我们派生的目的，也是为了提供这些数据。\n\n网络层与业务层对接部分的小总结：\n\n1. 使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问\n2. 交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性\n3. 提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多\n4. 网络层上部分使用离散型设计，下部分使用集约型设计\n5. 设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱\n6. 应该不止这5点...\n\n\n# 网络层的安全机制:\n\n**1、判断API的调用请求是来自于经过授权的APP**\n\n* 使用这个机制的目的主要有两点\n 1. 确保API的调用者是来自你自己的APP，防止竞争对手爬你的API\n 2. 如果你对外提供了需要注册才能使用的API平台，那么你需要有这个机制来识别是否是注册用户调用了你的API\n \n  **解决方案：设计签名**\n  \n  要达到第一个目的其实很简单，服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。\n  \n  一般情况下大部分公司不会出现需要满足第二种情况的需求，除非公司开发了自己的API平台给第三方使用。这个需求跟上面的需求有一点不同：符合授权的API请求者不只是一个。所以在这种情况下，需要的安全机制会更加复杂一点。\n  \n  这里有一个较容易实现的方案：客户端调用API的时候，把自己的密钥通过一个可逆的加密算法加密后连着请求和加密之后的Hash一起送上去。当然，这个可逆的加密算法肯定是放在在调用API的SDK里面，编译好的。然后服务端拿到加密后的密钥和加密的Hash之后，解码得到原始密钥，然后再用它去算Hash，最后再进行比对。\n\n**2、保证传输数据的安全**\n\n* 使用这个机制的主要目的有两点\n 1. 防止中间人攻击，比如说运营商很喜欢往用户的Http请求里面塞广告...\n 2. SPDY依赖于HTTPS，而且是未来HTTP/2的基础，他们能够提高你APP在网络层整体的性能\n\n **解决方案：HTTPS**\n \n 目前使用HTTPS的主要目的在于防止运营商往你的Response Data里面加广告啥的（中间人攻击），面对的威胁范围更广。从2011年开始，国外业界就已经提倡所有的请求（不光是API，还有网站）都走HTTPS，国内差不多晚了两年（2013年左右）才开始提倡这事，天猫是这两个月才开始做HTTPS的全APP迁移。\n关于速度，HTTPS肯定是比HTTP慢的，毕竟多了一次握手，但挂上SPDY之后，有了链接复用，这方面的性能就有了较大提升。这里的性能提升并不是说一个请求原来要500ms能完成，然后现在只要300ms，这是不对的。所谓整体性能是基于大量请求去讨论的：同样的请求量（假设100个）在短期发生时，挂上SPDY之后完成这些任务所要花的时间比不用SPDY要少。SPDY还有Header压缩的功能，不过因为一个API请求本身已经比较小了，压缩数据量所带来的性能提升不会特别明显，所以就单个请求来看，性能的提升是比较小的。不过这是下一节要讨论的事儿了，这儿只是顺带说一下。\n\n**3、安全机制小总结**\n\n这一节说了两种安全机制，一般来说第一种是标配，第二种属于可选配置。不过随着我国互联网基础设施的完善，移动设备性能的提高，以及优化技术的提高，第二种配置的缺点（速度慢）正在越来越微不足道，因此HTTPS也会成为不久之后的未来App的网络层安全机制标配。各位架构师们，如果你的App还没有挂HTTPS，现在就已经可以开始着手这件事情了。\n\n","source":"_posts/iOS应用架构谈：网络层框架的设计.md","raw":"---\ntitle: iOS应用架构谈：网络层框架的设计\ndate: 2018-3-10 17:23:33\n\ndescription: 学习 casa 关于网层的架构设计思想，已应用于公司重构项目中\n\ncategories: [iOS,三方框架]\ntags: [Objective-C]\ntoc: false \n---\n\n***\n[iOS应用架构谈：网络层框架的设计](https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/)\n[iOS应用架构谈：网络层框架的优化](https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/)\n[iOS应用架构谈：本地持久化方案](https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/)\n***\n\n\n# 网络层跟业务对接部分的设计：\n\n1. 使用哪种交互模式来跟业务层做对接？\n2. 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n3. 使用集约化调用方式还是离散型调用方式去调用API？\n\n### 一、使用哪种交互模式来跟业务层做对接？\n\n以什么方式将数据交付给业务层？\n\n* 以Delegate为主，Notification为辅。原因如下\n    1. 尽可能减少跨层数据交流的可能，限制耦合\n    2. 统一回调方法，便于调试和维护\n    3. 在跟业务层对接的部分只采用一种对接手段（在我这儿就是只采用delegate这一个手段）限制灵活性，以此来交换应用的可维护性\n    4. Notification也不是完全不能使用，当需求要求跨层时，我们就可以使用Notification，比如前面提到的网络条件切换，而且这个需求也是需要满足一对多的\n\n    \n交付什么样的数据给业务层？\n\n* 在设计网络层数据交付这部分时，添加了reformer（改革者）这个对象用于封装数据转化的逻辑，这个对象是一个独立对象，事实上，它是作为Adaptor（适配器）模式存在的。我们可以这么理解：想象一下我们洗澡时候使用的莲蓬头，水管里出来的水是API下发的原始数据。reformer就是莲蓬头上的不同水流挡板，需要什么模式，就拨到什么模式。\n* （reformer本质上就是一个符合某个protocol的对象，在controller需要从api manager中获得数据的时候，顺便把reformer传进去，于是就能获得经过reformer重新洗过的数据，然后就可以直接使用了。）\n* （reformer事实上是把转化的代码封装之后再从主体业务中拆分了出来，拆分出来之后不光降低了原有业务的复杂度，更重要的是，它提高了数据交付的灵活性。另外，由于Controller负责调度Manager和View，因此它是知道Manager和View之间的关系的，Controller知道了这个关系之后，就有了充要条件来为不同的View选择不同的Reformer，并用这个Reformer去改造Mananger的数据，然后ViewController获得了经过reformer处理过的数据之后，就可以直接交付给view去使用。Controller因此得到瘦身，负责业务数据转化的这部分代码也不用写在Controller里面，提高了可维护性。）\n\n1. 要点1：reformer是一个符合ReformerProtocol的对象，它提供了通用的方法供Manager使用。\n2. 要点2：API的原始数据（JSON对象）由Manager实例保管，reformer方法里面取Manager的原始数据(manager.rawData)做转换，然后交付出去。莲蓬头的水管部分是Manager，负责提供原始水流（数据流），reformer就是不同的模式，换什么reformer就能出来什么水流。\n3. 要点3：例子中举的场景是一个API数据被多个View使用的情况，体现了reformer的一个特点：可以根据需要改变同一数据来源的展示方式。比如API数据展示的是“附近的小区”，那么这个数据可以被列表（XXXView）和地图（YYYView）共用，不同的view使用的数据的转化方式不一样，这就通过不同的reformer解决了。\n4. 要点4：在一个view用来同一展示不同API数据的情况，reformer是绝佳利器。比如安居客的列表view的数据来源可能有三个：二手房列表API，租房列表API，新房列表API。这些API返回来的数据的value可能一致，但是key都是不一致的。这时候就可以通过同一个reformer来做数据的标准化输出，这样就使得view代码复用成为可能。这体现了reformer另外一个特点：同一个reformer出来的数据是高度标准化的。形象点说就是：只要莲蓬头不换，哪怕水管的水变成海水或者污水了，也依旧能够输出符合洗澡要求的淡水水流。\n5. 要点5：有没有发现，使用reformer之后，Controller的代码简洁了很多？而且，数据原型在这种情况下就没有必要存在了，随之而来的成本也就被我们绕过了。\n\n在不使用特定对象表征数据的情况下，如何保持数据可读性？\n保持reformer代码的可读性\n不使用对象来表征数据的时候，事实上就是使用NSDictionary的时候。事实上，这个问题就是，如何在NSDictionary表征数据的情况下保持良好的可读性？\n苹果已经给出了非常好的做法，用固定字符串做key，比如你在接收到KeyBoardWillShow的Notification时，带了一个userInfo，他的key就都是类似UIKeyboardAnimationCurveUserInfoKey这样的，所以我们采用这样的方案来维持可读性。 \n关于交付的NSDictionary，其实具体还是看view的需求，reformer的设计初衷是：通过reformer转化出来的可以直接是View，或者是view直接可以使用的对象（包括NSDictionary）。\n综上，我对交付什么样的数据给业务层？这个问题的回答就是这样：\n对于业务层而言，由Controller根据View和APIManager之间的关系，选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成view）转化好之后交付给View。对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型。然后数据采用NSDictionary加Const字符串key来表征，避免了使用对象来表征带来的迁移困难，同时不失去可读性。 \n\n### 二、集约型API调用方式和离散型API调用方式的选择？\n\n集约型API调用其实就是所有API的调用只有一个类，然后这个类接收API名字，API参数，以及回调着陆点（可以是target-action，或者block，或者delegate等各种模式的着陆点）作为参数。然后执行类似startRequest这样的方法，它就会去根据这些参数起飞去调用API了，然后获得API数据之后再根据指定的着陆点去着陆。比如这样：\n\n```\n[APIRequest startRequestWithApiName:@\"itemList.v1\" params:params success:@selector(success:) fail:@selector(fail:) target:self];\n\n离散型API调用是这样的，一个API对应于一个APIManager，然后这个APIManager只需要提供参数就能起飞，API名字、着陆方式都已经集成入APIManager中。\n```\n\n\n集约型API调用和离散型API调用这两者实现方案不是互斥的，单看下层，大家都是集约型。因为发起一个API请求之后，除去业务相关的部分（比如参数和API名字等），剩下的都是要统一处理的：加密，URL拼接，API请求的起飞和着陆，这些处理如果不用集约化的方式来实现，作者非癫即痴。然而对于整个网络层来说，尤其是业务方使用的那部分，我倾向于提供离散型的API调用方式，并不建议在业务层的代码直接使用集约型的API调用方式。原因如下：（业务部门为什么使用离散型API）\n\n1. 原因1：当前请求正在外面飞着的时候，根据不同的业务需求存在两种不同的请求起飞策略：一个是取消新发起的请求，等待外面飞着的请求着陆。另一个是取消外面飞着的请求，让新发起的请求起飞。集约化的API调用方式如果要满足这样的需求，那么每次要调用的时候都要多写一部分判断和取消的代码，手段就做不到很干净。 ---------------------------------前者的业务场景举个例子就是刷新页面的请求，刷新详情，刷新列表等。后者的业务场景举个例子是列表多维度筛选，比如你先筛选了商品类型，然后筛选了价格区间。当然，后者的情况不一定每次筛选都要调用API，我们先假设这种筛选每次都必须要通过调用API才能获得数据。\n如果是离散型的API调用，在编写不同的APIManager时候就可以针对不同的API设置不同的起飞策略，在实际使用的时候，就可以不必关心起飞策略了，因为APIMananger里面已经写好了。\n2. 原因2：便于针对某个API请求来进行AOP。在集约型的API调用方式下，如果要针对某个API请求的起飞和着陆过程进行AOP，这代码得写成什么样。。。噢，尼玛这画面太美别说看了，我都不敢想。\n3. 原因3：当API请求的着陆点消失时，离散型的API调用方式能够更加透明地处理这种情况。--------------------------------当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。一般来说处理这个情况都是在dealloc的时候取消当前页面所有的请求。如果是集约型的API调用，这个代码就要写到ViewController的dealloc里面，但如果是离散型的API调用，这个代码写到APIManager里面就可以了，然后随着ViewController的回收进程，APIManager也会被跟着回收，这部分代码就得到了调用的机会。这样业务方在使用的时候就可以不必关心着陆点消失的情况了，从而更加关注业务。\n4. 原因4：离散型的API调用方式能够最大程度地给业务方提供灵活性，比如reformer机制就是基于离散型的API调用方式的。另外，如果是针对提供翻页机制的API，APIManager就能简单地提供loadNextPage方法去加载下一页，页码的管理就不用业务方去管理了。还有就是，如果要针对业务请求参数进行验证，比如用户填写注册信息，在离散型的APIManager里面实现就会非常轻松。\n\n**综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求**\n\n怎么做APIManager的继承？\n\n如果要做成离散型的API调用，那么使用继承是逃不掉的。BaseAPIManager里面负责集约化的部分，外部派生的XXXAPIManager负责离散的部分，对于BaseAPIManager来说，离散的部分有一些是必要的，比如API名字等，而我们派生的目的，也是为了提供这些数据。\n\n网络层与业务层对接部分的小总结：\n\n1. 使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问\n2. 交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性\n3. 提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多\n4. 网络层上部分使用离散型设计，下部分使用集约型设计\n5. 设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱\n6. 应该不止这5点...\n\n\n# 网络层的安全机制:\n\n**1、判断API的调用请求是来自于经过授权的APP**\n\n* 使用这个机制的目的主要有两点\n 1. 确保API的调用者是来自你自己的APP，防止竞争对手爬你的API\n 2. 如果你对外提供了需要注册才能使用的API平台，那么你需要有这个机制来识别是否是注册用户调用了你的API\n \n  **解决方案：设计签名**\n  \n  要达到第一个目的其实很简单，服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。\n  \n  一般情况下大部分公司不会出现需要满足第二种情况的需求，除非公司开发了自己的API平台给第三方使用。这个需求跟上面的需求有一点不同：符合授权的API请求者不只是一个。所以在这种情况下，需要的安全机制会更加复杂一点。\n  \n  这里有一个较容易实现的方案：客户端调用API的时候，把自己的密钥通过一个可逆的加密算法加密后连着请求和加密之后的Hash一起送上去。当然，这个可逆的加密算法肯定是放在在调用API的SDK里面，编译好的。然后服务端拿到加密后的密钥和加密的Hash之后，解码得到原始密钥，然后再用它去算Hash，最后再进行比对。\n\n**2、保证传输数据的安全**\n\n* 使用这个机制的主要目的有两点\n 1. 防止中间人攻击，比如说运营商很喜欢往用户的Http请求里面塞广告...\n 2. SPDY依赖于HTTPS，而且是未来HTTP/2的基础，他们能够提高你APP在网络层整体的性能\n\n **解决方案：HTTPS**\n \n 目前使用HTTPS的主要目的在于防止运营商往你的Response Data里面加广告啥的（中间人攻击），面对的威胁范围更广。从2011年开始，国外业界就已经提倡所有的请求（不光是API，还有网站）都走HTTPS，国内差不多晚了两年（2013年左右）才开始提倡这事，天猫是这两个月才开始做HTTPS的全APP迁移。\n关于速度，HTTPS肯定是比HTTP慢的，毕竟多了一次握手，但挂上SPDY之后，有了链接复用，这方面的性能就有了较大提升。这里的性能提升并不是说一个请求原来要500ms能完成，然后现在只要300ms，这是不对的。所谓整体性能是基于大量请求去讨论的：同样的请求量（假设100个）在短期发生时，挂上SPDY之后完成这些任务所要花的时间比不用SPDY要少。SPDY还有Header压缩的功能，不过因为一个API请求本身已经比较小了，压缩数据量所带来的性能提升不会特别明显，所以就单个请求来看，性能的提升是比较小的。不过这是下一节要讨论的事儿了，这儿只是顺带说一下。\n\n**3、安全机制小总结**\n\n这一节说了两种安全机制，一般来说第一种是标配，第二种属于可选配置。不过随着我国互联网基础设施的完善，移动设备性能的提高，以及优化技术的提高，第二种配置的缺点（速度慢）正在越来越微不足道，因此HTTPS也会成为不久之后的未来App的网络层安全机制标配。各位架构师们，如果你的App还没有挂HTTPS，现在就已经可以开始着手这件事情了。\n\n","slug":"iOS应用架构谈：网络层框架的设计","published":1,"updated":"2018-09-11T09:55:38.000Z","_id":"cjlxj6gca002i66r20c001g3c","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的设计</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：本地持久化方案</a></p>\n<hr>\n<h1 id=\"网络层跟业务对接部分的设计：\"><a href=\"#网络层跟业务对接部分的设计：\" class=\"headerlink\" title=\"网络层跟业务对接部分的设计：\"></a>网络层跟业务对接部分的设计：</h1><ol>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ol>\n<h3 id=\"一、使用哪种交互模式来跟业务层做对接？\"><a href=\"#一、使用哪种交互模式来跟业务层做对接？\" class=\"headerlink\" title=\"一、使用哪种交互模式来跟业务层做对接？\"></a>一、使用哪种交互模式来跟业务层做对接？</h3><p>以什么方式将数据交付给业务层？</p>\n<ul>\n<li>以Delegate为主，Notification为辅。原因如下<ol>\n<li>尽可能减少跨层数据交流的可能，限制耦合</li>\n<li>统一回调方法，便于调试和维护</li>\n<li>在跟业务层对接的部分只采用一种对接手段（在我这儿就是只采用delegate这一个手段）限制灵活性，以此来交换应用的可维护性</li>\n<li>Notification也不是完全不能使用，当需求要求跨层时，我们就可以使用Notification，比如前面提到的网络条件切换，而且这个需求也是需要满足一对多的</li>\n</ol>\n</li>\n</ul>\n<p>交付什么样的数据给业务层？</p>\n<ul>\n<li>在设计网络层数据交付这部分时，添加了reformer（改革者）这个对象用于封装数据转化的逻辑，这个对象是一个独立对象，事实上，它是作为Adaptor（适配器）模式存在的。我们可以这么理解：想象一下我们洗澡时候使用的莲蓬头，水管里出来的水是API下发的原始数据。reformer就是莲蓬头上的不同水流挡板，需要什么模式，就拨到什么模式。</li>\n<li>（reformer本质上就是一个符合某个protocol的对象，在controller需要从api manager中获得数据的时候，顺便把reformer传进去，于是就能获得经过reformer重新洗过的数据，然后就可以直接使用了。）</li>\n<li>（reformer事实上是把转化的代码封装之后再从主体业务中拆分了出来，拆分出来之后不光降低了原有业务的复杂度，更重要的是，它提高了数据交付的灵活性。另外，由于Controller负责调度Manager和View，因此它是知道Manager和View之间的关系的，Controller知道了这个关系之后，就有了充要条件来为不同的View选择不同的Reformer，并用这个Reformer去改造Mananger的数据，然后ViewController获得了经过reformer处理过的数据之后，就可以直接交付给view去使用。Controller因此得到瘦身，负责业务数据转化的这部分代码也不用写在Controller里面，提高了可维护性。）</li>\n</ul>\n<ol>\n<li>要点1：reformer是一个符合ReformerProtocol的对象，它提供了通用的方法供Manager使用。</li>\n<li>要点2：API的原始数据（JSON对象）由Manager实例保管，reformer方法里面取Manager的原始数据(manager.rawData)做转换，然后交付出去。莲蓬头的水管部分是Manager，负责提供原始水流（数据流），reformer就是不同的模式，换什么reformer就能出来什么水流。</li>\n<li>要点3：例子中举的场景是一个API数据被多个View使用的情况，体现了reformer的一个特点：可以根据需要改变同一数据来源的展示方式。比如API数据展示的是“附近的小区”，那么这个数据可以被列表（XXXView）和地图（YYYView）共用，不同的view使用的数据的转化方式不一样，这就通过不同的reformer解决了。</li>\n<li>要点4：在一个view用来同一展示不同API数据的情况，reformer是绝佳利器。比如安居客的列表view的数据来源可能有三个：二手房列表API，租房列表API，新房列表API。这些API返回来的数据的value可能一致，但是key都是不一致的。这时候就可以通过同一个reformer来做数据的标准化输出，这样就使得view代码复用成为可能。这体现了reformer另外一个特点：同一个reformer出来的数据是高度标准化的。形象点说就是：只要莲蓬头不换，哪怕水管的水变成海水或者污水了，也依旧能够输出符合洗澡要求的淡水水流。</li>\n<li>要点5：有没有发现，使用reformer之后，Controller的代码简洁了很多？而且，数据原型在这种情况下就没有必要存在了，随之而来的成本也就被我们绕过了。</li>\n</ol>\n<p>在不使用特定对象表征数据的情况下，如何保持数据可读性？<br>保持reformer代码的可读性<br>不使用对象来表征数据的时候，事实上就是使用NSDictionary的时候。事实上，这个问题就是，如何在NSDictionary表征数据的情况下保持良好的可读性？<br>苹果已经给出了非常好的做法，用固定字符串做key，比如你在接收到KeyBoardWillShow的Notification时，带了一个userInfo，他的key就都是类似UIKeyboardAnimationCurveUserInfoKey这样的，所以我们采用这样的方案来维持可读性。<br>关于交付的NSDictionary，其实具体还是看view的需求，reformer的设计初衷是：通过reformer转化出来的可以直接是View，或者是view直接可以使用的对象（包括NSDictionary）。<br>综上，我对交付什么样的数据给业务层？这个问题的回答就是这样：<br>对于业务层而言，由Controller根据View和APIManager之间的关系，选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成view）转化好之后交付给View。对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型。然后数据采用NSDictionary加Const字符串key来表征，避免了使用对象来表征带来的迁移困难，同时不失去可读性。 </p>\n<h3 id=\"二、集约型API调用方式和离散型API调用方式的选择？\"><a href=\"#二、集约型API调用方式和离散型API调用方式的选择？\" class=\"headerlink\" title=\"二、集约型API调用方式和离散型API调用方式的选择？\"></a>二、集约型API调用方式和离散型API调用方式的选择？</h3><p>集约型API调用其实就是所有API的调用只有一个类，然后这个类接收API名字，API参数，以及回调着陆点（可以是target-action，或者block，或者delegate等各种模式的着陆点）作为参数。然后执行类似startRequest这样的方法，它就会去根据这些参数起飞去调用API了，然后获得API数据之后再根据指定的着陆点去着陆。比如这样：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[APIRequest <span class=\"string\">startRequestWithApiName:</span>@<span class=\"string\">\"itemList.v1\"</span> <span class=\"string\">params:</span>params <span class=\"string\">success:</span><span class=\"meta\">@selector</span>(<span class=\"string\">success:</span>) <span class=\"string\">fail:</span><span class=\"meta\">@selector</span>(<span class=\"string\">fail:</span>) <span class=\"string\">target:</span>self];</span><br><span class=\"line\"></span><br><span class=\"line\">离散型API调用是这样的，一个API对应于一个APIManager，然后这个APIManager只需要提供参数就能起飞，API名字、着陆方式都已经集成入APIManager中。</span><br></pre></td></tr></table></figure>\n<p>集约型API调用和离散型API调用这两者实现方案不是互斥的，单看下层，大家都是集约型。因为发起一个API请求之后，除去业务相关的部分（比如参数和API名字等），剩下的都是要统一处理的：加密，URL拼接，API请求的起飞和着陆，这些处理如果不用集约化的方式来实现，作者非癫即痴。然而对于整个网络层来说，尤其是业务方使用的那部分，我倾向于提供离散型的API调用方式，并不建议在业务层的代码直接使用集约型的API调用方式。原因如下：（业务部门为什么使用离散型API）</p>\n<ol>\n<li>原因1：当前请求正在外面飞着的时候，根据不同的业务需求存在两种不同的请求起飞策略：一个是取消新发起的请求，等待外面飞着的请求着陆。另一个是取消外面飞着的请求，让新发起的请求起飞。集约化的API调用方式如果要满足这样的需求，那么每次要调用的时候都要多写一部分判断和取消的代码，手段就做不到很干净。 ———————————前者的业务场景举个例子就是刷新页面的请求，刷新详情，刷新列表等。后者的业务场景举个例子是列表多维度筛选，比如你先筛选了商品类型，然后筛选了价格区间。当然，后者的情况不一定每次筛选都要调用API，我们先假设这种筛选每次都必须要通过调用API才能获得数据。<br>如果是离散型的API调用，在编写不同的APIManager时候就可以针对不同的API设置不同的起飞策略，在实际使用的时候，就可以不必关心起飞策略了，因为APIMananger里面已经写好了。</li>\n<li>原因2：便于针对某个API请求来进行AOP。在集约型的API调用方式下，如果要针对某个API请求的起飞和着陆过程进行AOP，这代码得写成什么样。。。噢，尼玛这画面太美别说看了，我都不敢想。</li>\n<li>原因3：当API请求的着陆点消失时，离散型的API调用方式能够更加透明地处理这种情况。——————————–当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。一般来说处理这个情况都是在dealloc的时候取消当前页面所有的请求。如果是集约型的API调用，这个代码就要写到ViewController的dealloc里面，但如果是离散型的API调用，这个代码写到APIManager里面就可以了，然后随着ViewController的回收进程，APIManager也会被跟着回收，这部分代码就得到了调用的机会。这样业务方在使用的时候就可以不必关心着陆点消失的情况了，从而更加关注业务。</li>\n<li>原因4：离散型的API调用方式能够最大程度地给业务方提供灵活性，比如reformer机制就是基于离散型的API调用方式的。另外，如果是针对提供翻页机制的API，APIManager就能简单地提供loadNextPage方法去加载下一页，页码的管理就不用业务方去管理了。还有就是，如果要针对业务请求参数进行验证，比如用户填写注册信息，在离散型的APIManager里面实现就会非常轻松。</li>\n</ol>\n<p><strong>综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求</strong></p>\n<p>怎么做APIManager的继承？</p>\n<p>如果要做成离散型的API调用，那么使用继承是逃不掉的。BaseAPIManager里面负责集约化的部分，外部派生的XXXAPIManager负责离散的部分，对于BaseAPIManager来说，离散的部分有一些是必要的，比如API名字等，而我们派生的目的，也是为了提供这些数据。</p>\n<p>网络层与业务层对接部分的小总结：</p>\n<ol>\n<li>使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问</li>\n<li>交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性</li>\n<li>提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多</li>\n<li>网络层上部分使用离散型设计，下部分使用集约型设计</li>\n<li>设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱</li>\n<li>应该不止这5点…</li>\n</ol>\n<h1 id=\"网络层的安全机制\"><a href=\"#网络层的安全机制\" class=\"headerlink\" title=\"网络层的安全机制:\"></a>网络层的安全机制:</h1><p><strong>1、判断API的调用请求是来自于经过授权的APP</strong></p>\n<ul>\n<li><p>使用这个机制的目的主要有两点</p>\n<ol>\n<li>确保API的调用者是来自你自己的APP，防止竞争对手爬你的API</li>\n<li>如果你对外提供了需要注册才能使用的API平台，那么你需要有这个机制来识别是否是注册用户调用了你的API</li>\n</ol>\n<p><strong>解决方案：设计签名</strong></p>\n<p>要达到第一个目的其实很简单，服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。</p>\n<p>一般情况下大部分公司不会出现需要满足第二种情况的需求，除非公司开发了自己的API平台给第三方使用。这个需求跟上面的需求有一点不同：符合授权的API请求者不只是一个。所以在这种情况下，需要的安全机制会更加复杂一点。</p>\n<p>这里有一个较容易实现的方案：客户端调用API的时候，把自己的密钥通过一个可逆的加密算法加密后连着请求和加密之后的Hash一起送上去。当然，这个可逆的加密算法肯定是放在在调用API的SDK里面，编译好的。然后服务端拿到加密后的密钥和加密的Hash之后，解码得到原始密钥，然后再用它去算Hash，最后再进行比对。</p>\n</li>\n</ul>\n<p><strong>2、保证传输数据的安全</strong></p>\n<ul>\n<li><p>使用这个机制的主要目的有两点</p>\n<ol>\n<li>防止中间人攻击，比如说运营商很喜欢往用户的Http请求里面塞广告…</li>\n<li>SPDY依赖于HTTPS，而且是未来HTTP/2的基础，他们能够提高你APP在网络层整体的性能</li>\n</ol>\n<p><strong>解决方案：HTTPS</strong></p>\n<p>目前使用HTTPS的主要目的在于防止运营商往你的Response Data里面加广告啥的（中间人攻击），面对的威胁范围更广。从2011年开始，国外业界就已经提倡所有的请求（不光是API，还有网站）都走HTTPS，国内差不多晚了两年（2013年左右）才开始提倡这事，天猫是这两个月才开始做HTTPS的全APP迁移。<br>关于速度，HTTPS肯定是比HTTP慢的，毕竟多了一次握手，但挂上SPDY之后，有了链接复用，这方面的性能就有了较大提升。这里的性能提升并不是说一个请求原来要500ms能完成，然后现在只要300ms，这是不对的。所谓整体性能是基于大量请求去讨论的：同样的请求量（假设100个）在短期发生时，挂上SPDY之后完成这些任务所要花的时间比不用SPDY要少。SPDY还有Header压缩的功能，不过因为一个API请求本身已经比较小了，压缩数据量所带来的性能提升不会特别明显，所以就单个请求来看，性能的提升是比较小的。不过这是下一节要讨论的事儿了，这儿只是顺带说一下。</p>\n</li>\n</ul>\n<p><strong>3、安全机制小总结</strong></p>\n<p>这一节说了两种安全机制，一般来说第一种是标配，第二种属于可选配置。不过随着我国互联网基础设施的完善，移动设备性能的提高，以及优化技术的提高，第二种配置的缺点（速度慢）正在越来越微不足道，因此HTTPS也会成为不久之后的未来App的网络层安全机制标配。各位架构师们，如果你的App还没有挂HTTPS，现在就已经可以开始着手这件事情了。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的设计</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：本地持久化方案</a></p>\n<hr>\n<h1 id=\"网络层跟业务对接部分的设计：\"><a href=\"#网络层跟业务对接部分的设计：\" class=\"headerlink\" title=\"网络层跟业务对接部分的设计：\"></a>网络层跟业务对接部分的设计：</h1><ol>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ol>\n<h3 id=\"一、使用哪种交互模式来跟业务层做对接？\"><a href=\"#一、使用哪种交互模式来跟业务层做对接？\" class=\"headerlink\" title=\"一、使用哪种交互模式来跟业务层做对接？\"></a>一、使用哪种交互模式来跟业务层做对接？</h3><p>以什么方式将数据交付给业务层？</p>\n<ul>\n<li>以Delegate为主，Notification为辅。原因如下<ol>\n<li>尽可能减少跨层数据交流的可能，限制耦合</li>\n<li>统一回调方法，便于调试和维护</li>\n<li>在跟业务层对接的部分只采用一种对接手段（在我这儿就是只采用delegate这一个手段）限制灵活性，以此来交换应用的可维护性</li>\n<li>Notification也不是完全不能使用，当需求要求跨层时，我们就可以使用Notification，比如前面提到的网络条件切换，而且这个需求也是需要满足一对多的</li>\n</ol>\n</li>\n</ul>\n<p>交付什么样的数据给业务层？</p>\n<ul>\n<li>在设计网络层数据交付这部分时，添加了reformer（改革者）这个对象用于封装数据转化的逻辑，这个对象是一个独立对象，事实上，它是作为Adaptor（适配器）模式存在的。我们可以这么理解：想象一下我们洗澡时候使用的莲蓬头，水管里出来的水是API下发的原始数据。reformer就是莲蓬头上的不同水流挡板，需要什么模式，就拨到什么模式。</li>\n<li>（reformer本质上就是一个符合某个protocol的对象，在controller需要从api manager中获得数据的时候，顺便把reformer传进去，于是就能获得经过reformer重新洗过的数据，然后就可以直接使用了。）</li>\n<li>（reformer事实上是把转化的代码封装之后再从主体业务中拆分了出来，拆分出来之后不光降低了原有业务的复杂度，更重要的是，它提高了数据交付的灵活性。另外，由于Controller负责调度Manager和View，因此它是知道Manager和View之间的关系的，Controller知道了这个关系之后，就有了充要条件来为不同的View选择不同的Reformer，并用这个Reformer去改造Mananger的数据，然后ViewController获得了经过reformer处理过的数据之后，就可以直接交付给view去使用。Controller因此得到瘦身，负责业务数据转化的这部分代码也不用写在Controller里面，提高了可维护性。）</li>\n</ul>\n<ol>\n<li>要点1：reformer是一个符合ReformerProtocol的对象，它提供了通用的方法供Manager使用。</li>\n<li>要点2：API的原始数据（JSON对象）由Manager实例保管，reformer方法里面取Manager的原始数据(manager.rawData)做转换，然后交付出去。莲蓬头的水管部分是Manager，负责提供原始水流（数据流），reformer就是不同的模式，换什么reformer就能出来什么水流。</li>\n<li>要点3：例子中举的场景是一个API数据被多个View使用的情况，体现了reformer的一个特点：可以根据需要改变同一数据来源的展示方式。比如API数据展示的是“附近的小区”，那么这个数据可以被列表（XXXView）和地图（YYYView）共用，不同的view使用的数据的转化方式不一样，这就通过不同的reformer解决了。</li>\n<li>要点4：在一个view用来同一展示不同API数据的情况，reformer是绝佳利器。比如安居客的列表view的数据来源可能有三个：二手房列表API，租房列表API，新房列表API。这些API返回来的数据的value可能一致，但是key都是不一致的。这时候就可以通过同一个reformer来做数据的标准化输出，这样就使得view代码复用成为可能。这体现了reformer另外一个特点：同一个reformer出来的数据是高度标准化的。形象点说就是：只要莲蓬头不换，哪怕水管的水变成海水或者污水了，也依旧能够输出符合洗澡要求的淡水水流。</li>\n<li>要点5：有没有发现，使用reformer之后，Controller的代码简洁了很多？而且，数据原型在这种情况下就没有必要存在了，随之而来的成本也就被我们绕过了。</li>\n</ol>\n<p>在不使用特定对象表征数据的情况下，如何保持数据可读性？<br>保持reformer代码的可读性<br>不使用对象来表征数据的时候，事实上就是使用NSDictionary的时候。事实上，这个问题就是，如何在NSDictionary表征数据的情况下保持良好的可读性？<br>苹果已经给出了非常好的做法，用固定字符串做key，比如你在接收到KeyBoardWillShow的Notification时，带了一个userInfo，他的key就都是类似UIKeyboardAnimationCurveUserInfoKey这样的，所以我们采用这样的方案来维持可读性。<br>关于交付的NSDictionary，其实具体还是看view的需求，reformer的设计初衷是：通过reformer转化出来的可以直接是View，或者是view直接可以使用的对象（包括NSDictionary）。<br>综上，我对交付什么样的数据给业务层？这个问题的回答就是这样：<br>对于业务层而言，由Controller根据View和APIManager之间的关系，选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成view）转化好之后交付给View。对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型。然后数据采用NSDictionary加Const字符串key来表征，避免了使用对象来表征带来的迁移困难，同时不失去可读性。 </p>\n<h3 id=\"二、集约型API调用方式和离散型API调用方式的选择？\"><a href=\"#二、集约型API调用方式和离散型API调用方式的选择？\" class=\"headerlink\" title=\"二、集约型API调用方式和离散型API调用方式的选择？\"></a>二、集约型API调用方式和离散型API调用方式的选择？</h3><p>集约型API调用其实就是所有API的调用只有一个类，然后这个类接收API名字，API参数，以及回调着陆点（可以是target-action，或者block，或者delegate等各种模式的着陆点）作为参数。然后执行类似startRequest这样的方法，它就会去根据这些参数起飞去调用API了，然后获得API数据之后再根据指定的着陆点去着陆。比如这样：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[APIRequest <span class=\"string\">startRequestWithApiName:</span>@<span class=\"string\">\"itemList.v1\"</span> <span class=\"string\">params:</span>params <span class=\"string\">success:</span><span class=\"meta\">@selector</span>(<span class=\"string\">success:</span>) <span class=\"string\">fail:</span><span class=\"meta\">@selector</span>(<span class=\"string\">fail:</span>) <span class=\"string\">target:</span>self];</span><br><span class=\"line\"></span><br><span class=\"line\">离散型API调用是这样的，一个API对应于一个APIManager，然后这个APIManager只需要提供参数就能起飞，API名字、着陆方式都已经集成入APIManager中。</span><br></pre></td></tr></table></figure>\n<p>集约型API调用和离散型API调用这两者实现方案不是互斥的，单看下层，大家都是集约型。因为发起一个API请求之后，除去业务相关的部分（比如参数和API名字等），剩下的都是要统一处理的：加密，URL拼接，API请求的起飞和着陆，这些处理如果不用集约化的方式来实现，作者非癫即痴。然而对于整个网络层来说，尤其是业务方使用的那部分，我倾向于提供离散型的API调用方式，并不建议在业务层的代码直接使用集约型的API调用方式。原因如下：（业务部门为什么使用离散型API）</p>\n<ol>\n<li>原因1：当前请求正在外面飞着的时候，根据不同的业务需求存在两种不同的请求起飞策略：一个是取消新发起的请求，等待外面飞着的请求着陆。另一个是取消外面飞着的请求，让新发起的请求起飞。集约化的API调用方式如果要满足这样的需求，那么每次要调用的时候都要多写一部分判断和取消的代码，手段就做不到很干净。 ———————————前者的业务场景举个例子就是刷新页面的请求，刷新详情，刷新列表等。后者的业务场景举个例子是列表多维度筛选，比如你先筛选了商品类型，然后筛选了价格区间。当然，后者的情况不一定每次筛选都要调用API，我们先假设这种筛选每次都必须要通过调用API才能获得数据。<br>如果是离散型的API调用，在编写不同的APIManager时候就可以针对不同的API设置不同的起飞策略，在实际使用的时候，就可以不必关心起飞策略了，因为APIMananger里面已经写好了。</li>\n<li>原因2：便于针对某个API请求来进行AOP。在集约型的API调用方式下，如果要针对某个API请求的起飞和着陆过程进行AOP，这代码得写成什么样。。。噢，尼玛这画面太美别说看了，我都不敢想。</li>\n<li>原因3：当API请求的着陆点消失时，离散型的API调用方式能够更加透明地处理这种情况。——————————–当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。一般来说处理这个情况都是在dealloc的时候取消当前页面所有的请求。如果是集约型的API调用，这个代码就要写到ViewController的dealloc里面，但如果是离散型的API调用，这个代码写到APIManager里面就可以了，然后随着ViewController的回收进程，APIManager也会被跟着回收，这部分代码就得到了调用的机会。这样业务方在使用的时候就可以不必关心着陆点消失的情况了，从而更加关注业务。</li>\n<li>原因4：离散型的API调用方式能够最大程度地给业务方提供灵活性，比如reformer机制就是基于离散型的API调用方式的。另外，如果是针对提供翻页机制的API，APIManager就能简单地提供loadNextPage方法去加载下一页，页码的管理就不用业务方去管理了。还有就是，如果要针对业务请求参数进行验证，比如用户填写注册信息，在离散型的APIManager里面实现就会非常轻松。</li>\n</ol>\n<p><strong>综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求</strong></p>\n<p>怎么做APIManager的继承？</p>\n<p>如果要做成离散型的API调用，那么使用继承是逃不掉的。BaseAPIManager里面负责集约化的部分，外部派生的XXXAPIManager负责离散的部分，对于BaseAPIManager来说，离散的部分有一些是必要的，比如API名字等，而我们派生的目的，也是为了提供这些数据。</p>\n<p>网络层与业务层对接部分的小总结：</p>\n<ol>\n<li>使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问</li>\n<li>交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性</li>\n<li>提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多</li>\n<li>网络层上部分使用离散型设计，下部分使用集约型设计</li>\n<li>设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱</li>\n<li>应该不止这5点…</li>\n</ol>\n<h1 id=\"网络层的安全机制\"><a href=\"#网络层的安全机制\" class=\"headerlink\" title=\"网络层的安全机制:\"></a>网络层的安全机制:</h1><p><strong>1、判断API的调用请求是来自于经过授权的APP</strong></p>\n<ul>\n<li><p>使用这个机制的目的主要有两点</p>\n<ol>\n<li>确保API的调用者是来自你自己的APP，防止竞争对手爬你的API</li>\n<li>如果你对外提供了需要注册才能使用的API平台，那么你需要有这个机制来识别是否是注册用户调用了你的API</li>\n</ol>\n<p><strong>解决方案：设计签名</strong></p>\n<p>要达到第一个目的其实很简单，服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。</p>\n<p>一般情况下大部分公司不会出现需要满足第二种情况的需求，除非公司开发了自己的API平台给第三方使用。这个需求跟上面的需求有一点不同：符合授权的API请求者不只是一个。所以在这种情况下，需要的安全机制会更加复杂一点。</p>\n<p>这里有一个较容易实现的方案：客户端调用API的时候，把自己的密钥通过一个可逆的加密算法加密后连着请求和加密之后的Hash一起送上去。当然，这个可逆的加密算法肯定是放在在调用API的SDK里面，编译好的。然后服务端拿到加密后的密钥和加密的Hash之后，解码得到原始密钥，然后再用它去算Hash，最后再进行比对。</p>\n</li>\n</ul>\n<p><strong>2、保证传输数据的安全</strong></p>\n<ul>\n<li><p>使用这个机制的主要目的有两点</p>\n<ol>\n<li>防止中间人攻击，比如说运营商很喜欢往用户的Http请求里面塞广告…</li>\n<li>SPDY依赖于HTTPS，而且是未来HTTP/2的基础，他们能够提高你APP在网络层整体的性能</li>\n</ol>\n<p><strong>解决方案：HTTPS</strong></p>\n<p>目前使用HTTPS的主要目的在于防止运营商往你的Response Data里面加广告啥的（中间人攻击），面对的威胁范围更广。从2011年开始，国外业界就已经提倡所有的请求（不光是API，还有网站）都走HTTPS，国内差不多晚了两年（2013年左右）才开始提倡这事，天猫是这两个月才开始做HTTPS的全APP迁移。<br>关于速度，HTTPS肯定是比HTTP慢的，毕竟多了一次握手，但挂上SPDY之后，有了链接复用，这方面的性能就有了较大提升。这里的性能提升并不是说一个请求原来要500ms能完成，然后现在只要300ms，这是不对的。所谓整体性能是基于大量请求去讨论的：同样的请求量（假设100个）在短期发生时，挂上SPDY之后完成这些任务所要花的时间比不用SPDY要少。SPDY还有Header压缩的功能，不过因为一个API请求本身已经比较小了，压缩数据量所带来的性能提升不会特别明显，所以就单个请求来看，性能的提升是比较小的。不过这是下一节要讨论的事儿了，这儿只是顺带说一下。</p>\n</li>\n</ul>\n<p><strong>3、安全机制小总结</strong></p>\n<p>这一节说了两种安全机制，一般来说第一种是标配，第二种属于可选配置。不过随着我国互联网基础设施的完善，移动设备性能的提高，以及优化技术的提高，第二种配置的缺点（速度慢）正在越来越微不足道，因此HTTPS也会成为不久之后的未来App的网络层安全机制标配。各位架构师们，如果你的App还没有挂HTTPS，现在就已经可以开始着手这件事情了。</p>\n"},{"title":"iOS应用架构谈：网络层框架的优化","date":"2018-03-14T17:23:33.000Z","description":"学习 casa 关于网层的架构设计思想，已应用于公司重构项目中","toc":false,"_content":"\n***\n[iOS应用架构谈：网络层框架的设计](https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/)\n[iOS应用架构谈：网络层框架的优化](https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/)\n[iOS应用架构谈：本地持久化方案](https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/)\n***\n\n\n网络层的优化手段主要从以下三方面考虑：\n\n1. 针对链接建立环节的优化\n2. 针对链接传输数据量的优化\n3. 针对链接复用的优化\n\n这三方面是所有优化手段的内容，各种五花八门的优化手段基本上都不会逃脱这三方面，下面我就会分别针对这三方面讲一下各自对应的优化手段。\n\n### 1. 针对链接建立环节的优化\n\n在API发起请求建立链接的环节，大致会分这些步骤：\n\n1. 发起请求\n2. DNS域名解析得到IP\n3. 根据IP进行三次握手（HTTPS四次握手），链接建立成功\n\n其实第三步的优化手段跟第二步的优化手段是一致的，会在讲第二步的时候一起讲掉\n\n**1.1 针对发起请求的优化手段**\n\n* 1.1.1 使用缓存手段减少请求的发起次数\n\n   对于大部分API调用请求来说，有些API请求所带来的数据的时效性是比较长的，比如商品详情，比如App皮肤等。那么我们就可以针对这些数据做本地缓存，这样下次请求这些数据的时候就可以不必再发起新的请求。\n   \n* 一般是把API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据。这样下次有同样请求的时候就可以直接读取这里面的数据。关于这里有一个缓存策略的问题需要讨论：什么时候清理缓存？要么就是根据超时时间限制进行清理，要么就是根据缓存数据大小进行清理。这个策略的选择要根据具体App的操作日志来决定。\n\n* 比如安居客App，日志数据记录显示用户平均使用时长不到3分钟，但是用户查看房源详情的次数比较多，而房源详情数据量较大。那么这个时候，就适合根据使用时长来做缓存，我当时给安居客设置的缓存超时时间就是3分钟，这样能够保证这个缓存能够在大部分用户使用时间产生作用。嗯，极端情况下做什么缓存手段不考虑，只要能够服务好80%的用户就可以了，而且针对极端情况采用的优化手段对大部分普通用户而言是不必要的，做了反而会对他们有影响。\n\n* 再比如网络图片缓存，数据量基本上都特别大，这种就比较适合针对缓存大小来清理缓存的策略。\n\n* 另外，之前的缓存的前提都是基于内存的。我们也可以把需要清理的缓存存储在硬盘上（APP的本地存储，我就先用硬盘来表示了，虽然很少有手机硬盘的说法，哈哈），比如前面提到的图片缓存，因为图片很有可能在很长时间之后，再被显示的，那么原本需要被清理的图片缓存，我们就可以考虑存到硬盘上去。当下次再有显示网络图片的需求的时候，我们可以先从内存中找，内存找不到那就从硬盘上找，这都找不到，那就发起请求吧。\n\n* 当然，有些时效性非常短的API数据，就不能使用这个方法了，比如用户的资金数据，那就需要每次都调用了。\n\n* 1.1.2 使用策略来减少请求的发起次数\n\n  这个我在前面提到过，就是针对重复请求的发起和取消，是有对应的请求策略的。我们先说取消策略。\n  \n* 如果是界面刷新请求这种，而且存在重复请求的情况（下拉刷新时，在请求着陆之前用户不断执行下拉操作），那么这个时候，后面重复操作导致的API请求就可以不必发送了。\n\n* 如果是条件筛选这种，那就取消前面已经发送的请求。虽然很有可能这个请求已经被执行了，那么取消所带来的性能提升就基本没有了。但如果这个请求还在队列中待执行的话，那么对应的这次链接就可以省掉了。\n\n* 以上是一种，另外一种情况就是请求策略：类似用户操作日志的请求策略。\n\n* 用户操作会触发操作日志上报Server，这种请求特别频繁，但是是暗地里进行的，不需要用户对此有所感知。所以也没必要操作一次就发起一次的请求。在这里就可以采用这样的策略：在本地记录用户的操作记录，当记录满30条的时候发起一次请求将操作记录上传到服务器。然后每次App启动的时候，上传一次上次遗留下来没上传的操作记录。这样能够有效降低用户设备的耗电量，同时提升网络层的性能。\n\n   小总结\n   \n   针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，所以针对发送请求的优化手段还是值得做的。\n   \n  1.2 & 1.3 针对DNS域名解析做的优化，以及建立链接的优化\n\n 其实在整个DNS链路上也是有DNS缓存的，理论上也是能够提高速度的。\n \n 这个链路上的DNS缓存在PC用户上效果明显，因为PC用户的DNS链路相对稳定，信号源不会变来变去。但是在移动设备的用户这边，链路上的DNS缓存所带来的性能提升就不太明显了。因为移动设备的实际使用场景比较复杂，网络信号源会经常变换，信号源每变换一次，对应的DNS解析链路就会变换一次，那么原链路上的DNS缓存就不起作用了。\n \n 而且信号源变换的情况特别特别频繁，所以对于移动设备用户来说，链路的DNS缓存我们基本上可以默认为没有。\n \n 所以大部分时间是手机系统自带的本地DNS缓存在起作用，但是一般来说，移动设备上网的需求也特别频繁，专门为我们这个App所做的DNS缓存很有可能会被别的DNS缓存给挤出去被清理掉，这种情况是特别多的，用户看一会儿知乎刷一下微博查一下地图逛一逛点评再聊个Q，回来之后很有可能属于你自己的App的本地DNS缓存就没了。这还没完，这里还有一个只有在中国特色社会主义的互联网环境中才会有的问题：国内的互联网环境由于GFW的存在，就使得DNS服务速度会比正常情况慢不少。\n \n 基于以上三个原因所导致的最终结果就是，API请求在DNS解析阶段的耗时会很多。\n \n  那么针对这个的优化方案就是，索性直接走IP请求，那不就绕过DNS服务的耗时了嘛。\n \n  另外一个，就是上面提到的建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，我们需要想办法让用户在最适合他的IP上给他提供服务，那么就针对我们绕过DNS服务的手段有一个额外要求：尽可能不要让用户使用对他来说很慢的IP。\n \n  所以综上所述，方案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。\n\n  针对建立连接的优化手段其实是跟DNS域名解析的优化手段是一样的。不过这需要你的服务器提供服务的网络情况要多，一般现在的服务器都是双网卡，电信和网通。由于中国特色的互联网ISP分布，南北网络之间存在瓶颈，而我们App针对链接的优化手段主要就是着手于如何减轻这个瓶颈对App产生的影响，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果。\n\n  我们一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。\n\n  如果你还不熟悉NSURLProtocol应该怎么玩，看完[官方文档](https://developer.apple.com/documentation/foundation/nsurlprotocol)和[这篇文章](https://nshipster.com/nsurlprotocol/)以及[这个Demo](https://github.com/rmls/NSURLProtocolExample)之后，你肯定就会了，其实很简单的。另外，刚才提到[那篇文章](https://nshipster.com/nsurlprotocol/)的作者(mattt)还写了[这个基于NSURLProtocol的工具](https://github.com/mattt/NSEtcHosts)，相当好用，是可以直接拿来集成到项目中的。\n\n   不用NSURLProtocol的话，用其他手段也可以做到这一点，但那些手段未免又比较愚蠢。\n\n**2. 针对链接传输数据量的优化**\n\n这个很好理解，传输的数据少了，那么自然速度就上去了。这里没什么花样可以讲的，就是压缩呗。各种压缩。\n\n**3. 针对链接复用的优化**\n\n建立链接本身是属于比较消耗资源的操作，耗电耗时。SPDY自带链接复用以及数据压缩的功能，所以服务端支持SPDY的时候，App直接挂SPDY就可以了。如果服务端不支持SPDY，也可以使用PipeLine，苹果原生自带这个功能。\n\n一般来说业界内普遍的认识是SPDY优于PipeLine，然后即便如此，SPDY能够带来的网络层效率提升其实也没有文献上的图表那么明显，但还是有性能提升的。还有另外一种比较笨的链接复用的方法，就是维护一个队列，然后将队列里的请求压缩成一个请求发出去，之所以会存在滞留在队列中的请求，是因为在上一个请求还在外面飘的时候。这种做法最终的效果表面上看跟链接复用差别不大，但并不是真正的链接复用，只能说是请求合并。\n\n还是说回来，我建议最好是用SPDY，SPDY和pipeline虽然都属于链接复用的范畴，但是pipeline并不是真正意义上的链接复用，SPDY的链接复用相对pipeline而言更为彻底。SPDY目前也有现成的客户端SDK可以使用，一个是twitter的[CocoaSPDY](https://github.com/twitter/CocoaSPDY)，另一个是[Voxer/iSPDY](https://github.com/Voxer/iSPDY)，这两个库都很活跃，大家可以挑合适的采用。\n\n\n不过目前业界趋势是倾向于使用HTTP/2.0来代替SPDY，不过目前HTTP/2.0还没有正式出台，相关实现大部分都处在demo阶段，所以我们还是先SPDY搞起就好了。未来很有可能会放弃SPDY，转而采用HTTP/2.0来实现网络的优化。这是要提醒各位架构师注意的事情。嗯，我也不知道HTTP/2.0什么时候能出来。","source":"_posts/iOS应用架构谈：网络层框架的优化.md","raw":"---\ntitle: iOS应用架构谈：网络层框架的优化\ndate: 2018-3-15 01:23:33\n\ndescription: 学习 casa 关于网层的架构设计思想，已应用于公司重构项目中\n\ncategories: [iOS,三方框架]\ntags: [Objective-C]\ntoc: false \n---\n\n***\n[iOS应用架构谈：网络层框架的设计](https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/)\n[iOS应用架构谈：网络层框架的优化](https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/)\n[iOS应用架构谈：本地持久化方案](https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/)\n***\n\n\n网络层的优化手段主要从以下三方面考虑：\n\n1. 针对链接建立环节的优化\n2. 针对链接传输数据量的优化\n3. 针对链接复用的优化\n\n这三方面是所有优化手段的内容，各种五花八门的优化手段基本上都不会逃脱这三方面，下面我就会分别针对这三方面讲一下各自对应的优化手段。\n\n### 1. 针对链接建立环节的优化\n\n在API发起请求建立链接的环节，大致会分这些步骤：\n\n1. 发起请求\n2. DNS域名解析得到IP\n3. 根据IP进行三次握手（HTTPS四次握手），链接建立成功\n\n其实第三步的优化手段跟第二步的优化手段是一致的，会在讲第二步的时候一起讲掉\n\n**1.1 针对发起请求的优化手段**\n\n* 1.1.1 使用缓存手段减少请求的发起次数\n\n   对于大部分API调用请求来说，有些API请求所带来的数据的时效性是比较长的，比如商品详情，比如App皮肤等。那么我们就可以针对这些数据做本地缓存，这样下次请求这些数据的时候就可以不必再发起新的请求。\n   \n* 一般是把API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据。这样下次有同样请求的时候就可以直接读取这里面的数据。关于这里有一个缓存策略的问题需要讨论：什么时候清理缓存？要么就是根据超时时间限制进行清理，要么就是根据缓存数据大小进行清理。这个策略的选择要根据具体App的操作日志来决定。\n\n* 比如安居客App，日志数据记录显示用户平均使用时长不到3分钟，但是用户查看房源详情的次数比较多，而房源详情数据量较大。那么这个时候，就适合根据使用时长来做缓存，我当时给安居客设置的缓存超时时间就是3分钟，这样能够保证这个缓存能够在大部分用户使用时间产生作用。嗯，极端情况下做什么缓存手段不考虑，只要能够服务好80%的用户就可以了，而且针对极端情况采用的优化手段对大部分普通用户而言是不必要的，做了反而会对他们有影响。\n\n* 再比如网络图片缓存，数据量基本上都特别大，这种就比较适合针对缓存大小来清理缓存的策略。\n\n* 另外，之前的缓存的前提都是基于内存的。我们也可以把需要清理的缓存存储在硬盘上（APP的本地存储，我就先用硬盘来表示了，虽然很少有手机硬盘的说法，哈哈），比如前面提到的图片缓存，因为图片很有可能在很长时间之后，再被显示的，那么原本需要被清理的图片缓存，我们就可以考虑存到硬盘上去。当下次再有显示网络图片的需求的时候，我们可以先从内存中找，内存找不到那就从硬盘上找，这都找不到，那就发起请求吧。\n\n* 当然，有些时效性非常短的API数据，就不能使用这个方法了，比如用户的资金数据，那就需要每次都调用了。\n\n* 1.1.2 使用策略来减少请求的发起次数\n\n  这个我在前面提到过，就是针对重复请求的发起和取消，是有对应的请求策略的。我们先说取消策略。\n  \n* 如果是界面刷新请求这种，而且存在重复请求的情况（下拉刷新时，在请求着陆之前用户不断执行下拉操作），那么这个时候，后面重复操作导致的API请求就可以不必发送了。\n\n* 如果是条件筛选这种，那就取消前面已经发送的请求。虽然很有可能这个请求已经被执行了，那么取消所带来的性能提升就基本没有了。但如果这个请求还在队列中待执行的话，那么对应的这次链接就可以省掉了。\n\n* 以上是一种，另外一种情况就是请求策略：类似用户操作日志的请求策略。\n\n* 用户操作会触发操作日志上报Server，这种请求特别频繁，但是是暗地里进行的，不需要用户对此有所感知。所以也没必要操作一次就发起一次的请求。在这里就可以采用这样的策略：在本地记录用户的操作记录，当记录满30条的时候发起一次请求将操作记录上传到服务器。然后每次App启动的时候，上传一次上次遗留下来没上传的操作记录。这样能够有效降低用户设备的耗电量，同时提升网络层的性能。\n\n   小总结\n   \n   针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，所以针对发送请求的优化手段还是值得做的。\n   \n  1.2 & 1.3 针对DNS域名解析做的优化，以及建立链接的优化\n\n 其实在整个DNS链路上也是有DNS缓存的，理论上也是能够提高速度的。\n \n 这个链路上的DNS缓存在PC用户上效果明显，因为PC用户的DNS链路相对稳定，信号源不会变来变去。但是在移动设备的用户这边，链路上的DNS缓存所带来的性能提升就不太明显了。因为移动设备的实际使用场景比较复杂，网络信号源会经常变换，信号源每变换一次，对应的DNS解析链路就会变换一次，那么原链路上的DNS缓存就不起作用了。\n \n 而且信号源变换的情况特别特别频繁，所以对于移动设备用户来说，链路的DNS缓存我们基本上可以默认为没有。\n \n 所以大部分时间是手机系统自带的本地DNS缓存在起作用，但是一般来说，移动设备上网的需求也特别频繁，专门为我们这个App所做的DNS缓存很有可能会被别的DNS缓存给挤出去被清理掉，这种情况是特别多的，用户看一会儿知乎刷一下微博查一下地图逛一逛点评再聊个Q，回来之后很有可能属于你自己的App的本地DNS缓存就没了。这还没完，这里还有一个只有在中国特色社会主义的互联网环境中才会有的问题：国内的互联网环境由于GFW的存在，就使得DNS服务速度会比正常情况慢不少。\n \n 基于以上三个原因所导致的最终结果就是，API请求在DNS解析阶段的耗时会很多。\n \n  那么针对这个的优化方案就是，索性直接走IP请求，那不就绕过DNS服务的耗时了嘛。\n \n  另外一个，就是上面提到的建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，我们需要想办法让用户在最适合他的IP上给他提供服务，那么就针对我们绕过DNS服务的手段有一个额外要求：尽可能不要让用户使用对他来说很慢的IP。\n \n  所以综上所述，方案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。\n\n  针对建立连接的优化手段其实是跟DNS域名解析的优化手段是一样的。不过这需要你的服务器提供服务的网络情况要多，一般现在的服务器都是双网卡，电信和网通。由于中国特色的互联网ISP分布，南北网络之间存在瓶颈，而我们App针对链接的优化手段主要就是着手于如何减轻这个瓶颈对App产生的影响，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果。\n\n  我们一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。\n\n  如果你还不熟悉NSURLProtocol应该怎么玩，看完[官方文档](https://developer.apple.com/documentation/foundation/nsurlprotocol)和[这篇文章](https://nshipster.com/nsurlprotocol/)以及[这个Demo](https://github.com/rmls/NSURLProtocolExample)之后，你肯定就会了，其实很简单的。另外，刚才提到[那篇文章](https://nshipster.com/nsurlprotocol/)的作者(mattt)还写了[这个基于NSURLProtocol的工具](https://github.com/mattt/NSEtcHosts)，相当好用，是可以直接拿来集成到项目中的。\n\n   不用NSURLProtocol的话，用其他手段也可以做到这一点，但那些手段未免又比较愚蠢。\n\n**2. 针对链接传输数据量的优化**\n\n这个很好理解，传输的数据少了，那么自然速度就上去了。这里没什么花样可以讲的，就是压缩呗。各种压缩。\n\n**3. 针对链接复用的优化**\n\n建立链接本身是属于比较消耗资源的操作，耗电耗时。SPDY自带链接复用以及数据压缩的功能，所以服务端支持SPDY的时候，App直接挂SPDY就可以了。如果服务端不支持SPDY，也可以使用PipeLine，苹果原生自带这个功能。\n\n一般来说业界内普遍的认识是SPDY优于PipeLine，然后即便如此，SPDY能够带来的网络层效率提升其实也没有文献上的图表那么明显，但还是有性能提升的。还有另外一种比较笨的链接复用的方法，就是维护一个队列，然后将队列里的请求压缩成一个请求发出去，之所以会存在滞留在队列中的请求，是因为在上一个请求还在外面飘的时候。这种做法最终的效果表面上看跟链接复用差别不大，但并不是真正的链接复用，只能说是请求合并。\n\n还是说回来，我建议最好是用SPDY，SPDY和pipeline虽然都属于链接复用的范畴，但是pipeline并不是真正意义上的链接复用，SPDY的链接复用相对pipeline而言更为彻底。SPDY目前也有现成的客户端SDK可以使用，一个是twitter的[CocoaSPDY](https://github.com/twitter/CocoaSPDY)，另一个是[Voxer/iSPDY](https://github.com/Voxer/iSPDY)，这两个库都很活跃，大家可以挑合适的采用。\n\n\n不过目前业界趋势是倾向于使用HTTP/2.0来代替SPDY，不过目前HTTP/2.0还没有正式出台，相关实现大部分都处在demo阶段，所以我们还是先SPDY搞起就好了。未来很有可能会放弃SPDY，转而采用HTTP/2.0来实现网络的优化。这是要提醒各位架构师注意的事情。嗯，我也不知道HTTP/2.0什么时候能出来。","slug":"iOS应用架构谈：网络层框架的优化","published":1,"updated":"2018-09-11T09:55:47.000Z","_id":"cjlxj6gcb002l66r2biew3lif","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的设计</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：本地持久化方案</a></p>\n<hr>\n<p>网络层的优化手段主要从以下三方面考虑：</p>\n<ol>\n<li>针对链接建立环节的优化</li>\n<li>针对链接传输数据量的优化</li>\n<li>针对链接复用的优化</li>\n</ol>\n<p>这三方面是所有优化手段的内容，各种五花八门的优化手段基本上都不会逃脱这三方面，下面我就会分别针对这三方面讲一下各自对应的优化手段。</p>\n<h3 id=\"1-针对链接建立环节的优化\"><a href=\"#1-针对链接建立环节的优化\" class=\"headerlink\" title=\"1. 针对链接建立环节的优化\"></a>1. 针对链接建立环节的优化</h3><p>在API发起请求建立链接的环节，大致会分这些步骤：</p>\n<ol>\n<li>发起请求</li>\n<li>DNS域名解析得到IP</li>\n<li>根据IP进行三次握手（HTTPS四次握手），链接建立成功</li>\n</ol>\n<p>其实第三步的优化手段跟第二步的优化手段是一致的，会在讲第二步的时候一起讲掉</p>\n<p><strong>1.1 针对发起请求的优化手段</strong></p>\n<ul>\n<li><p>1.1.1 使用缓存手段减少请求的发起次数</p>\n<p> 对于大部分API调用请求来说，有些API请求所带来的数据的时效性是比较长的，比如商品详情，比如App皮肤等。那么我们就可以针对这些数据做本地缓存，这样下次请求这些数据的时候就可以不必再发起新的请求。</p>\n</li>\n<li><p>一般是把API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据。这样下次有同样请求的时候就可以直接读取这里面的数据。关于这里有一个缓存策略的问题需要讨论：什么时候清理缓存？要么就是根据超时时间限制进行清理，要么就是根据缓存数据大小进行清理。这个策略的选择要根据具体App的操作日志来决定。</p>\n</li>\n<li><p>比如安居客App，日志数据记录显示用户平均使用时长不到3分钟，但是用户查看房源详情的次数比较多，而房源详情数据量较大。那么这个时候，就适合根据使用时长来做缓存，我当时给安居客设置的缓存超时时间就是3分钟，这样能够保证这个缓存能够在大部分用户使用时间产生作用。嗯，极端情况下做什么缓存手段不考虑，只要能够服务好80%的用户就可以了，而且针对极端情况采用的优化手段对大部分普通用户而言是不必要的，做了反而会对他们有影响。</p>\n</li>\n<li><p>再比如网络图片缓存，数据量基本上都特别大，这种就比较适合针对缓存大小来清理缓存的策略。</p>\n</li>\n<li><p>另外，之前的缓存的前提都是基于内存的。我们也可以把需要清理的缓存存储在硬盘上（APP的本地存储，我就先用硬盘来表示了，虽然很少有手机硬盘的说法，哈哈），比如前面提到的图片缓存，因为图片很有可能在很长时间之后，再被显示的，那么原本需要被清理的图片缓存，我们就可以考虑存到硬盘上去。当下次再有显示网络图片的需求的时候，我们可以先从内存中找，内存找不到那就从硬盘上找，这都找不到，那就发起请求吧。</p>\n</li>\n<li><p>当然，有些时效性非常短的API数据，就不能使用这个方法了，比如用户的资金数据，那就需要每次都调用了。</p>\n</li>\n<li><p>1.1.2 使用策略来减少请求的发起次数</p>\n<p>这个我在前面提到过，就是针对重复请求的发起和取消，是有对应的请求策略的。我们先说取消策略。</p>\n</li>\n<li><p>如果是界面刷新请求这种，而且存在重复请求的情况（下拉刷新时，在请求着陆之前用户不断执行下拉操作），那么这个时候，后面重复操作导致的API请求就可以不必发送了。</p>\n</li>\n<li><p>如果是条件筛选这种，那就取消前面已经发送的请求。虽然很有可能这个请求已经被执行了，那么取消所带来的性能提升就基本没有了。但如果这个请求还在队列中待执行的话，那么对应的这次链接就可以省掉了。</p>\n</li>\n<li><p>以上是一种，另外一种情况就是请求策略：类似用户操作日志的请求策略。</p>\n</li>\n<li><p>用户操作会触发操作日志上报Server，这种请求特别频繁，但是是暗地里进行的，不需要用户对此有所感知。所以也没必要操作一次就发起一次的请求。在这里就可以采用这样的策略：在本地记录用户的操作记录，当记录满30条的时候发起一次请求将操作记录上传到服务器。然后每次App启动的时候，上传一次上次遗留下来没上传的操作记录。这样能够有效降低用户设备的耗电量，同时提升网络层的性能。</p>\n<p> 小总结</p>\n<p> 针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，所以针对发送请求的优化手段还是值得做的。</p>\n<p>1.2 &amp; 1.3 针对DNS域名解析做的优化，以及建立链接的优化</p>\n<p>其实在整个DNS链路上也是有DNS缓存的，理论上也是能够提高速度的。</p>\n<p>这个链路上的DNS缓存在PC用户上效果明显，因为PC用户的DNS链路相对稳定，信号源不会变来变去。但是在移动设备的用户这边，链路上的DNS缓存所带来的性能提升就不太明显了。因为移动设备的实际使用场景比较复杂，网络信号源会经常变换，信号源每变换一次，对应的DNS解析链路就会变换一次，那么原链路上的DNS缓存就不起作用了。</p>\n<p>而且信号源变换的情况特别特别频繁，所以对于移动设备用户来说，链路的DNS缓存我们基本上可以默认为没有。</p>\n<p>所以大部分时间是手机系统自带的本地DNS缓存在起作用，但是一般来说，移动设备上网的需求也特别频繁，专门为我们这个App所做的DNS缓存很有可能会被别的DNS缓存给挤出去被清理掉，这种情况是特别多的，用户看一会儿知乎刷一下微博查一下地图逛一逛点评再聊个Q，回来之后很有可能属于你自己的App的本地DNS缓存就没了。这还没完，这里还有一个只有在中国特色社会主义的互联网环境中才会有的问题：国内的互联网环境由于GFW的存在，就使得DNS服务速度会比正常情况慢不少。</p>\n<p>基于以上三个原因所导致的最终结果就是，API请求在DNS解析阶段的耗时会很多。</p>\n<p>那么针对这个的优化方案就是，索性直接走IP请求，那不就绕过DNS服务的耗时了嘛。</p>\n<p>另外一个，就是上面提到的建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，我们需要想办法让用户在最适合他的IP上给他提供服务，那么就针对我们绕过DNS服务的手段有一个额外要求：尽可能不要让用户使用对他来说很慢的IP。</p>\n<p>所以综上所述，方案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。</p>\n<p>针对建立连接的优化手段其实是跟DNS域名解析的优化手段是一样的。不过这需要你的服务器提供服务的网络情况要多，一般现在的服务器都是双网卡，电信和网通。由于中国特色的互联网ISP分布，南北网络之间存在瓶颈，而我们App针对链接的优化手段主要就是着手于如何减轻这个瓶颈对App产生的影响，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果。</p>\n<p>我们一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。</p>\n<p>如果你还不熟悉NSURLProtocol应该怎么玩，看完<a href=\"https://developer.apple.com/documentation/foundation/nsurlprotocol\" target=\"_blank\" rel=\"noopener\">官方文档</a>和<a href=\"https://nshipster.com/nsurlprotocol/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>以及<a href=\"https://github.com/rmls/NSURLProtocolExample\" target=\"_blank\" rel=\"noopener\">这个Demo</a>之后，你肯定就会了，其实很简单的。另外，刚才提到<a href=\"https://nshipster.com/nsurlprotocol/\" target=\"_blank\" rel=\"noopener\">那篇文章</a>的作者(mattt)还写了<a href=\"https://github.com/mattt/NSEtcHosts\" target=\"_blank\" rel=\"noopener\">这个基于NSURLProtocol的工具</a>，相当好用，是可以直接拿来集成到项目中的。</p>\n<p> 不用NSURLProtocol的话，用其他手段也可以做到这一点，但那些手段未免又比较愚蠢。</p>\n</li>\n</ul>\n<p><strong>2. 针对链接传输数据量的优化</strong></p>\n<p>这个很好理解，传输的数据少了，那么自然速度就上去了。这里没什么花样可以讲的，就是压缩呗。各种压缩。</p>\n<p><strong>3. 针对链接复用的优化</strong></p>\n<p>建立链接本身是属于比较消耗资源的操作，耗电耗时。SPDY自带链接复用以及数据压缩的功能，所以服务端支持SPDY的时候，App直接挂SPDY就可以了。如果服务端不支持SPDY，也可以使用PipeLine，苹果原生自带这个功能。</p>\n<p>一般来说业界内普遍的认识是SPDY优于PipeLine，然后即便如此，SPDY能够带来的网络层效率提升其实也没有文献上的图表那么明显，但还是有性能提升的。还有另外一种比较笨的链接复用的方法，就是维护一个队列，然后将队列里的请求压缩成一个请求发出去，之所以会存在滞留在队列中的请求，是因为在上一个请求还在外面飘的时候。这种做法最终的效果表面上看跟链接复用差别不大，但并不是真正的链接复用，只能说是请求合并。</p>\n<p>还是说回来，我建议最好是用SPDY，SPDY和pipeline虽然都属于链接复用的范畴，但是pipeline并不是真正意义上的链接复用，SPDY的链接复用相对pipeline而言更为彻底。SPDY目前也有现成的客户端SDK可以使用，一个是twitter的<a href=\"https://github.com/twitter/CocoaSPDY\" target=\"_blank\" rel=\"noopener\">CocoaSPDY</a>，另一个是<a href=\"https://github.com/Voxer/iSPDY\" target=\"_blank\" rel=\"noopener\">Voxer/iSPDY</a>，这两个库都很活跃，大家可以挑合适的采用。</p>\n<p>不过目前业界趋势是倾向于使用HTTP/2.0来代替SPDY，不过目前HTTP/2.0还没有正式出台，相关实现大部分都处在demo阶段，所以我们还是先SPDY搞起就好了。未来很有可能会放弃SPDY，转而采用HTTP/2.0来实现网络的优化。这是要提醒各位架构师注意的事情。嗯，我也不知道HTTP/2.0什么时候能出来。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的设计</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：本地持久化方案</a></p>\n<hr>\n<p>网络层的优化手段主要从以下三方面考虑：</p>\n<ol>\n<li>针对链接建立环节的优化</li>\n<li>针对链接传输数据量的优化</li>\n<li>针对链接复用的优化</li>\n</ol>\n<p>这三方面是所有优化手段的内容，各种五花八门的优化手段基本上都不会逃脱这三方面，下面我就会分别针对这三方面讲一下各自对应的优化手段。</p>\n<h3 id=\"1-针对链接建立环节的优化\"><a href=\"#1-针对链接建立环节的优化\" class=\"headerlink\" title=\"1. 针对链接建立环节的优化\"></a>1. 针对链接建立环节的优化</h3><p>在API发起请求建立链接的环节，大致会分这些步骤：</p>\n<ol>\n<li>发起请求</li>\n<li>DNS域名解析得到IP</li>\n<li>根据IP进行三次握手（HTTPS四次握手），链接建立成功</li>\n</ol>\n<p>其实第三步的优化手段跟第二步的优化手段是一致的，会在讲第二步的时候一起讲掉</p>\n<p><strong>1.1 针对发起请求的优化手段</strong></p>\n<ul>\n<li><p>1.1.1 使用缓存手段减少请求的发起次数</p>\n<p> 对于大部分API调用请求来说，有些API请求所带来的数据的时效性是比较长的，比如商品详情，比如App皮肤等。那么我们就可以针对这些数据做本地缓存，这样下次请求这些数据的时候就可以不必再发起新的请求。</p>\n</li>\n<li><p>一般是把API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据。这样下次有同样请求的时候就可以直接读取这里面的数据。关于这里有一个缓存策略的问题需要讨论：什么时候清理缓存？要么就是根据超时时间限制进行清理，要么就是根据缓存数据大小进行清理。这个策略的选择要根据具体App的操作日志来决定。</p>\n</li>\n<li><p>比如安居客App，日志数据记录显示用户平均使用时长不到3分钟，但是用户查看房源详情的次数比较多，而房源详情数据量较大。那么这个时候，就适合根据使用时长来做缓存，我当时给安居客设置的缓存超时时间就是3分钟，这样能够保证这个缓存能够在大部分用户使用时间产生作用。嗯，极端情况下做什么缓存手段不考虑，只要能够服务好80%的用户就可以了，而且针对极端情况采用的优化手段对大部分普通用户而言是不必要的，做了反而会对他们有影响。</p>\n</li>\n<li><p>再比如网络图片缓存，数据量基本上都特别大，这种就比较适合针对缓存大小来清理缓存的策略。</p>\n</li>\n<li><p>另外，之前的缓存的前提都是基于内存的。我们也可以把需要清理的缓存存储在硬盘上（APP的本地存储，我就先用硬盘来表示了，虽然很少有手机硬盘的说法，哈哈），比如前面提到的图片缓存，因为图片很有可能在很长时间之后，再被显示的，那么原本需要被清理的图片缓存，我们就可以考虑存到硬盘上去。当下次再有显示网络图片的需求的时候，我们可以先从内存中找，内存找不到那就从硬盘上找，这都找不到，那就发起请求吧。</p>\n</li>\n<li><p>当然，有些时效性非常短的API数据，就不能使用这个方法了，比如用户的资金数据，那就需要每次都调用了。</p>\n</li>\n<li><p>1.1.2 使用策略来减少请求的发起次数</p>\n<p>这个我在前面提到过，就是针对重复请求的发起和取消，是有对应的请求策略的。我们先说取消策略。</p>\n</li>\n<li><p>如果是界面刷新请求这种，而且存在重复请求的情况（下拉刷新时，在请求着陆之前用户不断执行下拉操作），那么这个时候，后面重复操作导致的API请求就可以不必发送了。</p>\n</li>\n<li><p>如果是条件筛选这种，那就取消前面已经发送的请求。虽然很有可能这个请求已经被执行了，那么取消所带来的性能提升就基本没有了。但如果这个请求还在队列中待执行的话，那么对应的这次链接就可以省掉了。</p>\n</li>\n<li><p>以上是一种，另外一种情况就是请求策略：类似用户操作日志的请求策略。</p>\n</li>\n<li><p>用户操作会触发操作日志上报Server，这种请求特别频繁，但是是暗地里进行的，不需要用户对此有所感知。所以也没必要操作一次就发起一次的请求。在这里就可以采用这样的策略：在本地记录用户的操作记录，当记录满30条的时候发起一次请求将操作记录上传到服务器。然后每次App启动的时候，上传一次上次遗留下来没上传的操作记录。这样能够有效降低用户设备的耗电量，同时提升网络层的性能。</p>\n<p> 小总结</p>\n<p> 针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，所以针对发送请求的优化手段还是值得做的。</p>\n<p>1.2 &amp; 1.3 针对DNS域名解析做的优化，以及建立链接的优化</p>\n<p>其实在整个DNS链路上也是有DNS缓存的，理论上也是能够提高速度的。</p>\n<p>这个链路上的DNS缓存在PC用户上效果明显，因为PC用户的DNS链路相对稳定，信号源不会变来变去。但是在移动设备的用户这边，链路上的DNS缓存所带来的性能提升就不太明显了。因为移动设备的实际使用场景比较复杂，网络信号源会经常变换，信号源每变换一次，对应的DNS解析链路就会变换一次，那么原链路上的DNS缓存就不起作用了。</p>\n<p>而且信号源变换的情况特别特别频繁，所以对于移动设备用户来说，链路的DNS缓存我们基本上可以默认为没有。</p>\n<p>所以大部分时间是手机系统自带的本地DNS缓存在起作用，但是一般来说，移动设备上网的需求也特别频繁，专门为我们这个App所做的DNS缓存很有可能会被别的DNS缓存给挤出去被清理掉，这种情况是特别多的，用户看一会儿知乎刷一下微博查一下地图逛一逛点评再聊个Q，回来之后很有可能属于你自己的App的本地DNS缓存就没了。这还没完，这里还有一个只有在中国特色社会主义的互联网环境中才会有的问题：国内的互联网环境由于GFW的存在，就使得DNS服务速度会比正常情况慢不少。</p>\n<p>基于以上三个原因所导致的最终结果就是，API请求在DNS解析阶段的耗时会很多。</p>\n<p>那么针对这个的优化方案就是，索性直接走IP请求，那不就绕过DNS服务的耗时了嘛。</p>\n<p>另外一个，就是上面提到的建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，我们需要想办法让用户在最适合他的IP上给他提供服务，那么就针对我们绕过DNS服务的手段有一个额外要求：尽可能不要让用户使用对他来说很慢的IP。</p>\n<p>所以综上所述，方案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。</p>\n<p>针对建立连接的优化手段其实是跟DNS域名解析的优化手段是一样的。不过这需要你的服务器提供服务的网络情况要多，一般现在的服务器都是双网卡，电信和网通。由于中国特色的互联网ISP分布，南北网络之间存在瓶颈，而我们App针对链接的优化手段主要就是着手于如何减轻这个瓶颈对App产生的影响，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果。</p>\n<p>我们一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。</p>\n<p>如果你还不熟悉NSURLProtocol应该怎么玩，看完<a href=\"https://developer.apple.com/documentation/foundation/nsurlprotocol\" target=\"_blank\" rel=\"noopener\">官方文档</a>和<a href=\"https://nshipster.com/nsurlprotocol/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>以及<a href=\"https://github.com/rmls/NSURLProtocolExample\" target=\"_blank\" rel=\"noopener\">这个Demo</a>之后，你肯定就会了，其实很简单的。另外，刚才提到<a href=\"https://nshipster.com/nsurlprotocol/\" target=\"_blank\" rel=\"noopener\">那篇文章</a>的作者(mattt)还写了<a href=\"https://github.com/mattt/NSEtcHosts\" target=\"_blank\" rel=\"noopener\">这个基于NSURLProtocol的工具</a>，相当好用，是可以直接拿来集成到项目中的。</p>\n<p> 不用NSURLProtocol的话，用其他手段也可以做到这一点，但那些手段未免又比较愚蠢。</p>\n</li>\n</ul>\n<p><strong>2. 针对链接传输数据量的优化</strong></p>\n<p>这个很好理解，传输的数据少了，那么自然速度就上去了。这里没什么花样可以讲的，就是压缩呗。各种压缩。</p>\n<p><strong>3. 针对链接复用的优化</strong></p>\n<p>建立链接本身是属于比较消耗资源的操作，耗电耗时。SPDY自带链接复用以及数据压缩的功能，所以服务端支持SPDY的时候，App直接挂SPDY就可以了。如果服务端不支持SPDY，也可以使用PipeLine，苹果原生自带这个功能。</p>\n<p>一般来说业界内普遍的认识是SPDY优于PipeLine，然后即便如此，SPDY能够带来的网络层效率提升其实也没有文献上的图表那么明显，但还是有性能提升的。还有另外一种比较笨的链接复用的方法，就是维护一个队列，然后将队列里的请求压缩成一个请求发出去，之所以会存在滞留在队列中的请求，是因为在上一个请求还在外面飘的时候。这种做法最终的效果表面上看跟链接复用差别不大，但并不是真正的链接复用，只能说是请求合并。</p>\n<p>还是说回来，我建议最好是用SPDY，SPDY和pipeline虽然都属于链接复用的范畴，但是pipeline并不是真正意义上的链接复用，SPDY的链接复用相对pipeline而言更为彻底。SPDY目前也有现成的客户端SDK可以使用，一个是twitter的<a href=\"https://github.com/twitter/CocoaSPDY\" target=\"_blank\" rel=\"noopener\">CocoaSPDY</a>，另一个是<a href=\"https://github.com/Voxer/iSPDY\" target=\"_blank\" rel=\"noopener\">Voxer/iSPDY</a>，这两个库都很活跃，大家可以挑合适的采用。</p>\n<p>不过目前业界趋势是倾向于使用HTTP/2.0来代替SPDY，不过目前HTTP/2.0还没有正式出台，相关实现大部分都处在demo阶段，所以我们还是先SPDY搞起就好了。未来很有可能会放弃SPDY，转而采用HTTP/2.0来实现网络的优化。这是要提醒各位架构师注意的事情。嗯，我也不知道HTTP/2.0什么时候能出来。</p>\n"},{"title":"内存管理(三)--引用计数管理","date":"2018-06-20T17:01:18.000Z","description":"MRC&ARC 和 alloc、retain、release、retainCount、dealloc 的实现","_content":"\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## MRC&ARC\n\n### MRC\n\n ![](/img/MRC.png)\n \n MRC：是通过手动引用计数来进行对象的内存管理，关于内存管理涉及到这么几个方法\n \n* alloc：用来分配一个对象的内存空间\n* retain：可以使一个对象的引用计数加一\n* release：对一个对象的引用计数进行减一操作\n* retainCount：这个函数可以获取当前对象的引用计数值\n* autorelease：如果调用了一个对象的 autorelease 方法，那么当前这个对象会在 autorelease pool 结束的时候调用它的 release 操作进行计数减一\n* dealloc：在 MRC 中调用 dealloc 的话，需要显示的调用 super dealloc 来释放或者说废弃父类的相关成员变量\n在 MRC 当中所使用的特有方法，就是标红的这四个方法，在 ARC 当中如果调用这个四个方法，会引起编译报错\n \n### ARC\n\n ![](/img/ARC.png)\n\nARC：是自动引用计数管理内存\n\n实际上是由编译器自动为我们插入 retain release 之外，**还需要 Runtime 的功能支持**，然后由编译器和 Runtime 共同协作才能组成 ARC 的全部功能\n\nARC 中禁止手动调用 MRC 当中独有的方法，比如 retain release retainCount dealloc，在 ARC 当中可以重写某个对象的 dealloc 方法，但是不能在 dealloc 方法当中显式调用 super dealloc 方法\n除此之外 ARC 当中增加了 weak 和 strong 属性关键字\n\n## 引用计数管理\n\n实现原理分析\n\n* alloc\n* retain\n* release\n* retainCount\n* dealloc\n\n### 1. alloc 实现\n\n* 进过一系列调用，最终调用了 C 函数 calloc\n\n* 此时并没有设置引用计数为 1\n\nalloc 比较简单，只是经过一系列的函数封装和调用最终调用了一个C 函数 calloc\n\nalloc 分配之后的对象它并没有设置引用计数为 1，但是通过 retainCount 获取它的引用计数时为 1，原因请往下看\n\n### 2. retain 实现\n \n![](/img/retain实现.png)\n\n* 这段代码表示通过当前对象的指针到 SideTables 当中去获取它所指的 SideTable ，当获取到这个对象引用计数相关的 SideTable 之后，再在这个 SideTable 的结构当中去获取引用计数 refcnts 成员变量（引用计数表），通过当前对象的指针在这个 SideTables 当中的引用计数表当中去获取当前对象的引用计数值\n* 在进行 retain 操作的时候是**进行了两次哈希查找**，最终查找到的结构是 size_t 类型的（无符号 long 型）值，然后再对引用计数值加一操作\n* 这里面所加的是一个 SIDE_TAVLE_RC_ONE 的宏定义，加的值不是实际的 1，因为我们在讲述 size_t 这个存储引用计数变量的时候，说明了它64个bit位前两个位置不是存储引用计数的，而是在后面的62位中存储的引用计数，这里的所谓加一操作实际上加上了对应的偏移量，这个偏移量实际上应该是 4，给我们反应出来的结果就是加一操作\n\n思考：在进行 retain 操作的时候，系统是怎样查找它对应的引用计数的？\n\n### 3. release 实现\n\n![](/img/release实现.png)\n\n* 第一行代码和上面分析的一样，通过当前对象的指针经过哈希算法在 SideTables 当中去获取它所指的 SideTable\n* 然后再根据当前对象指针访问 table 当中的引用计数表去查找它对应的引用计数表\n* 查找到之后，把对应的值进行减一操作\n\n\n### 4. retainCount 实现\n\n![](/img/retainCount实现.png)\n\n* 第一句代码同上\n* 声明了一个局部变量，指定它的值是 1，然后通过当前对象到引用计数表当中去查找，把查找的结果做一个向右便宜的操作，然后再结合这个局部变量的 1 进行一个加的操作，再返回给调用方\n* 所以说，如果我们刚新 alloc 出来的对象，在引用计数表当中是没有这个对象相关联的一个 Key Value 的映射的，这个值读出来就是 0，然后由于局部变量是 1，所以此时只经过 alloc 调用产生的对象去调用它的 retainCount 就可以获取到它的值为 1\n\n\n### 5. dealloc 实现（重要）\n\n\n![](/img/dealloc实现.png)\n\n* 首先会调用 _ objc _rootDealloc() 私有函数\n* 这个函数又会调用 rootDealloc() 函数，然后会在这个函数内部判断当前对象是否可以直接释放\n* 如果这些条件都不满足就直接调用 C 函数的 free() 进行对象的内存释放\n* 否则就要再调用一个函数做后续的清理\n\n\n直接释放的判断条件\n\n* nonpointer_isa：判断当前对象是否使用了非指针型的 isa\n* weakly_referenced：当前对象是否有 weak 指针指向它\n* has_assoc：当前对象是否有关联对象\n* has_cxx_dtor：当期对象的内部实现是否有涉及到一些C++相关的内容，以及当前对象是否使用 ARC 管理内存，如果有涉及C++或者使用ARC管理内存返回YES\n* has_sidetable_rc：当前对象的引用计数是否是在通过 sidetable 当中的引用计数表来维护的，因为在前面讲述关于  nonpointer_isa 的时候提到过如果说采用这中非指针型的 isa 指针的话，它当中存储了一部分引用计数的值，当超出上限的时候，再使用 sidetable 这种方式去存储\n\n\n只有当当前对象既不是非指针型的 isa ，同时没有弱引用，并且也没有关联对象，并且也没有涉及到 C++ 相关内容，并且没有涉及到 ARC，并且当前对象没有采用 sidetable 来存储引用计数，只有在这种条件下，才可以调用 C 函数直接释放，否则的话就要调用 object_dispose() 对象清楚函数\n\n思考：为什么要进行这么多的判断才能进行后续的 object_dispose() 方法调用？\n\n* 如果对象有弱引用的话，那么在这个对象释放废弃的时候需要对它的引用对象进行处理\n* 如果有关联对象需要对关联对象进行处理\n* 包括C++、引用计数相关的处理\n\n#### object_dispose() 实现\n\n![](/img/object_dispose实现.png)\n\n* 首先这个函数内部会调用一个 objc_destructInstance() 函数，看这名字就可以得出是销毁实例的含义\n* 然后这个方法调用之后再调用 C 函数的 free()\n* 然后结束 dealloc 实现\n\n\n#### objc_destructInstance() 实现\n\n![](/img/objc_destructInstance实现.png)\n\n* 在这个函数当中首先会判断当前还有是否有 C++ 相关的内容或者当前对象是否采用的是 ARC\n* 如果有的话会调用 objec_cxxDestruct() 这个方法，如果没有的话会判断当前对象是否有关联对象\n* 如果当前对象有关联对象的话在 dealloc 内部实现会调用 _object_remove_assocations() ,通过名称可以看出是做了对象的相关关联对象的移除\n* 关联对象的判断过了之后会调用一个叫 clearDeallocating() 函数，然后结束 dealloc 流程\n\n思考：我通过关联对象的技术为一个类添加了一些实例变量，那么在对象的 dealloc 方法方法当中是否有必要对它的关联对象进行移除操作？\n在系统的 dealloc 内部实现当中，会自动判断当前对象是否有关联对象，如果有的话系统内部就帮助我们把相关的关联对象移除掉\n\n#### clearDeallocating() 实现\n\n![](/img/clearDeallocating实现.png)\n\n\n* 首先需要调用 sidetable_clearDeallocating() 函数\n* 之后会调用 weak_clear_no_lock() 函数，这个函数做的就是将指向该对象的弱引用指针置为 nil\n* 之后会调用 table.refcnts.erase() ,table 的引用计数的擦除操作，实际上就是将当前对象在引用计数表当中的一些存储数据给清除掉\n* 然后结束调用流程 \n\n思考：如果一个对象有 weak 指针指向他，当这个对象 dealloc 或者说废弃之后，他的 weak 指针为何会自动置为 nil ？\n就是因为在 dealloc 的内部实现当中有做关于他相关的弱引用指针自动置为 nil 的操作的","source":"_posts/内存管理--引用计数管理.md","raw":"---\ntitle: 内存管理(三)--引用计数管理\ndate: 2018-06-21 01:01:18\n\ndescription: MRC&ARC 和 alloc、retain、release、retainCount、dealloc 的实现\n\ncategories: 内存管理\ntags: [Objective-C]\n---\n\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## MRC&ARC\n\n### MRC\n\n ![](/img/MRC.png)\n \n MRC：是通过手动引用计数来进行对象的内存管理，关于内存管理涉及到这么几个方法\n \n* alloc：用来分配一个对象的内存空间\n* retain：可以使一个对象的引用计数加一\n* release：对一个对象的引用计数进行减一操作\n* retainCount：这个函数可以获取当前对象的引用计数值\n* autorelease：如果调用了一个对象的 autorelease 方法，那么当前这个对象会在 autorelease pool 结束的时候调用它的 release 操作进行计数减一\n* dealloc：在 MRC 中调用 dealloc 的话，需要显示的调用 super dealloc 来释放或者说废弃父类的相关成员变量\n在 MRC 当中所使用的特有方法，就是标红的这四个方法，在 ARC 当中如果调用这个四个方法，会引起编译报错\n \n### ARC\n\n ![](/img/ARC.png)\n\nARC：是自动引用计数管理内存\n\n实际上是由编译器自动为我们插入 retain release 之外，**还需要 Runtime 的功能支持**，然后由编译器和 Runtime 共同协作才能组成 ARC 的全部功能\n\nARC 中禁止手动调用 MRC 当中独有的方法，比如 retain release retainCount dealloc，在 ARC 当中可以重写某个对象的 dealloc 方法，但是不能在 dealloc 方法当中显式调用 super dealloc 方法\n除此之外 ARC 当中增加了 weak 和 strong 属性关键字\n\n## 引用计数管理\n\n实现原理分析\n\n* alloc\n* retain\n* release\n* retainCount\n* dealloc\n\n### 1. alloc 实现\n\n* 进过一系列调用，最终调用了 C 函数 calloc\n\n* 此时并没有设置引用计数为 1\n\nalloc 比较简单，只是经过一系列的函数封装和调用最终调用了一个C 函数 calloc\n\nalloc 分配之后的对象它并没有设置引用计数为 1，但是通过 retainCount 获取它的引用计数时为 1，原因请往下看\n\n### 2. retain 实现\n \n![](/img/retain实现.png)\n\n* 这段代码表示通过当前对象的指针到 SideTables 当中去获取它所指的 SideTable ，当获取到这个对象引用计数相关的 SideTable 之后，再在这个 SideTable 的结构当中去获取引用计数 refcnts 成员变量（引用计数表），通过当前对象的指针在这个 SideTables 当中的引用计数表当中去获取当前对象的引用计数值\n* 在进行 retain 操作的时候是**进行了两次哈希查找**，最终查找到的结构是 size_t 类型的（无符号 long 型）值，然后再对引用计数值加一操作\n* 这里面所加的是一个 SIDE_TAVLE_RC_ONE 的宏定义，加的值不是实际的 1，因为我们在讲述 size_t 这个存储引用计数变量的时候，说明了它64个bit位前两个位置不是存储引用计数的，而是在后面的62位中存储的引用计数，这里的所谓加一操作实际上加上了对应的偏移量，这个偏移量实际上应该是 4，给我们反应出来的结果就是加一操作\n\n思考：在进行 retain 操作的时候，系统是怎样查找它对应的引用计数的？\n\n### 3. release 实现\n\n![](/img/release实现.png)\n\n* 第一行代码和上面分析的一样，通过当前对象的指针经过哈希算法在 SideTables 当中去获取它所指的 SideTable\n* 然后再根据当前对象指针访问 table 当中的引用计数表去查找它对应的引用计数表\n* 查找到之后，把对应的值进行减一操作\n\n\n### 4. retainCount 实现\n\n![](/img/retainCount实现.png)\n\n* 第一句代码同上\n* 声明了一个局部变量，指定它的值是 1，然后通过当前对象到引用计数表当中去查找，把查找的结果做一个向右便宜的操作，然后再结合这个局部变量的 1 进行一个加的操作，再返回给调用方\n* 所以说，如果我们刚新 alloc 出来的对象，在引用计数表当中是没有这个对象相关联的一个 Key Value 的映射的，这个值读出来就是 0，然后由于局部变量是 1，所以此时只经过 alloc 调用产生的对象去调用它的 retainCount 就可以获取到它的值为 1\n\n\n### 5. dealloc 实现（重要）\n\n\n![](/img/dealloc实现.png)\n\n* 首先会调用 _ objc _rootDealloc() 私有函数\n* 这个函数又会调用 rootDealloc() 函数，然后会在这个函数内部判断当前对象是否可以直接释放\n* 如果这些条件都不满足就直接调用 C 函数的 free() 进行对象的内存释放\n* 否则就要再调用一个函数做后续的清理\n\n\n直接释放的判断条件\n\n* nonpointer_isa：判断当前对象是否使用了非指针型的 isa\n* weakly_referenced：当前对象是否有 weak 指针指向它\n* has_assoc：当前对象是否有关联对象\n* has_cxx_dtor：当期对象的内部实现是否有涉及到一些C++相关的内容，以及当前对象是否使用 ARC 管理内存，如果有涉及C++或者使用ARC管理内存返回YES\n* has_sidetable_rc：当前对象的引用计数是否是在通过 sidetable 当中的引用计数表来维护的，因为在前面讲述关于  nonpointer_isa 的时候提到过如果说采用这中非指针型的 isa 指针的话，它当中存储了一部分引用计数的值，当超出上限的时候，再使用 sidetable 这种方式去存储\n\n\n只有当当前对象既不是非指针型的 isa ，同时没有弱引用，并且也没有关联对象，并且也没有涉及到 C++ 相关内容，并且没有涉及到 ARC，并且当前对象没有采用 sidetable 来存储引用计数，只有在这种条件下，才可以调用 C 函数直接释放，否则的话就要调用 object_dispose() 对象清楚函数\n\n思考：为什么要进行这么多的判断才能进行后续的 object_dispose() 方法调用？\n\n* 如果对象有弱引用的话，那么在这个对象释放废弃的时候需要对它的引用对象进行处理\n* 如果有关联对象需要对关联对象进行处理\n* 包括C++、引用计数相关的处理\n\n#### object_dispose() 实现\n\n![](/img/object_dispose实现.png)\n\n* 首先这个函数内部会调用一个 objc_destructInstance() 函数，看这名字就可以得出是销毁实例的含义\n* 然后这个方法调用之后再调用 C 函数的 free()\n* 然后结束 dealloc 实现\n\n\n#### objc_destructInstance() 实现\n\n![](/img/objc_destructInstance实现.png)\n\n* 在这个函数当中首先会判断当前还有是否有 C++ 相关的内容或者当前对象是否采用的是 ARC\n* 如果有的话会调用 objec_cxxDestruct() 这个方法，如果没有的话会判断当前对象是否有关联对象\n* 如果当前对象有关联对象的话在 dealloc 内部实现会调用 _object_remove_assocations() ,通过名称可以看出是做了对象的相关关联对象的移除\n* 关联对象的判断过了之后会调用一个叫 clearDeallocating() 函数，然后结束 dealloc 流程\n\n思考：我通过关联对象的技术为一个类添加了一些实例变量，那么在对象的 dealloc 方法方法当中是否有必要对它的关联对象进行移除操作？\n在系统的 dealloc 内部实现当中，会自动判断当前对象是否有关联对象，如果有的话系统内部就帮助我们把相关的关联对象移除掉\n\n#### clearDeallocating() 实现\n\n![](/img/clearDeallocating实现.png)\n\n\n* 首先需要调用 sidetable_clearDeallocating() 函数\n* 之后会调用 weak_clear_no_lock() 函数，这个函数做的就是将指向该对象的弱引用指针置为 nil\n* 之后会调用 table.refcnts.erase() ,table 的引用计数的擦除操作，实际上就是将当前对象在引用计数表当中的一些存储数据给清除掉\n* 然后结束调用流程 \n\n思考：如果一个对象有 weak 指针指向他，当这个对象 dealloc 或者说废弃之后，他的 weak 指针为何会自动置为 nil ？\n就是因为在 dealloc 的内部实现当中有做关于他相关的弱引用指针自动置为 nil 的操作的","slug":"内存管理--引用计数管理","published":1,"updated":"2018-09-14T03:04:14.000Z","_id":"cjlxj6gcd002o66r2ob8qpe7a","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"MRC-amp-ARC\"><a href=\"#MRC-amp-ARC\" class=\"headerlink\" title=\"MRC&amp;ARC\"></a>MRC&amp;ARC</h2><h3 id=\"MRC\"><a href=\"#MRC\" class=\"headerlink\" title=\"MRC\"></a>MRC</h3><p> <img src=\"/img/MRC.png\" alt=\"\"></p>\n<p> MRC：是通过手动引用计数来进行对象的内存管理，关于内存管理涉及到这么几个方法</p>\n<ul>\n<li>alloc：用来分配一个对象的内存空间</li>\n<li>retain：可以使一个对象的引用计数加一</li>\n<li>release：对一个对象的引用计数进行减一操作</li>\n<li>retainCount：这个函数可以获取当前对象的引用计数值</li>\n<li>autorelease：如果调用了一个对象的 autorelease 方法，那么当前这个对象会在 autorelease pool 结束的时候调用它的 release 操作进行计数减一</li>\n<li>dealloc：在 MRC 中调用 dealloc 的话，需要显示的调用 super dealloc 来释放或者说废弃父类的相关成员变量<br>在 MRC 当中所使用的特有方法，就是标红的这四个方法，在 ARC 当中如果调用这个四个方法，会引起编译报错</li>\n</ul>\n<h3 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h3><p> <img src=\"/img/ARC.png\" alt=\"\"></p>\n<p>ARC：是自动引用计数管理内存</p>\n<p>实际上是由编译器自动为我们插入 retain release 之外，<strong>还需要 Runtime 的功能支持</strong>，然后由编译器和 Runtime 共同协作才能组成 ARC 的全部功能</p>\n<p>ARC 中禁止手动调用 MRC 当中独有的方法，比如 retain release retainCount dealloc，在 ARC 当中可以重写某个对象的 dealloc 方法，但是不能在 dealloc 方法当中显式调用 super dealloc 方法<br>除此之外 ARC 当中增加了 weak 和 strong 属性关键字</p>\n<h2 id=\"引用计数管理\"><a href=\"#引用计数管理\" class=\"headerlink\" title=\"引用计数管理\"></a>引用计数管理</h2><p>实现原理分析</p>\n<ul>\n<li>alloc</li>\n<li>retain</li>\n<li>release</li>\n<li>retainCount</li>\n<li>dealloc</li>\n</ul>\n<h3 id=\"1-alloc-实现\"><a href=\"#1-alloc-实现\" class=\"headerlink\" title=\"1. alloc 实现\"></a>1. alloc 实现</h3><ul>\n<li><p>进过一系列调用，最终调用了 C 函数 calloc</p>\n</li>\n<li><p>此时并没有设置引用计数为 1</p>\n</li>\n</ul>\n<p>alloc 比较简单，只是经过一系列的函数封装和调用最终调用了一个C 函数 calloc</p>\n<p>alloc 分配之后的对象它并没有设置引用计数为 1，但是通过 retainCount 获取它的引用计数时为 1，原因请往下看</p>\n<h3 id=\"2-retain-实现\"><a href=\"#2-retain-实现\" class=\"headerlink\" title=\"2. retain 实现\"></a>2. retain 实现</h3><p><img src=\"/img/retain实现.png\" alt=\"\"></p>\n<ul>\n<li>这段代码表示通过当前对象的指针到 SideTables 当中去获取它所指的 SideTable ，当获取到这个对象引用计数相关的 SideTable 之后，再在这个 SideTable 的结构当中去获取引用计数 refcnts 成员变量（引用计数表），通过当前对象的指针在这个 SideTables 当中的引用计数表当中去获取当前对象的引用计数值</li>\n<li>在进行 retain 操作的时候是<strong>进行了两次哈希查找</strong>，最终查找到的结构是 size_t 类型的（无符号 long 型）值，然后再对引用计数值加一操作</li>\n<li>这里面所加的是一个 SIDE_TAVLE_RC_ONE 的宏定义，加的值不是实际的 1，因为我们在讲述 size_t 这个存储引用计数变量的时候，说明了它64个bit位前两个位置不是存储引用计数的，而是在后面的62位中存储的引用计数，这里的所谓加一操作实际上加上了对应的偏移量，这个偏移量实际上应该是 4，给我们反应出来的结果就是加一操作</li>\n</ul>\n<p>思考：在进行 retain 操作的时候，系统是怎样查找它对应的引用计数的？</p>\n<h3 id=\"3-release-实现\"><a href=\"#3-release-实现\" class=\"headerlink\" title=\"3. release 实现\"></a>3. release 实现</h3><p><img src=\"/img/release实现.png\" alt=\"\"></p>\n<ul>\n<li>第一行代码和上面分析的一样，通过当前对象的指针经过哈希算法在 SideTables 当中去获取它所指的 SideTable</li>\n<li>然后再根据当前对象指针访问 table 当中的引用计数表去查找它对应的引用计数表</li>\n<li>查找到之后，把对应的值进行减一操作</li>\n</ul>\n<h3 id=\"4-retainCount-实现\"><a href=\"#4-retainCount-实现\" class=\"headerlink\" title=\"4. retainCount 实现\"></a>4. retainCount 实现</h3><p><img src=\"/img/retainCount实现.png\" alt=\"\"></p>\n<ul>\n<li>第一句代码同上</li>\n<li>声明了一个局部变量，指定它的值是 1，然后通过当前对象到引用计数表当中去查找，把查找的结果做一个向右便宜的操作，然后再结合这个局部变量的 1 进行一个加的操作，再返回给调用方</li>\n<li>所以说，如果我们刚新 alloc 出来的对象，在引用计数表当中是没有这个对象相关联的一个 Key Value 的映射的，这个值读出来就是 0，然后由于局部变量是 1，所以此时只经过 alloc 调用产生的对象去调用它的 retainCount 就可以获取到它的值为 1</li>\n</ul>\n<h3 id=\"5-dealloc-实现（重要）\"><a href=\"#5-dealloc-实现（重要）\" class=\"headerlink\" title=\"5. dealloc 实现（重要）\"></a>5. dealloc 实现（重要）</h3><p><img src=\"/img/dealloc实现.png\" alt=\"\"></p>\n<ul>\n<li>首先会调用 _ objc _rootDealloc() 私有函数</li>\n<li>这个函数又会调用 rootDealloc() 函数，然后会在这个函数内部判断当前对象是否可以直接释放</li>\n<li>如果这些条件都不满足就直接调用 C 函数的 free() 进行对象的内存释放</li>\n<li>否则就要再调用一个函数做后续的清理</li>\n</ul>\n<p>直接释放的判断条件</p>\n<ul>\n<li>nonpointer_isa：判断当前对象是否使用了非指针型的 isa</li>\n<li>weakly_referenced：当前对象是否有 weak 指针指向它</li>\n<li>has_assoc：当前对象是否有关联对象</li>\n<li>has_cxx_dtor：当期对象的内部实现是否有涉及到一些C++相关的内容，以及当前对象是否使用 ARC 管理内存，如果有涉及C++或者使用ARC管理内存返回YES</li>\n<li>has_sidetable_rc：当前对象的引用计数是否是在通过 sidetable 当中的引用计数表来维护的，因为在前面讲述关于  nonpointer_isa 的时候提到过如果说采用这中非指针型的 isa 指针的话，它当中存储了一部分引用计数的值，当超出上限的时候，再使用 sidetable 这种方式去存储</li>\n</ul>\n<p>只有当当前对象既不是非指针型的 isa ，同时没有弱引用，并且也没有关联对象，并且也没有涉及到 C++ 相关内容，并且没有涉及到 ARC，并且当前对象没有采用 sidetable 来存储引用计数，只有在这种条件下，才可以调用 C 函数直接释放，否则的话就要调用 object_dispose() 对象清楚函数</p>\n<p>思考：为什么要进行这么多的判断才能进行后续的 object_dispose() 方法调用？</p>\n<ul>\n<li>如果对象有弱引用的话，那么在这个对象释放废弃的时候需要对它的引用对象进行处理</li>\n<li>如果有关联对象需要对关联对象进行处理</li>\n<li>包括C++、引用计数相关的处理</li>\n</ul>\n<h4 id=\"object-dispose-实现\"><a href=\"#object-dispose-实现\" class=\"headerlink\" title=\"object_dispose() 实现\"></a>object_dispose() 实现</h4><p><img src=\"/img/object_dispose实现.png\" alt=\"\"></p>\n<ul>\n<li>首先这个函数内部会调用一个 objc_destructInstance() 函数，看这名字就可以得出是销毁实例的含义</li>\n<li>然后这个方法调用之后再调用 C 函数的 free()</li>\n<li>然后结束 dealloc 实现</li>\n</ul>\n<h4 id=\"objc-destructInstance-实现\"><a href=\"#objc-destructInstance-实现\" class=\"headerlink\" title=\"objc_destructInstance() 实现\"></a>objc_destructInstance() 实现</h4><p><img src=\"/img/objc_destructInstance实现.png\" alt=\"\"></p>\n<ul>\n<li>在这个函数当中首先会判断当前还有是否有 C++ 相关的内容或者当前对象是否采用的是 ARC</li>\n<li>如果有的话会调用 objec_cxxDestruct() 这个方法，如果没有的话会判断当前对象是否有关联对象</li>\n<li>如果当前对象有关联对象的话在 dealloc 内部实现会调用 _object_remove_assocations() ,通过名称可以看出是做了对象的相关关联对象的移除</li>\n<li>关联对象的判断过了之后会调用一个叫 clearDeallocating() 函数，然后结束 dealloc 流程</li>\n</ul>\n<p>思考：我通过关联对象的技术为一个类添加了一些实例变量，那么在对象的 dealloc 方法方法当中是否有必要对它的关联对象进行移除操作？<br>在系统的 dealloc 内部实现当中，会自动判断当前对象是否有关联对象，如果有的话系统内部就帮助我们把相关的关联对象移除掉</p>\n<h4 id=\"clearDeallocating-实现\"><a href=\"#clearDeallocating-实现\" class=\"headerlink\" title=\"clearDeallocating() 实现\"></a>clearDeallocating() 实现</h4><p><img src=\"/img/clearDeallocating实现.png\" alt=\"\"></p>\n<ul>\n<li>首先需要调用 sidetable_clearDeallocating() 函数</li>\n<li>之后会调用 weak_clear_no_lock() 函数，这个函数做的就是将指向该对象的弱引用指针置为 nil</li>\n<li>之后会调用 table.refcnts.erase() ,table 的引用计数的擦除操作，实际上就是将当前对象在引用计数表当中的一些存储数据给清除掉</li>\n<li>然后结束调用流程 </li>\n</ul>\n<p>思考：如果一个对象有 weak 指针指向他，当这个对象 dealloc 或者说废弃之后，他的 weak 指针为何会自动置为 nil ？<br>就是因为在 dealloc 的内部实现当中有做关于他相关的弱引用指针自动置为 nil 的操作的</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"MRC-amp-ARC\"><a href=\"#MRC-amp-ARC\" class=\"headerlink\" title=\"MRC&amp;ARC\"></a>MRC&amp;ARC</h2><h3 id=\"MRC\"><a href=\"#MRC\" class=\"headerlink\" title=\"MRC\"></a>MRC</h3><p> <img src=\"/img/MRC.png\" alt=\"\"></p>\n<p> MRC：是通过手动引用计数来进行对象的内存管理，关于内存管理涉及到这么几个方法</p>\n<ul>\n<li>alloc：用来分配一个对象的内存空间</li>\n<li>retain：可以使一个对象的引用计数加一</li>\n<li>release：对一个对象的引用计数进行减一操作</li>\n<li>retainCount：这个函数可以获取当前对象的引用计数值</li>\n<li>autorelease：如果调用了一个对象的 autorelease 方法，那么当前这个对象会在 autorelease pool 结束的时候调用它的 release 操作进行计数减一</li>\n<li>dealloc：在 MRC 中调用 dealloc 的话，需要显示的调用 super dealloc 来释放或者说废弃父类的相关成员变量<br>在 MRC 当中所使用的特有方法，就是标红的这四个方法，在 ARC 当中如果调用这个四个方法，会引起编译报错</li>\n</ul>\n<h3 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h3><p> <img src=\"/img/ARC.png\" alt=\"\"></p>\n<p>ARC：是自动引用计数管理内存</p>\n<p>实际上是由编译器自动为我们插入 retain release 之外，<strong>还需要 Runtime 的功能支持</strong>，然后由编译器和 Runtime 共同协作才能组成 ARC 的全部功能</p>\n<p>ARC 中禁止手动调用 MRC 当中独有的方法，比如 retain release retainCount dealloc，在 ARC 当中可以重写某个对象的 dealloc 方法，但是不能在 dealloc 方法当中显式调用 super dealloc 方法<br>除此之外 ARC 当中增加了 weak 和 strong 属性关键字</p>\n<h2 id=\"引用计数管理\"><a href=\"#引用计数管理\" class=\"headerlink\" title=\"引用计数管理\"></a>引用计数管理</h2><p>实现原理分析</p>\n<ul>\n<li>alloc</li>\n<li>retain</li>\n<li>release</li>\n<li>retainCount</li>\n<li>dealloc</li>\n</ul>\n<h3 id=\"1-alloc-实现\"><a href=\"#1-alloc-实现\" class=\"headerlink\" title=\"1. alloc 实现\"></a>1. alloc 实现</h3><ul>\n<li><p>进过一系列调用，最终调用了 C 函数 calloc</p>\n</li>\n<li><p>此时并没有设置引用计数为 1</p>\n</li>\n</ul>\n<p>alloc 比较简单，只是经过一系列的函数封装和调用最终调用了一个C 函数 calloc</p>\n<p>alloc 分配之后的对象它并没有设置引用计数为 1，但是通过 retainCount 获取它的引用计数时为 1，原因请往下看</p>\n<h3 id=\"2-retain-实现\"><a href=\"#2-retain-实现\" class=\"headerlink\" title=\"2. retain 实现\"></a>2. retain 实现</h3><p><img src=\"/img/retain实现.png\" alt=\"\"></p>\n<ul>\n<li>这段代码表示通过当前对象的指针到 SideTables 当中去获取它所指的 SideTable ，当获取到这个对象引用计数相关的 SideTable 之后，再在这个 SideTable 的结构当中去获取引用计数 refcnts 成员变量（引用计数表），通过当前对象的指针在这个 SideTables 当中的引用计数表当中去获取当前对象的引用计数值</li>\n<li>在进行 retain 操作的时候是<strong>进行了两次哈希查找</strong>，最终查找到的结构是 size_t 类型的（无符号 long 型）值，然后再对引用计数值加一操作</li>\n<li>这里面所加的是一个 SIDE_TAVLE_RC_ONE 的宏定义，加的值不是实际的 1，因为我们在讲述 size_t 这个存储引用计数变量的时候，说明了它64个bit位前两个位置不是存储引用计数的，而是在后面的62位中存储的引用计数，这里的所谓加一操作实际上加上了对应的偏移量，这个偏移量实际上应该是 4，给我们反应出来的结果就是加一操作</li>\n</ul>\n<p>思考：在进行 retain 操作的时候，系统是怎样查找它对应的引用计数的？</p>\n<h3 id=\"3-release-实现\"><a href=\"#3-release-实现\" class=\"headerlink\" title=\"3. release 实现\"></a>3. release 实现</h3><p><img src=\"/img/release实现.png\" alt=\"\"></p>\n<ul>\n<li>第一行代码和上面分析的一样，通过当前对象的指针经过哈希算法在 SideTables 当中去获取它所指的 SideTable</li>\n<li>然后再根据当前对象指针访问 table 当中的引用计数表去查找它对应的引用计数表</li>\n<li>查找到之后，把对应的值进行减一操作</li>\n</ul>\n<h3 id=\"4-retainCount-实现\"><a href=\"#4-retainCount-实现\" class=\"headerlink\" title=\"4. retainCount 实现\"></a>4. retainCount 实现</h3><p><img src=\"/img/retainCount实现.png\" alt=\"\"></p>\n<ul>\n<li>第一句代码同上</li>\n<li>声明了一个局部变量，指定它的值是 1，然后通过当前对象到引用计数表当中去查找，把查找的结果做一个向右便宜的操作，然后再结合这个局部变量的 1 进行一个加的操作，再返回给调用方</li>\n<li>所以说，如果我们刚新 alloc 出来的对象，在引用计数表当中是没有这个对象相关联的一个 Key Value 的映射的，这个值读出来就是 0，然后由于局部变量是 1，所以此时只经过 alloc 调用产生的对象去调用它的 retainCount 就可以获取到它的值为 1</li>\n</ul>\n<h3 id=\"5-dealloc-实现（重要）\"><a href=\"#5-dealloc-实现（重要）\" class=\"headerlink\" title=\"5. dealloc 实现（重要）\"></a>5. dealloc 实现（重要）</h3><p><img src=\"/img/dealloc实现.png\" alt=\"\"></p>\n<ul>\n<li>首先会调用 _ objc _rootDealloc() 私有函数</li>\n<li>这个函数又会调用 rootDealloc() 函数，然后会在这个函数内部判断当前对象是否可以直接释放</li>\n<li>如果这些条件都不满足就直接调用 C 函数的 free() 进行对象的内存释放</li>\n<li>否则就要再调用一个函数做后续的清理</li>\n</ul>\n<p>直接释放的判断条件</p>\n<ul>\n<li>nonpointer_isa：判断当前对象是否使用了非指针型的 isa</li>\n<li>weakly_referenced：当前对象是否有 weak 指针指向它</li>\n<li>has_assoc：当前对象是否有关联对象</li>\n<li>has_cxx_dtor：当期对象的内部实现是否有涉及到一些C++相关的内容，以及当前对象是否使用 ARC 管理内存，如果有涉及C++或者使用ARC管理内存返回YES</li>\n<li>has_sidetable_rc：当前对象的引用计数是否是在通过 sidetable 当中的引用计数表来维护的，因为在前面讲述关于  nonpointer_isa 的时候提到过如果说采用这中非指针型的 isa 指针的话，它当中存储了一部分引用计数的值，当超出上限的时候，再使用 sidetable 这种方式去存储</li>\n</ul>\n<p>只有当当前对象既不是非指针型的 isa ，同时没有弱引用，并且也没有关联对象，并且也没有涉及到 C++ 相关内容，并且没有涉及到 ARC，并且当前对象没有采用 sidetable 来存储引用计数，只有在这种条件下，才可以调用 C 函数直接释放，否则的话就要调用 object_dispose() 对象清楚函数</p>\n<p>思考：为什么要进行这么多的判断才能进行后续的 object_dispose() 方法调用？</p>\n<ul>\n<li>如果对象有弱引用的话，那么在这个对象释放废弃的时候需要对它的引用对象进行处理</li>\n<li>如果有关联对象需要对关联对象进行处理</li>\n<li>包括C++、引用计数相关的处理</li>\n</ul>\n<h4 id=\"object-dispose-实现\"><a href=\"#object-dispose-实现\" class=\"headerlink\" title=\"object_dispose() 实现\"></a>object_dispose() 实现</h4><p><img src=\"/img/object_dispose实现.png\" alt=\"\"></p>\n<ul>\n<li>首先这个函数内部会调用一个 objc_destructInstance() 函数，看这名字就可以得出是销毁实例的含义</li>\n<li>然后这个方法调用之后再调用 C 函数的 free()</li>\n<li>然后结束 dealloc 实现</li>\n</ul>\n<h4 id=\"objc-destructInstance-实现\"><a href=\"#objc-destructInstance-实现\" class=\"headerlink\" title=\"objc_destructInstance() 实现\"></a>objc_destructInstance() 实现</h4><p><img src=\"/img/objc_destructInstance实现.png\" alt=\"\"></p>\n<ul>\n<li>在这个函数当中首先会判断当前还有是否有 C++ 相关的内容或者当前对象是否采用的是 ARC</li>\n<li>如果有的话会调用 objec_cxxDestruct() 这个方法，如果没有的话会判断当前对象是否有关联对象</li>\n<li>如果当前对象有关联对象的话在 dealloc 内部实现会调用 _object_remove_assocations() ,通过名称可以看出是做了对象的相关关联对象的移除</li>\n<li>关联对象的判断过了之后会调用一个叫 clearDeallocating() 函数，然后结束 dealloc 流程</li>\n</ul>\n<p>思考：我通过关联对象的技术为一个类添加了一些实例变量，那么在对象的 dealloc 方法方法当中是否有必要对它的关联对象进行移除操作？<br>在系统的 dealloc 内部实现当中，会自动判断当前对象是否有关联对象，如果有的话系统内部就帮助我们把相关的关联对象移除掉</p>\n<h4 id=\"clearDeallocating-实现\"><a href=\"#clearDeallocating-实现\" class=\"headerlink\" title=\"clearDeallocating() 实现\"></a>clearDeallocating() 实现</h4><p><img src=\"/img/clearDeallocating实现.png\" alt=\"\"></p>\n<ul>\n<li>首先需要调用 sidetable_clearDeallocating() 函数</li>\n<li>之后会调用 weak_clear_no_lock() 函数，这个函数做的就是将指向该对象的弱引用指针置为 nil</li>\n<li>之后会调用 table.refcnts.erase() ,table 的引用计数的擦除操作，实际上就是将当前对象在引用计数表当中的一些存储数据给清除掉</li>\n<li>然后结束调用流程 </li>\n</ul>\n<p>思考：如果一个对象有 weak 指针指向他，当这个对象 dealloc 或者说废弃之后，他的 weak 指针为何会自动置为 nil ？<br>就是因为在 dealloc 的内部实现当中有做关于他相关的弱引用指针自动置为 nil 的操作的</p>\n"},{"title":"内存管理(一)--内存管理方案","date":"2018-06-12T17:01:18.000Z","description":"内存布局、内存管理方案","_content":"\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## 内存布局\n\n ![](/img/内存布局.png)\n \n地址的表示是由下到上是低地址到高地址，比如说程序最终加载到内存被分成三段，分别对应未初始化区，已初始化区还有代码段，我们写的程序所有的代码一些数据段都在 .text 内存当中，声明的一些静态变量，全局变量，前提是已初始化的，都会放到已初始化数据区，对于未初始化的一些静态或者全局变量会放到未初始化数据区\n\n在 iOS 中定义的一些方法或者说函数都是在栈上进行工作的，栈是从高地址到低地址进行扩展，所以说栈是向下扩展或者说向下增长，在 iOS 开发过程中，创建的对象或者 block 经过 copy 之后，都会被转移到堆上面去，堆是向上增长的\n\n**不同内存段分别代表的详细含义**\n\n* stack：代表栈区，栈区一般都是方法调用\n* heap：对应的是堆区，通过 alloc 分配的一些对象实际上都是在堆上面提现的\n* bss：就是未初始化的全局变量以及一些未初始化的静态变量\n* data：代表的是已初始化的全局变量\n* text：程序的代码段，程序的代码加载到内存都是放在 text 段\n\n## 内存管理方案\n\n* TaggedPointer\n\n* NONPOINTER_ISA\n\n* 散列表\n\n系统针对不同场景下提出的内存管理方案:\n\n1. 对一些小对象，如 NSNumber 等，采用的是 TaggedPointer 内存管理方案（把指针指向的内容直接放在了指针变量的内存地址中）[戳这里](https://www.jianshu.com/p/e354f9137ba8)\n\n2. 对于64位架构下的 iOS 应用程序采用的是 NONPOINTER_ISA 内存管理方案\nNONPOINTER _ISA 内存管理方案的涵义：实际上在64位架构下 isa 这个指针本身是占64个 比特位的，那么实际上有32位或者说40位就够用了，剩余这些位数的比特位实际上是浪费的，苹果为了提高内存的利用率，在 isa 当中剩余的这些比特位当中，存储了一些关于内存管理当面的相关数据内容，所以说这个叫非指针型的 isa\n\n3. 散列表，散列表是一个很复杂的结构，其中包括了引用计数表和弱引用表  \n\n### 非指针型的 isa 内存管理方案 NONPOINTER_ISA \n\n ![](/img/NONPOINTER_ISA1.png)\n \n ![](/img/NONPOINTER_ISA2.png)\n\n在 arm64 架构下，isa 指针一共有 64 个bit位，这 64 个bit位都存储了哪些内容：\n\n* **第 0 位** 是一个叫 indexed 的标志位，如果这个位置是 0 ，代表的是我们使用的 isa 指针只是一个纯的 isa 指针，它里面的内容就直接代表当前对象的类对象的地址，如果这个标志位是 1 的话就代表这个 isa 里面存储的不止是它的类对象的地址，而且还有内存管理方面的数据，那就是我们这里面要讲到的非指针型的 isa \n* **第 1 位** has_assoc ，是表示当前对象是否有关联对象，0 代表没有，1代表有\n* **第 2 位** has_cxx_dtor ,这个函数或者说这个变量标志表示的是当前对象是否有使用 C++ 相关的代码，那么在 ARC 当中也可以这个表示位来表示有些对象是通过 ARC 来进行内存管理的\n* **3-35 位** 表示的是当前对象的类对象的指针地址（一共有33位01的bit来表示当前对象的类对象的指针地址，我们需要把这个这个位置全部拿出来再去计算它对应的类对象的实际的指针地址）\n* **36-41 位** 这 6 位代表的是 magic 字段（不讲解）\n* **42 位** 是 weakly_referenced 就标识了这个对象是否有相应的弱引用指针\n* **43 位** deallocating 标志当前对象是否正在进行 dealloc 操作\n* **44 位** has_sidetable_rc 这个0是指当前 isa 指针当中如果所存储的引用计数已经达到了上限的话，那么需要外挂一个 sidetable 数据结构去存储相关的引用计数内容，那就是接下里要讲解的散列表\n* **45-63 位** 代表的是 extra_rc 也就是额外的引用计数，当引用计数在很小的值范围之内的话就会存到 isa 指针当中，而不是有单独的引用计数表去存储它\n\n通过对 NONPOINTER_ ISA 的 64 个bit位的分析，就应该清楚关于内存管理不仅仅是散列表，其实还有 isa 部分的 extra_rc 来存储相关的引用计数值\n\n### 散列表内存管理方案\n\n ![](/img/散列表内存管理方案.png)\n\n散列表方案在源码中是通过 Side Tables() 结构来实现的\n\nSide Tables() 结构是什么？\n\n在他的结构下面挂了很多 Side Table 数据结构，这些数据结构在不同的架构上面是有不同个数的，比如在非嵌入式系统当中，Side Table 这个表一共有 64 个，在这里解释一下，Side Tables() 实际上是一个哈希表，可以通过一个对象指针来具体找到它对应的引用计数表或者说弱引用表在哪一张具体的 Side Table 当中\n\n**Side Table结构**\n\n实际上 Side Table 结构就包含了以下三个元素\n\n* 自旋锁\n* 引用计数表\n* 弱引用表\n\n**问题：为什么不是一个 SideTable，而是有多个 SideTable 共同组成 SideTables？**\n\n![](/img/为什么不是一个SideTable.png)\n\n假如说只有一张 SideTable ，那么在内存中分配的所有对象的引用计数或者说弱引用存储都放到一张大表当中，这个时候如果说要操作某一个对象的引用计数值进行修改，比如说加一减一的操作，由于所有的对象可能是在不同的线程当中去分配创建的，包括调用他们的 retain，release等方法也可能是在不同线程当中操作的，那么这个时候再对这张表进行操作的时候，需要进行加锁处理才能保证对数据的访问安全，在这个过程当中就存在了效率问题，如果现在已经有一个对象在操作这张表，那么下一个对象就要等前一个对象操作完后把锁释放之后它才能操作这张表\n\n**系统为了解决效率问题引用了分离锁的技术方案**\n\n![](/img/分离锁.png)\n\n可以把内存对象所对应的引用技术表可以分拆成多个部分，比如说把它分拆成8个，分拆成8个需要对这8个表分别加锁\n\n比如说某一个对象A在第一张表里面，另一个对象B在另一张表中，那么当A和B同时进行引用计数操作的时候可以并发操作，但是如果按照一张表的情况下他们就需要顺序操作\n\n**怎样实现快速分流？**\n\n快速分流指的是通过一个对象的指针如何快速的定位到它属于哪张 side Table 表？\n\n![](/img/怎样实现快速分流.png)\n\nside Tables 的本质是一张哈希表，这张哈希表当中可能有64张具体的 side Table ，然后存储不同对象的引用计数表和弱引用表\n\n**哈希表的概念这里简单讲解一下：**\n\n看这幅图，左侧是一个对象，这个对象指针可以作为一个 Key ，经过哈希函数的一个运算然后会计算出一个值来决定出这个对象它所对应的 side Table 是哪张或者说在数组的索引是多少\n\n\n![](/img/哈希查找.png)\n\n**哈希查找的过程：**\n\n比如说给定值是对象的内存地址，目标值是 side Tables 结构当中的下标索引\n\n现在给一个对象的内存指针地址，通过一个哈希函数把指针作为哈希函数的参数，然后经过函数的运算就可以得出一个数组的下标索引值\n哈希函数对于 side Tables 具体的情况，实际上表达式就是这样的，也就是说通过对象的内存地址来和 side Tables 数组的个数来进行取余运算，这样就可以计算出一个对象指针它所对应的引用计数表或者弱引用表在哪一张具体的 side Table 当中\n\n**为什么通过哈希查找？**\n\n是为了提高查找效率，比如说存储的时候是通过这个哈希函数进行存储的，比如说这个数组个数是8，内存地址假设是1的话，那么取余就是1，就把这个对象存储到数组对应第一个位置，当我们去访问这个对象的时候，也不需要根据这个数组进行遍历来比较指针值，而是也通过这个函数进行一次运算去取值，这个过程不涉及遍历的操作，自然查找效率是比较高的，内存地址的分布是均匀分布，可以称这个哈希函数为一个均匀散列函数","source":"_posts/内存管理--内存管理方案.md","raw":"---\ntitle: 内存管理(一)--内存管理方案\ndate: 2018-06-13 01:01:18\n\ndescription: 内存布局、内存管理方案\n\ncategories: 内存管理\ntags: [Objective-C]\n---\n\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## 内存布局\n\n ![](/img/内存布局.png)\n \n地址的表示是由下到上是低地址到高地址，比如说程序最终加载到内存被分成三段，分别对应未初始化区，已初始化区还有代码段，我们写的程序所有的代码一些数据段都在 .text 内存当中，声明的一些静态变量，全局变量，前提是已初始化的，都会放到已初始化数据区，对于未初始化的一些静态或者全局变量会放到未初始化数据区\n\n在 iOS 中定义的一些方法或者说函数都是在栈上进行工作的，栈是从高地址到低地址进行扩展，所以说栈是向下扩展或者说向下增长，在 iOS 开发过程中，创建的对象或者 block 经过 copy 之后，都会被转移到堆上面去，堆是向上增长的\n\n**不同内存段分别代表的详细含义**\n\n* stack：代表栈区，栈区一般都是方法调用\n* heap：对应的是堆区，通过 alloc 分配的一些对象实际上都是在堆上面提现的\n* bss：就是未初始化的全局变量以及一些未初始化的静态变量\n* data：代表的是已初始化的全局变量\n* text：程序的代码段，程序的代码加载到内存都是放在 text 段\n\n## 内存管理方案\n\n* TaggedPointer\n\n* NONPOINTER_ISA\n\n* 散列表\n\n系统针对不同场景下提出的内存管理方案:\n\n1. 对一些小对象，如 NSNumber 等，采用的是 TaggedPointer 内存管理方案（把指针指向的内容直接放在了指针变量的内存地址中）[戳这里](https://www.jianshu.com/p/e354f9137ba8)\n\n2. 对于64位架构下的 iOS 应用程序采用的是 NONPOINTER_ISA 内存管理方案\nNONPOINTER _ISA 内存管理方案的涵义：实际上在64位架构下 isa 这个指针本身是占64个 比特位的，那么实际上有32位或者说40位就够用了，剩余这些位数的比特位实际上是浪费的，苹果为了提高内存的利用率，在 isa 当中剩余的这些比特位当中，存储了一些关于内存管理当面的相关数据内容，所以说这个叫非指针型的 isa\n\n3. 散列表，散列表是一个很复杂的结构，其中包括了引用计数表和弱引用表  \n\n### 非指针型的 isa 内存管理方案 NONPOINTER_ISA \n\n ![](/img/NONPOINTER_ISA1.png)\n \n ![](/img/NONPOINTER_ISA2.png)\n\n在 arm64 架构下，isa 指针一共有 64 个bit位，这 64 个bit位都存储了哪些内容：\n\n* **第 0 位** 是一个叫 indexed 的标志位，如果这个位置是 0 ，代表的是我们使用的 isa 指针只是一个纯的 isa 指针，它里面的内容就直接代表当前对象的类对象的地址，如果这个标志位是 1 的话就代表这个 isa 里面存储的不止是它的类对象的地址，而且还有内存管理方面的数据，那就是我们这里面要讲到的非指针型的 isa \n* **第 1 位** has_assoc ，是表示当前对象是否有关联对象，0 代表没有，1代表有\n* **第 2 位** has_cxx_dtor ,这个函数或者说这个变量标志表示的是当前对象是否有使用 C++ 相关的代码，那么在 ARC 当中也可以这个表示位来表示有些对象是通过 ARC 来进行内存管理的\n* **3-35 位** 表示的是当前对象的类对象的指针地址（一共有33位01的bit来表示当前对象的类对象的指针地址，我们需要把这个这个位置全部拿出来再去计算它对应的类对象的实际的指针地址）\n* **36-41 位** 这 6 位代表的是 magic 字段（不讲解）\n* **42 位** 是 weakly_referenced 就标识了这个对象是否有相应的弱引用指针\n* **43 位** deallocating 标志当前对象是否正在进行 dealloc 操作\n* **44 位** has_sidetable_rc 这个0是指当前 isa 指针当中如果所存储的引用计数已经达到了上限的话，那么需要外挂一个 sidetable 数据结构去存储相关的引用计数内容，那就是接下里要讲解的散列表\n* **45-63 位** 代表的是 extra_rc 也就是额外的引用计数，当引用计数在很小的值范围之内的话就会存到 isa 指针当中，而不是有单独的引用计数表去存储它\n\n通过对 NONPOINTER_ ISA 的 64 个bit位的分析，就应该清楚关于内存管理不仅仅是散列表，其实还有 isa 部分的 extra_rc 来存储相关的引用计数值\n\n### 散列表内存管理方案\n\n ![](/img/散列表内存管理方案.png)\n\n散列表方案在源码中是通过 Side Tables() 结构来实现的\n\nSide Tables() 结构是什么？\n\n在他的结构下面挂了很多 Side Table 数据结构，这些数据结构在不同的架构上面是有不同个数的，比如在非嵌入式系统当中，Side Table 这个表一共有 64 个，在这里解释一下，Side Tables() 实际上是一个哈希表，可以通过一个对象指针来具体找到它对应的引用计数表或者说弱引用表在哪一张具体的 Side Table 当中\n\n**Side Table结构**\n\n实际上 Side Table 结构就包含了以下三个元素\n\n* 自旋锁\n* 引用计数表\n* 弱引用表\n\n**问题：为什么不是一个 SideTable，而是有多个 SideTable 共同组成 SideTables？**\n\n![](/img/为什么不是一个SideTable.png)\n\n假如说只有一张 SideTable ，那么在内存中分配的所有对象的引用计数或者说弱引用存储都放到一张大表当中，这个时候如果说要操作某一个对象的引用计数值进行修改，比如说加一减一的操作，由于所有的对象可能是在不同的线程当中去分配创建的，包括调用他们的 retain，release等方法也可能是在不同线程当中操作的，那么这个时候再对这张表进行操作的时候，需要进行加锁处理才能保证对数据的访问安全，在这个过程当中就存在了效率问题，如果现在已经有一个对象在操作这张表，那么下一个对象就要等前一个对象操作完后把锁释放之后它才能操作这张表\n\n**系统为了解决效率问题引用了分离锁的技术方案**\n\n![](/img/分离锁.png)\n\n可以把内存对象所对应的引用技术表可以分拆成多个部分，比如说把它分拆成8个，分拆成8个需要对这8个表分别加锁\n\n比如说某一个对象A在第一张表里面，另一个对象B在另一张表中，那么当A和B同时进行引用计数操作的时候可以并发操作，但是如果按照一张表的情况下他们就需要顺序操作\n\n**怎样实现快速分流？**\n\n快速分流指的是通过一个对象的指针如何快速的定位到它属于哪张 side Table 表？\n\n![](/img/怎样实现快速分流.png)\n\nside Tables 的本质是一张哈希表，这张哈希表当中可能有64张具体的 side Table ，然后存储不同对象的引用计数表和弱引用表\n\n**哈希表的概念这里简单讲解一下：**\n\n看这幅图，左侧是一个对象，这个对象指针可以作为一个 Key ，经过哈希函数的一个运算然后会计算出一个值来决定出这个对象它所对应的 side Table 是哪张或者说在数组的索引是多少\n\n\n![](/img/哈希查找.png)\n\n**哈希查找的过程：**\n\n比如说给定值是对象的内存地址，目标值是 side Tables 结构当中的下标索引\n\n现在给一个对象的内存指针地址，通过一个哈希函数把指针作为哈希函数的参数，然后经过函数的运算就可以得出一个数组的下标索引值\n哈希函数对于 side Tables 具体的情况，实际上表达式就是这样的，也就是说通过对象的内存地址来和 side Tables 数组的个数来进行取余运算，这样就可以计算出一个对象指针它所对应的引用计数表或者弱引用表在哪一张具体的 side Table 当中\n\n**为什么通过哈希查找？**\n\n是为了提高查找效率，比如说存储的时候是通过这个哈希函数进行存储的，比如说这个数组个数是8，内存地址假设是1的话，那么取余就是1，就把这个对象存储到数组对应第一个位置，当我们去访问这个对象的时候，也不需要根据这个数组进行遍历来比较指针值，而是也通过这个函数进行一次运算去取值，这个过程不涉及遍历的操作，自然查找效率是比较高的，内存地址的分布是均匀分布，可以称这个哈希函数为一个均匀散列函数","slug":"内存管理--内存管理方案","published":1,"updated":"2018-09-11T09:51:34.000Z","_id":"cjlxj6gce002r66r2uffmckxo","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><p> <img src=\"/img/内存布局.png\" alt=\"\"></p>\n<p>地址的表示是由下到上是低地址到高地址，比如说程序最终加载到内存被分成三段，分别对应未初始化区，已初始化区还有代码段，我们写的程序所有的代码一些数据段都在 .text 内存当中，声明的一些静态变量，全局变量，前提是已初始化的，都会放到已初始化数据区，对于未初始化的一些静态或者全局变量会放到未初始化数据区</p>\n<p>在 iOS 中定义的一些方法或者说函数都是在栈上进行工作的，栈是从高地址到低地址进行扩展，所以说栈是向下扩展或者说向下增长，在 iOS 开发过程中，创建的对象或者 block 经过 copy 之后，都会被转移到堆上面去，堆是向上增长的</p>\n<p><strong>不同内存段分别代表的详细含义</strong></p>\n<ul>\n<li>stack：代表栈区，栈区一般都是方法调用</li>\n<li>heap：对应的是堆区，通过 alloc 分配的一些对象实际上都是在堆上面提现的</li>\n<li>bss：就是未初始化的全局变量以及一些未初始化的静态变量</li>\n<li>data：代表的是已初始化的全局变量</li>\n<li>text：程序的代码段，程序的代码加载到内存都是放在 text 段</li>\n</ul>\n<h2 id=\"内存管理方案\"><a href=\"#内存管理方案\" class=\"headerlink\" title=\"内存管理方案\"></a>内存管理方案</h2><ul>\n<li><p>TaggedPointer</p>\n</li>\n<li><p>NONPOINTER_ISA</p>\n</li>\n<li><p>散列表</p>\n</li>\n</ul>\n<p>系统针对不同场景下提出的内存管理方案:</p>\n<ol>\n<li><p>对一些小对象，如 NSNumber 等，采用的是 TaggedPointer 内存管理方案（把指针指向的内容直接放在了指针变量的内存地址中）<a href=\"https://www.jianshu.com/p/e354f9137ba8\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n</li>\n<li><p>对于64位架构下的 iOS 应用程序采用的是 NONPOINTER_ISA 内存管理方案<br>NONPOINTER _ISA 内存管理方案的涵义：实际上在64位架构下 isa 这个指针本身是占64个 比特位的，那么实际上有32位或者说40位就够用了，剩余这些位数的比特位实际上是浪费的，苹果为了提高内存的利用率，在 isa 当中剩余的这些比特位当中，存储了一些关于内存管理当面的相关数据内容，所以说这个叫非指针型的 isa</p>\n</li>\n<li><p>散列表，散列表是一个很复杂的结构，其中包括了引用计数表和弱引用表  </p>\n</li>\n</ol>\n<h3 id=\"非指针型的-isa-内存管理方案-NONPOINTER-ISA\"><a href=\"#非指针型的-isa-内存管理方案-NONPOINTER-ISA\" class=\"headerlink\" title=\"非指针型的 isa 内存管理方案 NONPOINTER_ISA\"></a>非指针型的 isa 内存管理方案 NONPOINTER_ISA</h3><p> <img src=\"/img/NONPOINTER_ISA1.png\" alt=\"\"></p>\n<p> <img src=\"/img/NONPOINTER_ISA2.png\" alt=\"\"></p>\n<p>在 arm64 架构下，isa 指针一共有 64 个bit位，这 64 个bit位都存储了哪些内容：</p>\n<ul>\n<li><strong>第 0 位</strong> 是一个叫 indexed 的标志位，如果这个位置是 0 ，代表的是我们使用的 isa 指针只是一个纯的 isa 指针，它里面的内容就直接代表当前对象的类对象的地址，如果这个标志位是 1 的话就代表这个 isa 里面存储的不止是它的类对象的地址，而且还有内存管理方面的数据，那就是我们这里面要讲到的非指针型的 isa </li>\n<li><strong>第 1 位</strong> has_assoc ，是表示当前对象是否有关联对象，0 代表没有，1代表有</li>\n<li><strong>第 2 位</strong> has_cxx_dtor ,这个函数或者说这个变量标志表示的是当前对象是否有使用 C++ 相关的代码，那么在 ARC 当中也可以这个表示位来表示有些对象是通过 ARC 来进行内存管理的</li>\n<li><strong>3-35 位</strong> 表示的是当前对象的类对象的指针地址（一共有33位01的bit来表示当前对象的类对象的指针地址，我们需要把这个这个位置全部拿出来再去计算它对应的类对象的实际的指针地址）</li>\n<li><strong>36-41 位</strong> 这 6 位代表的是 magic 字段（不讲解）</li>\n<li><strong>42 位</strong> 是 weakly_referenced 就标识了这个对象是否有相应的弱引用指针</li>\n<li><strong>43 位</strong> deallocating 标志当前对象是否正在进行 dealloc 操作</li>\n<li><strong>44 位</strong> has_sidetable_rc 这个0是指当前 isa 指针当中如果所存储的引用计数已经达到了上限的话，那么需要外挂一个 sidetable 数据结构去存储相关的引用计数内容，那就是接下里要讲解的散列表</li>\n<li><strong>45-63 位</strong> 代表的是 extra_rc 也就是额外的引用计数，当引用计数在很小的值范围之内的话就会存到 isa 指针当中，而不是有单独的引用计数表去存储它</li>\n</ul>\n<p>通过对 NONPOINTER_ ISA 的 64 个bit位的分析，就应该清楚关于内存管理不仅仅是散列表，其实还有 isa 部分的 extra_rc 来存储相关的引用计数值</p>\n<h3 id=\"散列表内存管理方案\"><a href=\"#散列表内存管理方案\" class=\"headerlink\" title=\"散列表内存管理方案\"></a>散列表内存管理方案</h3><p> <img src=\"/img/散列表内存管理方案.png\" alt=\"\"></p>\n<p>散列表方案在源码中是通过 Side Tables() 结构来实现的</p>\n<p>Side Tables() 结构是什么？</p>\n<p>在他的结构下面挂了很多 Side Table 数据结构，这些数据结构在不同的架构上面是有不同个数的，比如在非嵌入式系统当中，Side Table 这个表一共有 64 个，在这里解释一下，Side Tables() 实际上是一个哈希表，可以通过一个对象指针来具体找到它对应的引用计数表或者说弱引用表在哪一张具体的 Side Table 当中</p>\n<p><strong>Side Table结构</strong></p>\n<p>实际上 Side Table 结构就包含了以下三个元素</p>\n<ul>\n<li>自旋锁</li>\n<li>引用计数表</li>\n<li>弱引用表</li>\n</ul>\n<p><strong>问题：为什么不是一个 SideTable，而是有多个 SideTable 共同组成 SideTables？</strong></p>\n<p><img src=\"/img/为什么不是一个SideTable.png\" alt=\"\"></p>\n<p>假如说只有一张 SideTable ，那么在内存中分配的所有对象的引用计数或者说弱引用存储都放到一张大表当中，这个时候如果说要操作某一个对象的引用计数值进行修改，比如说加一减一的操作，由于所有的对象可能是在不同的线程当中去分配创建的，包括调用他们的 retain，release等方法也可能是在不同线程当中操作的，那么这个时候再对这张表进行操作的时候，需要进行加锁处理才能保证对数据的访问安全，在这个过程当中就存在了效率问题，如果现在已经有一个对象在操作这张表，那么下一个对象就要等前一个对象操作完后把锁释放之后它才能操作这张表</p>\n<p><strong>系统为了解决效率问题引用了分离锁的技术方案</strong></p>\n<p><img src=\"/img/分离锁.png\" alt=\"\"></p>\n<p>可以把内存对象所对应的引用技术表可以分拆成多个部分，比如说把它分拆成8个，分拆成8个需要对这8个表分别加锁</p>\n<p>比如说某一个对象A在第一张表里面，另一个对象B在另一张表中，那么当A和B同时进行引用计数操作的时候可以并发操作，但是如果按照一张表的情况下他们就需要顺序操作</p>\n<p><strong>怎样实现快速分流？</strong></p>\n<p>快速分流指的是通过一个对象的指针如何快速的定位到它属于哪张 side Table 表？</p>\n<p><img src=\"/img/怎样实现快速分流.png\" alt=\"\"></p>\n<p>side Tables 的本质是一张哈希表，这张哈希表当中可能有64张具体的 side Table ，然后存储不同对象的引用计数表和弱引用表</p>\n<p><strong>哈希表的概念这里简单讲解一下：</strong></p>\n<p>看这幅图，左侧是一个对象，这个对象指针可以作为一个 Key ，经过哈希函数的一个运算然后会计算出一个值来决定出这个对象它所对应的 side Table 是哪张或者说在数组的索引是多少</p>\n<p><img src=\"/img/哈希查找.png\" alt=\"\"></p>\n<p><strong>哈希查找的过程：</strong></p>\n<p>比如说给定值是对象的内存地址，目标值是 side Tables 结构当中的下标索引</p>\n<p>现在给一个对象的内存指针地址，通过一个哈希函数把指针作为哈希函数的参数，然后经过函数的运算就可以得出一个数组的下标索引值<br>哈希函数对于 side Tables 具体的情况，实际上表达式就是这样的，也就是说通过对象的内存地址来和 side Tables 数组的个数来进行取余运算，这样就可以计算出一个对象指针它所对应的引用计数表或者弱引用表在哪一张具体的 side Table 当中</p>\n<p><strong>为什么通过哈希查找？</strong></p>\n<p>是为了提高查找效率，比如说存储的时候是通过这个哈希函数进行存储的，比如说这个数组个数是8，内存地址假设是1的话，那么取余就是1，就把这个对象存储到数组对应第一个位置，当我们去访问这个对象的时候，也不需要根据这个数组进行遍历来比较指针值，而是也通过这个函数进行一次运算去取值，这个过程不涉及遍历的操作，自然查找效率是比较高的，内存地址的分布是均匀分布，可以称这个哈希函数为一个均匀散列函数</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><p> <img src=\"/img/内存布局.png\" alt=\"\"></p>\n<p>地址的表示是由下到上是低地址到高地址，比如说程序最终加载到内存被分成三段，分别对应未初始化区，已初始化区还有代码段，我们写的程序所有的代码一些数据段都在 .text 内存当中，声明的一些静态变量，全局变量，前提是已初始化的，都会放到已初始化数据区，对于未初始化的一些静态或者全局变量会放到未初始化数据区</p>\n<p>在 iOS 中定义的一些方法或者说函数都是在栈上进行工作的，栈是从高地址到低地址进行扩展，所以说栈是向下扩展或者说向下增长，在 iOS 开发过程中，创建的对象或者 block 经过 copy 之后，都会被转移到堆上面去，堆是向上增长的</p>\n<p><strong>不同内存段分别代表的详细含义</strong></p>\n<ul>\n<li>stack：代表栈区，栈区一般都是方法调用</li>\n<li>heap：对应的是堆区，通过 alloc 分配的一些对象实际上都是在堆上面提现的</li>\n<li>bss：就是未初始化的全局变量以及一些未初始化的静态变量</li>\n<li>data：代表的是已初始化的全局变量</li>\n<li>text：程序的代码段，程序的代码加载到内存都是放在 text 段</li>\n</ul>\n<h2 id=\"内存管理方案\"><a href=\"#内存管理方案\" class=\"headerlink\" title=\"内存管理方案\"></a>内存管理方案</h2><ul>\n<li><p>TaggedPointer</p>\n</li>\n<li><p>NONPOINTER_ISA</p>\n</li>\n<li><p>散列表</p>\n</li>\n</ul>\n<p>系统针对不同场景下提出的内存管理方案:</p>\n<ol>\n<li><p>对一些小对象，如 NSNumber 等，采用的是 TaggedPointer 内存管理方案（把指针指向的内容直接放在了指针变量的内存地址中）<a href=\"https://www.jianshu.com/p/e354f9137ba8\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n</li>\n<li><p>对于64位架构下的 iOS 应用程序采用的是 NONPOINTER_ISA 内存管理方案<br>NONPOINTER _ISA 内存管理方案的涵义：实际上在64位架构下 isa 这个指针本身是占64个 比特位的，那么实际上有32位或者说40位就够用了，剩余这些位数的比特位实际上是浪费的，苹果为了提高内存的利用率，在 isa 当中剩余的这些比特位当中，存储了一些关于内存管理当面的相关数据内容，所以说这个叫非指针型的 isa</p>\n</li>\n<li><p>散列表，散列表是一个很复杂的结构，其中包括了引用计数表和弱引用表  </p>\n</li>\n</ol>\n<h3 id=\"非指针型的-isa-内存管理方案-NONPOINTER-ISA\"><a href=\"#非指针型的-isa-内存管理方案-NONPOINTER-ISA\" class=\"headerlink\" title=\"非指针型的 isa 内存管理方案 NONPOINTER_ISA\"></a>非指针型的 isa 内存管理方案 NONPOINTER_ISA</h3><p> <img src=\"/img/NONPOINTER_ISA1.png\" alt=\"\"></p>\n<p> <img src=\"/img/NONPOINTER_ISA2.png\" alt=\"\"></p>\n<p>在 arm64 架构下，isa 指针一共有 64 个bit位，这 64 个bit位都存储了哪些内容：</p>\n<ul>\n<li><strong>第 0 位</strong> 是一个叫 indexed 的标志位，如果这个位置是 0 ，代表的是我们使用的 isa 指针只是一个纯的 isa 指针，它里面的内容就直接代表当前对象的类对象的地址，如果这个标志位是 1 的话就代表这个 isa 里面存储的不止是它的类对象的地址，而且还有内存管理方面的数据，那就是我们这里面要讲到的非指针型的 isa </li>\n<li><strong>第 1 位</strong> has_assoc ，是表示当前对象是否有关联对象，0 代表没有，1代表有</li>\n<li><strong>第 2 位</strong> has_cxx_dtor ,这个函数或者说这个变量标志表示的是当前对象是否有使用 C++ 相关的代码，那么在 ARC 当中也可以这个表示位来表示有些对象是通过 ARC 来进行内存管理的</li>\n<li><strong>3-35 位</strong> 表示的是当前对象的类对象的指针地址（一共有33位01的bit来表示当前对象的类对象的指针地址，我们需要把这个这个位置全部拿出来再去计算它对应的类对象的实际的指针地址）</li>\n<li><strong>36-41 位</strong> 这 6 位代表的是 magic 字段（不讲解）</li>\n<li><strong>42 位</strong> 是 weakly_referenced 就标识了这个对象是否有相应的弱引用指针</li>\n<li><strong>43 位</strong> deallocating 标志当前对象是否正在进行 dealloc 操作</li>\n<li><strong>44 位</strong> has_sidetable_rc 这个0是指当前 isa 指针当中如果所存储的引用计数已经达到了上限的话，那么需要外挂一个 sidetable 数据结构去存储相关的引用计数内容，那就是接下里要讲解的散列表</li>\n<li><strong>45-63 位</strong> 代表的是 extra_rc 也就是额外的引用计数，当引用计数在很小的值范围之内的话就会存到 isa 指针当中，而不是有单独的引用计数表去存储它</li>\n</ul>\n<p>通过对 NONPOINTER_ ISA 的 64 个bit位的分析，就应该清楚关于内存管理不仅仅是散列表，其实还有 isa 部分的 extra_rc 来存储相关的引用计数值</p>\n<h3 id=\"散列表内存管理方案\"><a href=\"#散列表内存管理方案\" class=\"headerlink\" title=\"散列表内存管理方案\"></a>散列表内存管理方案</h3><p> <img src=\"/img/散列表内存管理方案.png\" alt=\"\"></p>\n<p>散列表方案在源码中是通过 Side Tables() 结构来实现的</p>\n<p>Side Tables() 结构是什么？</p>\n<p>在他的结构下面挂了很多 Side Table 数据结构，这些数据结构在不同的架构上面是有不同个数的，比如在非嵌入式系统当中，Side Table 这个表一共有 64 个，在这里解释一下，Side Tables() 实际上是一个哈希表，可以通过一个对象指针来具体找到它对应的引用计数表或者说弱引用表在哪一张具体的 Side Table 当中</p>\n<p><strong>Side Table结构</strong></p>\n<p>实际上 Side Table 结构就包含了以下三个元素</p>\n<ul>\n<li>自旋锁</li>\n<li>引用计数表</li>\n<li>弱引用表</li>\n</ul>\n<p><strong>问题：为什么不是一个 SideTable，而是有多个 SideTable 共同组成 SideTables？</strong></p>\n<p><img src=\"/img/为什么不是一个SideTable.png\" alt=\"\"></p>\n<p>假如说只有一张 SideTable ，那么在内存中分配的所有对象的引用计数或者说弱引用存储都放到一张大表当中，这个时候如果说要操作某一个对象的引用计数值进行修改，比如说加一减一的操作，由于所有的对象可能是在不同的线程当中去分配创建的，包括调用他们的 retain，release等方法也可能是在不同线程当中操作的，那么这个时候再对这张表进行操作的时候，需要进行加锁处理才能保证对数据的访问安全，在这个过程当中就存在了效率问题，如果现在已经有一个对象在操作这张表，那么下一个对象就要等前一个对象操作完后把锁释放之后它才能操作这张表</p>\n<p><strong>系统为了解决效率问题引用了分离锁的技术方案</strong></p>\n<p><img src=\"/img/分离锁.png\" alt=\"\"></p>\n<p>可以把内存对象所对应的引用技术表可以分拆成多个部分，比如说把它分拆成8个，分拆成8个需要对这8个表分别加锁</p>\n<p>比如说某一个对象A在第一张表里面，另一个对象B在另一张表中，那么当A和B同时进行引用计数操作的时候可以并发操作，但是如果按照一张表的情况下他们就需要顺序操作</p>\n<p><strong>怎样实现快速分流？</strong></p>\n<p>快速分流指的是通过一个对象的指针如何快速的定位到它属于哪张 side Table 表？</p>\n<p><img src=\"/img/怎样实现快速分流.png\" alt=\"\"></p>\n<p>side Tables 的本质是一张哈希表，这张哈希表当中可能有64张具体的 side Table ，然后存储不同对象的引用计数表和弱引用表</p>\n<p><strong>哈希表的概念这里简单讲解一下：</strong></p>\n<p>看这幅图，左侧是一个对象，这个对象指针可以作为一个 Key ，经过哈希函数的一个运算然后会计算出一个值来决定出这个对象它所对应的 side Table 是哪张或者说在数组的索引是多少</p>\n<p><img src=\"/img/哈希查找.png\" alt=\"\"></p>\n<p><strong>哈希查找的过程：</strong></p>\n<p>比如说给定值是对象的内存地址，目标值是 side Tables 结构当中的下标索引</p>\n<p>现在给一个对象的内存指针地址，通过一个哈希函数把指针作为哈希函数的参数，然后经过函数的运算就可以得出一个数组的下标索引值<br>哈希函数对于 side Tables 具体的情况，实际上表达式就是这样的，也就是说通过对象的内存地址来和 side Tables 数组的个数来进行取余运算，这样就可以计算出一个对象指针它所对应的引用计数表或者弱引用表在哪一张具体的 side Table 当中</p>\n<p><strong>为什么通过哈希查找？</strong></p>\n<p>是为了提高查找效率，比如说存储的时候是通过这个哈希函数进行存储的，比如说这个数组个数是8，内存地址假设是1的话，那么取余就是1，就把这个对象存储到数组对应第一个位置，当我们去访问这个对象的时候，也不需要根据这个数组进行遍历来比较指针值，而是也通过这个函数进行一次运算去取值，这个过程不涉及遍历的操作，自然查找效率是比较高的，内存地址的分布是均匀分布，可以称这个哈希函数为一个均匀散列函数</p>\n"},{"title":"iOS应用架构谈：本地持久化方案","date":"2018-03-18T03:23:33.000Z","description":"学习 casa 关于网层的架构设计思想，已应用于公司重构项目中","toc":false,"_content":"\n***\n[iOS应用架构谈：网络层框架的设计](https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/)\n[iOS应用架构谈：网络层框架的优化](https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/)\n[iOS应用架构谈：本地持久化方案](https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/)\n***\n\n1. 根据需求决定持久化方案\n2. 持久层与业务层之间的隔离\n3. 持久层与业务层的交互方式\n4. 数据迁移方案\n5. 数据同步方案\n\n## 根据需求决定持久化方案\n\n### 1、NSUserDefault\n\n一般来说，小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。\n\n### 2、keychain\n\nKeychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。\n\n### 3、文件存储\n\n文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体<NSCoding>中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。\n\n### 4、归档操作（NSkeyedArchiver）\n\n可以把自定义对象存放在文件中。\n\n### 5、数据库存储\n\n数据库存储的话，花样就比较多了。苹果自带了一个Core Data，当然业界也有无数替代方案可选，不过真正用在iOS领域的除了Core Data外，就是FMDB比较多了。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好，而且尤其是当这些状态和类别都是强业务相关的时候，就更加要采用数据库方案了。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。\n\n**总的说一下：**NSUserDefault、Keychain、File这些持久化方案都非常简单基础，分清楚什么时候用什么就可以了，不要像天猫那样乱写就好。而且在这之上并不会有更复杂的衍生需求，如果真的要针对它们写文章，无非就是写怎么储存怎么读取，这个大家随便Google一下就有了，我就不浪费笔墨了。由于大多数衍生复杂需求都是通过采用基于数据库的持久化方案去满足，所以这篇文章的重点就数据库相关的架构方案设计和实现。如果文章中有哪些问题我没有写到的，大家可以在评论区提问，我会一一解答或者直接把遗漏的内容补充在文章中。\n\n\n## 持久层实现时要注意的隔离\n\n\n在设计持久层架构的时候，我们要关注以下几个方面的隔离：\n\n\n1. 持久层与业务层的隔离\n2. 数据库读写隔离\n3. 多线程控制导致的隔离\n4. 数据表达和数据操作的隔离\n\n### 1. 持久层与业务层的隔离\n\n**关于Model**\n\n在具体讲持久层下数据的处理之前，我觉得需要针对这个问题做一个完整的分析。\n\n在View层设计中我分别提到了胖Model和瘦Model的设计思路，而且告诉大家我更加倾向于胖Model的设计思路。在网络层设计里面我使用了去Model化的思路设计了APIMananger与业务层的数据交互。这两个看似矛盾的关于Model的设计思路在我接下来要提出的持久层方案中其实是并不矛盾，而且是相互配合的。在网络层设计这篇文章中，我对去Model化只给出了思路和做法，相关的解释并不多，是因为要解释这个问题涉及面会比较广，写的时候并不认为在那篇文章里做解释是最好的时机。由于持久层在这里胖Model和去Model化都会涉及，所以我觉得在讲持久层的时候解释这个话题会比较好。\n\n我在跟别的各种领域的架构师交流的时候，发现大家都会或多或少地混用Model和Model Layer的概念，然后往往导致大家讨论的问题最后都不在一个点上，说Model的时候他跟你说Model Layer，那好吧，我就跟你说Model Layer，结果他又在说Model，于是问题就讨论不下去了。我觉得作为架构师，如果不分清楚这两个概念，肯定是会对你设计的架构的质量有很大影响的。\n\n如果把Model说成Data Model，然后跟Model Layer放在一起，这样就能够很容易区分概念了。\n\n**Data Model**\n\nData Model这个术语针对的问题领域是业务数据的建模，以及代码中这一数据模型的表征方式。两者相辅相承：因为业务数据的建模方案以及业务本身特点，而最终决定了数据的表征方式。同样操作一批数据，你的数据建模方案基本都是细化业务问题之后，抽象得出一个逻辑上的实体。在实现这个业务时，你可以选择不同的表征方式来表征这个逻辑上的实体，比如字节流(TCP包等)，字符串流(JSON、XML等)，对象流。对象流又分通用数据对象(NSDictionary等)，业务数据对象(HomeCellModel等)。\n\n前面已经遍历了所有的Data Model的形式。在习惯上，当我们讨论Model化时，都是单指对象流中的业务数据对象这一种。然而去Model化就是指：更多地使用通用数据对象去表征数据，业务数据对象不会在设计时被优先考虑的一种设计倾向。这里的通用数据对象可以在某种程度上理解为范型。\n\n**Model Layer**\n\nModel Layer描述的问题领域是如何对数据进行增删改查(CURD, Create Update Read Delete)，和相关业务处理。一般来说如果在Model Layer中采用瘦Model的设计思路的话，就差不多到CURD为止了。胖Model还会关心如何为需要数据的上层提供除了增删改查以外的服务，并为他们提供相应的解决方案。例如缓存、数据同步、弱业务处理等。\n\n**我的倾向**\n\n我更加倾向于去Model化的设计，在网络层我设计了reformer来实现去Model化。在持久层，我设计了Virtual Record来实现去Model化。\n\n因为具体的Model是一种很容易引入耦合的做法，在尽可能弱化Model概念的同时，就能够为引入业务和对接业务提供充分的空间。同时，也能通过去Model的设计达到区分强弱业务的目的，这在将来的代码迁移和维护中，是至关重要的。很多设计不好的架构，就在于架构师并没有认识到区分强弱业务的重要性，所以就导致架构腐化的速度很快，越来越难维护。\n\n所以说回来，持久层与业务层之间的隔离，是通过强弱业务的隔离达到的。而Virtual Record正是因为这种去Model化的设计，从而达到了强弱业务的隔离，进而做到持久层与业务层之间既隔离同时又能交互的平衡。具体Virtual Record是什么样的设计，我在后面会给大家分析。\n\n### 2. 数据库读写隔离\n\n在网站的架构中，对数据库进行读写分离主要是为了提高响应速度。在iOS应用架构中，对持久层进行读写隔离的设计主要是为了提高代码的可维护性。这也是两个领域要求架构师在设计架构时要求侧重点不同的一个方面。\n\n在这里我们所谓的读写隔离并不是指将数据的读操作和写操作做隔离。而是以某一条界限为准，在这个界限以外的所有数据模型，都是不可写不可修改，或者修改属性的行为不影响数据库中的数据。在这个界限以内的数据是可写可修改的。一般来说我们在设计时划分的这个界限会和持久层与业务层之间的界限保持一致，也就是业务层从持久层拿到数据之后，都不可写不可修改，或业务层针对这一数据模型的写操作、修改操作都对数据库文件中的内容不产生作用。只有持久层中的操作才能够对数据库文件中的内容产生作用。\n\n在苹果官方提供的持久层方案Core Data的架构设计中，并没有针对读写作出隔离，数据的结果都是以NSManagedObject扔出。所以只要业务工程师稍微一不小心动一下某个属性，NSManagedObjectContext在save的时候就会把这个修改给存进去了。另外，当我们需要对所有的增删改查操作做AOP的切片时，Core Data技术栈的实现就会非常复杂。\n\n整体上看，我觉得Core Data相对大部分需求而言是过度设计了。我当时设计安居客聊天模块的持久层时就采用了Core Data，然后为了读写隔离，将所有扔出来的NSManagedObject都转为了普通的对象。另外，由于聊天记录的业务相当复杂，使用Core Data之后为了完成需求不得不引入很多Hack的手段，这种做法在一定程度上降低了这个持久层的可维护性和提高了接手模块的工程师的学习曲线，这是不太好的。在天猫客户端，我去的时候天猫这个App就已经属于基本毫无持久层可言了，比较混乱。只能依靠各个业务线各显神通去解决数据持久化的需求，难以推动统一的持久层方案，这对于项目维护尤其是跨业务项目合作来说，基本就和车祸现场没啥区别。我现在已经从天猫离职，读者中若是有阿里人想升职想刷存在感拿3.75的，可以考虑给天猫搞个统一的持久层方案。\n\n读写隔离还能够便于加入AOP切点，因为针对数据库的写操作被隔离到一个固定的地方，加AOP时就很容易在正确的地方放入切片。这个会在讲到数据同步方案时看到应用。\n\n### 3. 多线程导致的隔离\n\n**Core Data**\n\nCore Data要求在多线程场景下，为异步操作再生成一个NSManagedObjectContext，然后设置它的ConcurrencyType为NSPrivateQueueConcurrencyType，最后把这个Context的parentContext设为Main线程下的Context。这相比于使用原始的SQLite去做多线程要轻松许多。只不过要注意的是，如果要传递NSManagedObject的时候，不能直接传这个对象的指针，要传NSManagedObjectID。这属于多线程环境下对象传递的隔离，在进行架构设计的时候需要注意。\n\n**SQLite**\n\n纯SQLite其实对于多线程倒是直接支持，SQLite库提供了三种方式：Single Thread，Multi Thread，Serialized。\n\nSingle Thread模式不是线程安全的，不提供任何同步机制。Multi Thread模式要求database connection不能在多线程中共享，其他的在使用上就没什么特殊限制了。Serialized模式顾名思义就是由一个串行队列来执行所有的操作，对于使用者来说除了响应速度会慢一些，基本上就没什么限制了。大多数情况下SQLite的默认模式是Serialized。\n\n根据Core Data在多线程场景下的表现，我觉得Core Data在使用SQLite作为数据载体时，使用的应该就是Multi Thread模式。SQLite在Multi Thread模式下使用的是读写锁，而且是针对整个数据库加锁，不是表锁也不是行锁，这一点需要提醒各位架构师注意。如果对响应速度要求很高的话，建议开一个辅助数据库，把一个大的写入任务先写入辅助数据库，然后拆成几个小的写入任务见缝插针地隔一段时间往主数据库中写入一次，写完之后再把辅助数据库删掉。\n\n不过从实际经验上看，本地App的持久化需求的读写操作一般都不会大，只要注意好几个点之后一般都不会影响用户体验。因此相比于Multi Thread模式，Serialized模式我认为是性价比比较高的一种选择，代码容易写容易维护，性能损失不大。为了提高几十毫秒的性能而牺牲代码的维护性，我是觉得划不来的。\n\n### 4. 数据表达和数据操作的隔离\n\n这是最容易被忽视的一点，数据表达和数据操作的隔离是否能够做好，直接影响的是整个程序的可拓展性。\n\n长久以来，我们都很习惯Active Record类型的数据操作和表达方式，例如这样：\n\n```\nRecord *record = [[Record alloc] init];\nrecord.data = @\"data\";\n[record save];\n```\n\n或者这样\n\n```\nRecord *record = [[Record alloc] init];\nNSArray *result = [record fetchList];\n```\n\n简单说就是，让一个对象映射了一个数据库里的表，然后针对这个对象做操作就等同于针对这个表以及这个对象所表达的数据做操作。这里有一个不好的地方就在于，这个Record既是数据库中数据表的映射，又是这个表中某一条数据的映射。我见过很多框架(不仅限于iOS，包括Python, PHP等)都把这两者混在一起去处理。如果按照这种不恰当的方式来组织数据操作和数据表达，在胖Model的实践下会导致强弱业务难以区分从而造成非常大的困难。使用瘦Model这种实践本身就是我认为有缺点的，具体的我在开篇中已经讲过，这里就不细说了。\n\n强弱业务不能区分带来的最大困难在于代码复用和迁移，因为持久层中的强业务对View层业务的高耦合是无法避免的，然而弱业务相对而言只对下层有耦合关系对上层并不存在耦合关系，当我们做代码迁移或者复用时，往往希望复用的是弱业务而不是强业务，若此时强弱业务分不开，代码复用就无从谈起，迁移时就倍加困难。\n\n另外，数据操作和数据表达混在一起会导致的问题在于：客观情况下，数据在view层业务上的表达方式多种多样，有可能是个View，也有可能是个别的什么对象。如果采用映射数据库表的数据对象去映射数据，那么这种多样性就会被限制，实际编码时每到使用数据的地方，就不得不多一层转换。\n\n我认为之所以会产生这样不好的做法原因在于，对象对数据表的映射和对象对数据表达的映射结果非常相似，尤其是在表达Column时，他们几乎就是一模一样。在这里要做好针对数据表或是针对数据的映射要做的区分的关键要点是：这个映射对象的操作着手点相对数据表而言，是对内还是对外操作。如果是对内操作，那么这个操作范围就仅限于当前数据表，这些操作映射给数据表模型就比较合适。如果是对外操作，执行这些操作时有可能涉及其他的数据表，那么这些操作就不应该映射到数据表对象中。\n\n因此实际操作中，我是以数据表为单位去针对操作进行对象封装，然后再针对数据记录进行对象封装。数据表中的操作都是针对记录的普通增删改查操作，都是弱业务逻辑。数据记录仅仅是数据的表达方式，这些操作最好交付给数据层分管强业务的对象去执行。具体内容我在下文还会继续说。\n","source":"_posts/iOS应用架构谈：本地持久化方案及动态部署.md","raw":"---\ntitle: iOS应用架构谈：本地持久化方案\ndate: 2018-3-18 11:23:33\n\ndescription: 学习 casa 关于网层的架构设计思想，已应用于公司重构项目中\n\ncategories: [iOS,三方框架]\ntags: [Objective-C]\ntoc: false \n---\n\n***\n[iOS应用架构谈：网络层框架的设计](https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/)\n[iOS应用架构谈：网络层框架的优化](https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/)\n[iOS应用架构谈：本地持久化方案](https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/)\n***\n\n1. 根据需求决定持久化方案\n2. 持久层与业务层之间的隔离\n3. 持久层与业务层的交互方式\n4. 数据迁移方案\n5. 数据同步方案\n\n## 根据需求决定持久化方案\n\n### 1、NSUserDefault\n\n一般来说，小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。\n\n### 2、keychain\n\nKeychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。\n\n### 3、文件存储\n\n文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体<NSCoding>中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。\n\n### 4、归档操作（NSkeyedArchiver）\n\n可以把自定义对象存放在文件中。\n\n### 5、数据库存储\n\n数据库存储的话，花样就比较多了。苹果自带了一个Core Data，当然业界也有无数替代方案可选，不过真正用在iOS领域的除了Core Data外，就是FMDB比较多了。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好，而且尤其是当这些状态和类别都是强业务相关的时候，就更加要采用数据库方案了。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。\n\n**总的说一下：**NSUserDefault、Keychain、File这些持久化方案都非常简单基础，分清楚什么时候用什么就可以了，不要像天猫那样乱写就好。而且在这之上并不会有更复杂的衍生需求，如果真的要针对它们写文章，无非就是写怎么储存怎么读取，这个大家随便Google一下就有了，我就不浪费笔墨了。由于大多数衍生复杂需求都是通过采用基于数据库的持久化方案去满足，所以这篇文章的重点就数据库相关的架构方案设计和实现。如果文章中有哪些问题我没有写到的，大家可以在评论区提问，我会一一解答或者直接把遗漏的内容补充在文章中。\n\n\n## 持久层实现时要注意的隔离\n\n\n在设计持久层架构的时候，我们要关注以下几个方面的隔离：\n\n\n1. 持久层与业务层的隔离\n2. 数据库读写隔离\n3. 多线程控制导致的隔离\n4. 数据表达和数据操作的隔离\n\n### 1. 持久层与业务层的隔离\n\n**关于Model**\n\n在具体讲持久层下数据的处理之前，我觉得需要针对这个问题做一个完整的分析。\n\n在View层设计中我分别提到了胖Model和瘦Model的设计思路，而且告诉大家我更加倾向于胖Model的设计思路。在网络层设计里面我使用了去Model化的思路设计了APIMananger与业务层的数据交互。这两个看似矛盾的关于Model的设计思路在我接下来要提出的持久层方案中其实是并不矛盾，而且是相互配合的。在网络层设计这篇文章中，我对去Model化只给出了思路和做法，相关的解释并不多，是因为要解释这个问题涉及面会比较广，写的时候并不认为在那篇文章里做解释是最好的时机。由于持久层在这里胖Model和去Model化都会涉及，所以我觉得在讲持久层的时候解释这个话题会比较好。\n\n我在跟别的各种领域的架构师交流的时候，发现大家都会或多或少地混用Model和Model Layer的概念，然后往往导致大家讨论的问题最后都不在一个点上，说Model的时候他跟你说Model Layer，那好吧，我就跟你说Model Layer，结果他又在说Model，于是问题就讨论不下去了。我觉得作为架构师，如果不分清楚这两个概念，肯定是会对你设计的架构的质量有很大影响的。\n\n如果把Model说成Data Model，然后跟Model Layer放在一起，这样就能够很容易区分概念了。\n\n**Data Model**\n\nData Model这个术语针对的问题领域是业务数据的建模，以及代码中这一数据模型的表征方式。两者相辅相承：因为业务数据的建模方案以及业务本身特点，而最终决定了数据的表征方式。同样操作一批数据，你的数据建模方案基本都是细化业务问题之后，抽象得出一个逻辑上的实体。在实现这个业务时，你可以选择不同的表征方式来表征这个逻辑上的实体，比如字节流(TCP包等)，字符串流(JSON、XML等)，对象流。对象流又分通用数据对象(NSDictionary等)，业务数据对象(HomeCellModel等)。\n\n前面已经遍历了所有的Data Model的形式。在习惯上，当我们讨论Model化时，都是单指对象流中的业务数据对象这一种。然而去Model化就是指：更多地使用通用数据对象去表征数据，业务数据对象不会在设计时被优先考虑的一种设计倾向。这里的通用数据对象可以在某种程度上理解为范型。\n\n**Model Layer**\n\nModel Layer描述的问题领域是如何对数据进行增删改查(CURD, Create Update Read Delete)，和相关业务处理。一般来说如果在Model Layer中采用瘦Model的设计思路的话，就差不多到CURD为止了。胖Model还会关心如何为需要数据的上层提供除了增删改查以外的服务，并为他们提供相应的解决方案。例如缓存、数据同步、弱业务处理等。\n\n**我的倾向**\n\n我更加倾向于去Model化的设计，在网络层我设计了reformer来实现去Model化。在持久层，我设计了Virtual Record来实现去Model化。\n\n因为具体的Model是一种很容易引入耦合的做法，在尽可能弱化Model概念的同时，就能够为引入业务和对接业务提供充分的空间。同时，也能通过去Model的设计达到区分强弱业务的目的，这在将来的代码迁移和维护中，是至关重要的。很多设计不好的架构，就在于架构师并没有认识到区分强弱业务的重要性，所以就导致架构腐化的速度很快，越来越难维护。\n\n所以说回来，持久层与业务层之间的隔离，是通过强弱业务的隔离达到的。而Virtual Record正是因为这种去Model化的设计，从而达到了强弱业务的隔离，进而做到持久层与业务层之间既隔离同时又能交互的平衡。具体Virtual Record是什么样的设计，我在后面会给大家分析。\n\n### 2. 数据库读写隔离\n\n在网站的架构中，对数据库进行读写分离主要是为了提高响应速度。在iOS应用架构中，对持久层进行读写隔离的设计主要是为了提高代码的可维护性。这也是两个领域要求架构师在设计架构时要求侧重点不同的一个方面。\n\n在这里我们所谓的读写隔离并不是指将数据的读操作和写操作做隔离。而是以某一条界限为准，在这个界限以外的所有数据模型，都是不可写不可修改，或者修改属性的行为不影响数据库中的数据。在这个界限以内的数据是可写可修改的。一般来说我们在设计时划分的这个界限会和持久层与业务层之间的界限保持一致，也就是业务层从持久层拿到数据之后，都不可写不可修改，或业务层针对这一数据模型的写操作、修改操作都对数据库文件中的内容不产生作用。只有持久层中的操作才能够对数据库文件中的内容产生作用。\n\n在苹果官方提供的持久层方案Core Data的架构设计中，并没有针对读写作出隔离，数据的结果都是以NSManagedObject扔出。所以只要业务工程师稍微一不小心动一下某个属性，NSManagedObjectContext在save的时候就会把这个修改给存进去了。另外，当我们需要对所有的增删改查操作做AOP的切片时，Core Data技术栈的实现就会非常复杂。\n\n整体上看，我觉得Core Data相对大部分需求而言是过度设计了。我当时设计安居客聊天模块的持久层时就采用了Core Data，然后为了读写隔离，将所有扔出来的NSManagedObject都转为了普通的对象。另外，由于聊天记录的业务相当复杂，使用Core Data之后为了完成需求不得不引入很多Hack的手段，这种做法在一定程度上降低了这个持久层的可维护性和提高了接手模块的工程师的学习曲线，这是不太好的。在天猫客户端，我去的时候天猫这个App就已经属于基本毫无持久层可言了，比较混乱。只能依靠各个业务线各显神通去解决数据持久化的需求，难以推动统一的持久层方案，这对于项目维护尤其是跨业务项目合作来说，基本就和车祸现场没啥区别。我现在已经从天猫离职，读者中若是有阿里人想升职想刷存在感拿3.75的，可以考虑给天猫搞个统一的持久层方案。\n\n读写隔离还能够便于加入AOP切点，因为针对数据库的写操作被隔离到一个固定的地方，加AOP时就很容易在正确的地方放入切片。这个会在讲到数据同步方案时看到应用。\n\n### 3. 多线程导致的隔离\n\n**Core Data**\n\nCore Data要求在多线程场景下，为异步操作再生成一个NSManagedObjectContext，然后设置它的ConcurrencyType为NSPrivateQueueConcurrencyType，最后把这个Context的parentContext设为Main线程下的Context。这相比于使用原始的SQLite去做多线程要轻松许多。只不过要注意的是，如果要传递NSManagedObject的时候，不能直接传这个对象的指针，要传NSManagedObjectID。这属于多线程环境下对象传递的隔离，在进行架构设计的时候需要注意。\n\n**SQLite**\n\n纯SQLite其实对于多线程倒是直接支持，SQLite库提供了三种方式：Single Thread，Multi Thread，Serialized。\n\nSingle Thread模式不是线程安全的，不提供任何同步机制。Multi Thread模式要求database connection不能在多线程中共享，其他的在使用上就没什么特殊限制了。Serialized模式顾名思义就是由一个串行队列来执行所有的操作，对于使用者来说除了响应速度会慢一些，基本上就没什么限制了。大多数情况下SQLite的默认模式是Serialized。\n\n根据Core Data在多线程场景下的表现，我觉得Core Data在使用SQLite作为数据载体时，使用的应该就是Multi Thread模式。SQLite在Multi Thread模式下使用的是读写锁，而且是针对整个数据库加锁，不是表锁也不是行锁，这一点需要提醒各位架构师注意。如果对响应速度要求很高的话，建议开一个辅助数据库，把一个大的写入任务先写入辅助数据库，然后拆成几个小的写入任务见缝插针地隔一段时间往主数据库中写入一次，写完之后再把辅助数据库删掉。\n\n不过从实际经验上看，本地App的持久化需求的读写操作一般都不会大，只要注意好几个点之后一般都不会影响用户体验。因此相比于Multi Thread模式，Serialized模式我认为是性价比比较高的一种选择，代码容易写容易维护，性能损失不大。为了提高几十毫秒的性能而牺牲代码的维护性，我是觉得划不来的。\n\n### 4. 数据表达和数据操作的隔离\n\n这是最容易被忽视的一点，数据表达和数据操作的隔离是否能够做好，直接影响的是整个程序的可拓展性。\n\n长久以来，我们都很习惯Active Record类型的数据操作和表达方式，例如这样：\n\n```\nRecord *record = [[Record alloc] init];\nrecord.data = @\"data\";\n[record save];\n```\n\n或者这样\n\n```\nRecord *record = [[Record alloc] init];\nNSArray *result = [record fetchList];\n```\n\n简单说就是，让一个对象映射了一个数据库里的表，然后针对这个对象做操作就等同于针对这个表以及这个对象所表达的数据做操作。这里有一个不好的地方就在于，这个Record既是数据库中数据表的映射，又是这个表中某一条数据的映射。我见过很多框架(不仅限于iOS，包括Python, PHP等)都把这两者混在一起去处理。如果按照这种不恰当的方式来组织数据操作和数据表达，在胖Model的实践下会导致强弱业务难以区分从而造成非常大的困难。使用瘦Model这种实践本身就是我认为有缺点的，具体的我在开篇中已经讲过，这里就不细说了。\n\n强弱业务不能区分带来的最大困难在于代码复用和迁移，因为持久层中的强业务对View层业务的高耦合是无法避免的，然而弱业务相对而言只对下层有耦合关系对上层并不存在耦合关系，当我们做代码迁移或者复用时，往往希望复用的是弱业务而不是强业务，若此时强弱业务分不开，代码复用就无从谈起，迁移时就倍加困难。\n\n另外，数据操作和数据表达混在一起会导致的问题在于：客观情况下，数据在view层业务上的表达方式多种多样，有可能是个View，也有可能是个别的什么对象。如果采用映射数据库表的数据对象去映射数据，那么这种多样性就会被限制，实际编码时每到使用数据的地方，就不得不多一层转换。\n\n我认为之所以会产生这样不好的做法原因在于，对象对数据表的映射和对象对数据表达的映射结果非常相似，尤其是在表达Column时，他们几乎就是一模一样。在这里要做好针对数据表或是针对数据的映射要做的区分的关键要点是：这个映射对象的操作着手点相对数据表而言，是对内还是对外操作。如果是对内操作，那么这个操作范围就仅限于当前数据表，这些操作映射给数据表模型就比较合适。如果是对外操作，执行这些操作时有可能涉及其他的数据表，那么这些操作就不应该映射到数据表对象中。\n\n因此实际操作中，我是以数据表为单位去针对操作进行对象封装，然后再针对数据记录进行对象封装。数据表中的操作都是针对记录的普通增删改查操作，都是弱业务逻辑。数据记录仅仅是数据的表达方式，这些操作最好交付给数据层分管强业务的对象去执行。具体内容我在下文还会继续说。\n","slug":"iOS应用架构谈：本地持久化方案及动态部署","published":1,"updated":"2018-09-11T09:55:31.000Z","_id":"cjlxj6gcg002v66r2pi5ao9jn","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的设计</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：本地持久化方案</a></p>\n<hr>\n<ol>\n<li>根据需求决定持久化方案</li>\n<li>持久层与业务层之间的隔离</li>\n<li>持久层与业务层的交互方式</li>\n<li>数据迁移方案</li>\n<li>数据同步方案</li>\n</ol>\n<h2 id=\"根据需求决定持久化方案\"><a href=\"#根据需求决定持久化方案\" class=\"headerlink\" title=\"根据需求决定持久化方案\"></a>根据需求决定持久化方案</h2><h3 id=\"1、NSUserDefault\"><a href=\"#1、NSUserDefault\" class=\"headerlink\" title=\"1、NSUserDefault\"></a>1、NSUserDefault</h3><p>一般来说，小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。</p>\n<h3 id=\"2、keychain\"><a href=\"#2、keychain\" class=\"headerlink\" title=\"2、keychain\"></a>2、keychain</h3><p>Keychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。</p>\n<h3 id=\"3、文件存储\"><a href=\"#3、文件存储\" class=\"headerlink\" title=\"3、文件存储\"></a>3、文件存储</h3><p>文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体<nscoding>中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。</nscoding></p>\n<h3 id=\"4、归档操作（NSkeyedArchiver）\"><a href=\"#4、归档操作（NSkeyedArchiver）\" class=\"headerlink\" title=\"4、归档操作（NSkeyedArchiver）\"></a>4、归档操作（NSkeyedArchiver）</h3><p>可以把自定义对象存放在文件中。</p>\n<h3 id=\"5、数据库存储\"><a href=\"#5、数据库存储\" class=\"headerlink\" title=\"5、数据库存储\"></a>5、数据库存储</h3><p>数据库存储的话，花样就比较多了。苹果自带了一个Core Data，当然业界也有无数替代方案可选，不过真正用在iOS领域的除了Core Data外，就是FMDB比较多了。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好，而且尤其是当这些状态和类别都是强业务相关的时候，就更加要采用数据库方案了。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。</p>\n<p><strong>总的说一下：</strong>NSUserDefault、Keychain、File这些持久化方案都非常简单基础，分清楚什么时候用什么就可以了，不要像天猫那样乱写就好。而且在这之上并不会有更复杂的衍生需求，如果真的要针对它们写文章，无非就是写怎么储存怎么读取，这个大家随便Google一下就有了，我就不浪费笔墨了。由于大多数衍生复杂需求都是通过采用基于数据库的持久化方案去满足，所以这篇文章的重点就数据库相关的架构方案设计和实现。如果文章中有哪些问题我没有写到的，大家可以在评论区提问，我会一一解答或者直接把遗漏的内容补充在文章中。</p>\n<h2 id=\"持久层实现时要注意的隔离\"><a href=\"#持久层实现时要注意的隔离\" class=\"headerlink\" title=\"持久层实现时要注意的隔离\"></a>持久层实现时要注意的隔离</h2><p>在设计持久层架构的时候，我们要关注以下几个方面的隔离：</p>\n<ol>\n<li>持久层与业务层的隔离</li>\n<li>数据库读写隔离</li>\n<li>多线程控制导致的隔离</li>\n<li>数据表达和数据操作的隔离</li>\n</ol>\n<h3 id=\"1-持久层与业务层的隔离\"><a href=\"#1-持久层与业务层的隔离\" class=\"headerlink\" title=\"1. 持久层与业务层的隔离\"></a>1. 持久层与业务层的隔离</h3><p><strong>关于Model</strong></p>\n<p>在具体讲持久层下数据的处理之前，我觉得需要针对这个问题做一个完整的分析。</p>\n<p>在View层设计中我分别提到了胖Model和瘦Model的设计思路，而且告诉大家我更加倾向于胖Model的设计思路。在网络层设计里面我使用了去Model化的思路设计了APIMananger与业务层的数据交互。这两个看似矛盾的关于Model的设计思路在我接下来要提出的持久层方案中其实是并不矛盾，而且是相互配合的。在网络层设计这篇文章中，我对去Model化只给出了思路和做法，相关的解释并不多，是因为要解释这个问题涉及面会比较广，写的时候并不认为在那篇文章里做解释是最好的时机。由于持久层在这里胖Model和去Model化都会涉及，所以我觉得在讲持久层的时候解释这个话题会比较好。</p>\n<p>我在跟别的各种领域的架构师交流的时候，发现大家都会或多或少地混用Model和Model Layer的概念，然后往往导致大家讨论的问题最后都不在一个点上，说Model的时候他跟你说Model Layer，那好吧，我就跟你说Model Layer，结果他又在说Model，于是问题就讨论不下去了。我觉得作为架构师，如果不分清楚这两个概念，肯定是会对你设计的架构的质量有很大影响的。</p>\n<p>如果把Model说成Data Model，然后跟Model Layer放在一起，这样就能够很容易区分概念了。</p>\n<p><strong>Data Model</strong></p>\n<p>Data Model这个术语针对的问题领域是业务数据的建模，以及代码中这一数据模型的表征方式。两者相辅相承：因为业务数据的建模方案以及业务本身特点，而最终决定了数据的表征方式。同样操作一批数据，你的数据建模方案基本都是细化业务问题之后，抽象得出一个逻辑上的实体。在实现这个业务时，你可以选择不同的表征方式来表征这个逻辑上的实体，比如字节流(TCP包等)，字符串流(JSON、XML等)，对象流。对象流又分通用数据对象(NSDictionary等)，业务数据对象(HomeCellModel等)。</p>\n<p>前面已经遍历了所有的Data Model的形式。在习惯上，当我们讨论Model化时，都是单指对象流中的业务数据对象这一种。然而去Model化就是指：更多地使用通用数据对象去表征数据，业务数据对象不会在设计时被优先考虑的一种设计倾向。这里的通用数据对象可以在某种程度上理解为范型。</p>\n<p><strong>Model Layer</strong></p>\n<p>Model Layer描述的问题领域是如何对数据进行增删改查(CURD, Create Update Read Delete)，和相关业务处理。一般来说如果在Model Layer中采用瘦Model的设计思路的话，就差不多到CURD为止了。胖Model还会关心如何为需要数据的上层提供除了增删改查以外的服务，并为他们提供相应的解决方案。例如缓存、数据同步、弱业务处理等。</p>\n<p><strong>我的倾向</strong></p>\n<p>我更加倾向于去Model化的设计，在网络层我设计了reformer来实现去Model化。在持久层，我设计了Virtual Record来实现去Model化。</p>\n<p>因为具体的Model是一种很容易引入耦合的做法，在尽可能弱化Model概念的同时，就能够为引入业务和对接业务提供充分的空间。同时，也能通过去Model的设计达到区分强弱业务的目的，这在将来的代码迁移和维护中，是至关重要的。很多设计不好的架构，就在于架构师并没有认识到区分强弱业务的重要性，所以就导致架构腐化的速度很快，越来越难维护。</p>\n<p>所以说回来，持久层与业务层之间的隔离，是通过强弱业务的隔离达到的。而Virtual Record正是因为这种去Model化的设计，从而达到了强弱业务的隔离，进而做到持久层与业务层之间既隔离同时又能交互的平衡。具体Virtual Record是什么样的设计，我在后面会给大家分析。</p>\n<h3 id=\"2-数据库读写隔离\"><a href=\"#2-数据库读写隔离\" class=\"headerlink\" title=\"2. 数据库读写隔离\"></a>2. 数据库读写隔离</h3><p>在网站的架构中，对数据库进行读写分离主要是为了提高响应速度。在iOS应用架构中，对持久层进行读写隔离的设计主要是为了提高代码的可维护性。这也是两个领域要求架构师在设计架构时要求侧重点不同的一个方面。</p>\n<p>在这里我们所谓的读写隔离并不是指将数据的读操作和写操作做隔离。而是以某一条界限为准，在这个界限以外的所有数据模型，都是不可写不可修改，或者修改属性的行为不影响数据库中的数据。在这个界限以内的数据是可写可修改的。一般来说我们在设计时划分的这个界限会和持久层与业务层之间的界限保持一致，也就是业务层从持久层拿到数据之后，都不可写不可修改，或业务层针对这一数据模型的写操作、修改操作都对数据库文件中的内容不产生作用。只有持久层中的操作才能够对数据库文件中的内容产生作用。</p>\n<p>在苹果官方提供的持久层方案Core Data的架构设计中，并没有针对读写作出隔离，数据的结果都是以NSManagedObject扔出。所以只要业务工程师稍微一不小心动一下某个属性，NSManagedObjectContext在save的时候就会把这个修改给存进去了。另外，当我们需要对所有的增删改查操作做AOP的切片时，Core Data技术栈的实现就会非常复杂。</p>\n<p>整体上看，我觉得Core Data相对大部分需求而言是过度设计了。我当时设计安居客聊天模块的持久层时就采用了Core Data，然后为了读写隔离，将所有扔出来的NSManagedObject都转为了普通的对象。另外，由于聊天记录的业务相当复杂，使用Core Data之后为了完成需求不得不引入很多Hack的手段，这种做法在一定程度上降低了这个持久层的可维护性和提高了接手模块的工程师的学习曲线，这是不太好的。在天猫客户端，我去的时候天猫这个App就已经属于基本毫无持久层可言了，比较混乱。只能依靠各个业务线各显神通去解决数据持久化的需求，难以推动统一的持久层方案，这对于项目维护尤其是跨业务项目合作来说，基本就和车祸现场没啥区别。我现在已经从天猫离职，读者中若是有阿里人想升职想刷存在感拿3.75的，可以考虑给天猫搞个统一的持久层方案。</p>\n<p>读写隔离还能够便于加入AOP切点，因为针对数据库的写操作被隔离到一个固定的地方，加AOP时就很容易在正确的地方放入切片。这个会在讲到数据同步方案时看到应用。</p>\n<h3 id=\"3-多线程导致的隔离\"><a href=\"#3-多线程导致的隔离\" class=\"headerlink\" title=\"3. 多线程导致的隔离\"></a>3. 多线程导致的隔离</h3><p><strong>Core Data</strong></p>\n<p>Core Data要求在多线程场景下，为异步操作再生成一个NSManagedObjectContext，然后设置它的ConcurrencyType为NSPrivateQueueConcurrencyType，最后把这个Context的parentContext设为Main线程下的Context。这相比于使用原始的SQLite去做多线程要轻松许多。只不过要注意的是，如果要传递NSManagedObject的时候，不能直接传这个对象的指针，要传NSManagedObjectID。这属于多线程环境下对象传递的隔离，在进行架构设计的时候需要注意。</p>\n<p><strong>SQLite</strong></p>\n<p>纯SQLite其实对于多线程倒是直接支持，SQLite库提供了三种方式：Single Thread，Multi Thread，Serialized。</p>\n<p>Single Thread模式不是线程安全的，不提供任何同步机制。Multi Thread模式要求database connection不能在多线程中共享，其他的在使用上就没什么特殊限制了。Serialized模式顾名思义就是由一个串行队列来执行所有的操作，对于使用者来说除了响应速度会慢一些，基本上就没什么限制了。大多数情况下SQLite的默认模式是Serialized。</p>\n<p>根据Core Data在多线程场景下的表现，我觉得Core Data在使用SQLite作为数据载体时，使用的应该就是Multi Thread模式。SQLite在Multi Thread模式下使用的是读写锁，而且是针对整个数据库加锁，不是表锁也不是行锁，这一点需要提醒各位架构师注意。如果对响应速度要求很高的话，建议开一个辅助数据库，把一个大的写入任务先写入辅助数据库，然后拆成几个小的写入任务见缝插针地隔一段时间往主数据库中写入一次，写完之后再把辅助数据库删掉。</p>\n<p>不过从实际经验上看，本地App的持久化需求的读写操作一般都不会大，只要注意好几个点之后一般都不会影响用户体验。因此相比于Multi Thread模式，Serialized模式我认为是性价比比较高的一种选择，代码容易写容易维护，性能损失不大。为了提高几十毫秒的性能而牺牲代码的维护性，我是觉得划不来的。</p>\n<h3 id=\"4-数据表达和数据操作的隔离\"><a href=\"#4-数据表达和数据操作的隔离\" class=\"headerlink\" title=\"4. 数据表达和数据操作的隔离\"></a>4. 数据表达和数据操作的隔离</h3><p>这是最容易被忽视的一点，数据表达和数据操作的隔离是否能够做好，直接影响的是整个程序的可拓展性。</p>\n<p>长久以来，我们都很习惯Active Record类型的数据操作和表达方式，例如这样：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Record</span> *<span class=\"keyword\">record</span> = [[<span class=\"keyword\">Record</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">record</span>.data = @<span class=\"string\">\"data\"</span>;</span><br><span class=\"line\">[<span class=\"keyword\">record</span> save];</span><br></pre></td></tr></table></figure>\n<p>或者这样</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Record</span> *<span class=\"keyword\">record</span> = [[<span class=\"keyword\">Record</span> alloc] init];</span><br><span class=\"line\">NSArray *<span class=\"keyword\">result</span> = [<span class=\"keyword\">record</span> fetchList];</span><br></pre></td></tr></table></figure>\n<p>简单说就是，让一个对象映射了一个数据库里的表，然后针对这个对象做操作就等同于针对这个表以及这个对象所表达的数据做操作。这里有一个不好的地方就在于，这个Record既是数据库中数据表的映射，又是这个表中某一条数据的映射。我见过很多框架(不仅限于iOS，包括Python, PHP等)都把这两者混在一起去处理。如果按照这种不恰当的方式来组织数据操作和数据表达，在胖Model的实践下会导致强弱业务难以区分从而造成非常大的困难。使用瘦Model这种实践本身就是我认为有缺点的，具体的我在开篇中已经讲过，这里就不细说了。</p>\n<p>强弱业务不能区分带来的最大困难在于代码复用和迁移，因为持久层中的强业务对View层业务的高耦合是无法避免的，然而弱业务相对而言只对下层有耦合关系对上层并不存在耦合关系，当我们做代码迁移或者复用时，往往希望复用的是弱业务而不是强业务，若此时强弱业务分不开，代码复用就无从谈起，迁移时就倍加困难。</p>\n<p>另外，数据操作和数据表达混在一起会导致的问题在于：客观情况下，数据在view层业务上的表达方式多种多样，有可能是个View，也有可能是个别的什么对象。如果采用映射数据库表的数据对象去映射数据，那么这种多样性就会被限制，实际编码时每到使用数据的地方，就不得不多一层转换。</p>\n<p>我认为之所以会产生这样不好的做法原因在于，对象对数据表的映射和对象对数据表达的映射结果非常相似，尤其是在表达Column时，他们几乎就是一模一样。在这里要做好针对数据表或是针对数据的映射要做的区分的关键要点是：这个映射对象的操作着手点相对数据表而言，是对内还是对外操作。如果是对内操作，那么这个操作范围就仅限于当前数据表，这些操作映射给数据表模型就比较合适。如果是对外操作，执行这些操作时有可能涉及其他的数据表，那么这些操作就不应该映射到数据表对象中。</p>\n<p>因此实际操作中，我是以数据表为单位去针对操作进行对象封装，然后再针对数据记录进行对象封装。数据表中的操作都是针对记录的普通增删改查操作，都是弱业务逻辑。数据记录仅仅是数据的表达方式，这些操作最好交付给数据层分管强业务的对象去执行。具体内容我在下文还会继续说。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/03/10/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的设计</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/15/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：网络层框架的优化</a><br><a href=\"https://xiaopengmonsters.github.io/2018/03/18/iOS%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E8%B0%88%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E5%8F%8A%E5%8A%A8%E6%80%81%E9%83%A8%E7%BD%B2/\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈：本地持久化方案</a></p>\n<hr>\n<ol>\n<li>根据需求决定持久化方案</li>\n<li>持久层与业务层之间的隔离</li>\n<li>持久层与业务层的交互方式</li>\n<li>数据迁移方案</li>\n<li>数据同步方案</li>\n</ol>\n<h2 id=\"根据需求决定持久化方案\"><a href=\"#根据需求决定持久化方案\" class=\"headerlink\" title=\"根据需求决定持久化方案\"></a>根据需求决定持久化方案</h2><h3 id=\"1、NSUserDefault\"><a href=\"#1、NSUserDefault\" class=\"headerlink\" title=\"1、NSUserDefault\"></a>1、NSUserDefault</h3><p>一般来说，小规模数据，弱业务相关数据，都可以放到NSUserDefault里面，内容比较多的数据，强业务相关的数据就不太适合NSUserDefault了。</p>\n<h3 id=\"2、keychain\"><a href=\"#2、keychain\" class=\"headerlink\" title=\"2、keychain\"></a>2、keychain</h3><p>Keychain是苹果提供的带有可逆加密的存储机制，普遍用在各种存密码的需求上。另外，由于App卸载只要系统不重装，Keychain中的数据依旧能够得到保留，以及可被iCloud同步的特性，大家都会在这里存储用户唯一标识串。所以有需要加密、需要存iCloud的敏感小数据，一般都会放在Keychain。</p>\n<h3 id=\"3、文件存储\"><a href=\"#3、文件存储\" class=\"headerlink\" title=\"3、文件存储\"></a>3、文件存储</h3><p>文件存储包括了Plist、archive、Stream等方式，一般结构化的数据或者需要方便查询的数据，都会以Plist的方式去持久化。Archive方式适合存储平时不太经常使用但很大量的数据，或者读取之后希望直接对象化的数据，因为Archive会将对象及其对象关系序列化，以至于读取数据的时候需要Decode很花时间，Decode的过程可以是解压，也可以是对象化，这个可以根据具体<nscoding>中的实现来决定。Stream就是一般的文件存储了，一般用来存存图片啊啥的，适用于比较经常使用，然而数据量又不算非常大的那种。</nscoding></p>\n<h3 id=\"4、归档操作（NSkeyedArchiver）\"><a href=\"#4、归档操作（NSkeyedArchiver）\" class=\"headerlink\" title=\"4、归档操作（NSkeyedArchiver）\"></a>4、归档操作（NSkeyedArchiver）</h3><p>可以把自定义对象存放在文件中。</p>\n<h3 id=\"5、数据库存储\"><a href=\"#5、数据库存储\" class=\"headerlink\" title=\"5、数据库存储\"></a>5、数据库存储</h3><p>数据库存储的话，花样就比较多了。苹果自带了一个Core Data，当然业界也有无数替代方案可选，不过真正用在iOS领域的除了Core Data外，就是FMDB比较多了。数据库方案主要是为了便于增删改查，当数据有状态和类别的时候最好还是采用数据库方案比较好，而且尤其是当这些状态和类别都是强业务相关的时候，就更加要采用数据库方案了。因为你不可能通过文件系统遍历文件去甄别你需要获取的属于某个状态或类别的数据，这么做成本就太大了。当然，特别大量的数据也不适合直接存储数据库，比如图片或者文章这样的数据，一般来说，都是数据库存一个文件名，然后这个文件名指向的是某个图片或者文章的文件。如果真的要做全文索引这种需求，建议最好还是挂个API丢到服务端去做。</p>\n<p><strong>总的说一下：</strong>NSUserDefault、Keychain、File这些持久化方案都非常简单基础，分清楚什么时候用什么就可以了，不要像天猫那样乱写就好。而且在这之上并不会有更复杂的衍生需求，如果真的要针对它们写文章，无非就是写怎么储存怎么读取，这个大家随便Google一下就有了，我就不浪费笔墨了。由于大多数衍生复杂需求都是通过采用基于数据库的持久化方案去满足，所以这篇文章的重点就数据库相关的架构方案设计和实现。如果文章中有哪些问题我没有写到的，大家可以在评论区提问，我会一一解答或者直接把遗漏的内容补充在文章中。</p>\n<h2 id=\"持久层实现时要注意的隔离\"><a href=\"#持久层实现时要注意的隔离\" class=\"headerlink\" title=\"持久层实现时要注意的隔离\"></a>持久层实现时要注意的隔离</h2><p>在设计持久层架构的时候，我们要关注以下几个方面的隔离：</p>\n<ol>\n<li>持久层与业务层的隔离</li>\n<li>数据库读写隔离</li>\n<li>多线程控制导致的隔离</li>\n<li>数据表达和数据操作的隔离</li>\n</ol>\n<h3 id=\"1-持久层与业务层的隔离\"><a href=\"#1-持久层与业务层的隔离\" class=\"headerlink\" title=\"1. 持久层与业务层的隔离\"></a>1. 持久层与业务层的隔离</h3><p><strong>关于Model</strong></p>\n<p>在具体讲持久层下数据的处理之前，我觉得需要针对这个问题做一个完整的分析。</p>\n<p>在View层设计中我分别提到了胖Model和瘦Model的设计思路，而且告诉大家我更加倾向于胖Model的设计思路。在网络层设计里面我使用了去Model化的思路设计了APIMananger与业务层的数据交互。这两个看似矛盾的关于Model的设计思路在我接下来要提出的持久层方案中其实是并不矛盾，而且是相互配合的。在网络层设计这篇文章中，我对去Model化只给出了思路和做法，相关的解释并不多，是因为要解释这个问题涉及面会比较广，写的时候并不认为在那篇文章里做解释是最好的时机。由于持久层在这里胖Model和去Model化都会涉及，所以我觉得在讲持久层的时候解释这个话题会比较好。</p>\n<p>我在跟别的各种领域的架构师交流的时候，发现大家都会或多或少地混用Model和Model Layer的概念，然后往往导致大家讨论的问题最后都不在一个点上，说Model的时候他跟你说Model Layer，那好吧，我就跟你说Model Layer，结果他又在说Model，于是问题就讨论不下去了。我觉得作为架构师，如果不分清楚这两个概念，肯定是会对你设计的架构的质量有很大影响的。</p>\n<p>如果把Model说成Data Model，然后跟Model Layer放在一起，这样就能够很容易区分概念了。</p>\n<p><strong>Data Model</strong></p>\n<p>Data Model这个术语针对的问题领域是业务数据的建模，以及代码中这一数据模型的表征方式。两者相辅相承：因为业务数据的建模方案以及业务本身特点，而最终决定了数据的表征方式。同样操作一批数据，你的数据建模方案基本都是细化业务问题之后，抽象得出一个逻辑上的实体。在实现这个业务时，你可以选择不同的表征方式来表征这个逻辑上的实体，比如字节流(TCP包等)，字符串流(JSON、XML等)，对象流。对象流又分通用数据对象(NSDictionary等)，业务数据对象(HomeCellModel等)。</p>\n<p>前面已经遍历了所有的Data Model的形式。在习惯上，当我们讨论Model化时，都是单指对象流中的业务数据对象这一种。然而去Model化就是指：更多地使用通用数据对象去表征数据，业务数据对象不会在设计时被优先考虑的一种设计倾向。这里的通用数据对象可以在某种程度上理解为范型。</p>\n<p><strong>Model Layer</strong></p>\n<p>Model Layer描述的问题领域是如何对数据进行增删改查(CURD, Create Update Read Delete)，和相关业务处理。一般来说如果在Model Layer中采用瘦Model的设计思路的话，就差不多到CURD为止了。胖Model还会关心如何为需要数据的上层提供除了增删改查以外的服务，并为他们提供相应的解决方案。例如缓存、数据同步、弱业务处理等。</p>\n<p><strong>我的倾向</strong></p>\n<p>我更加倾向于去Model化的设计，在网络层我设计了reformer来实现去Model化。在持久层，我设计了Virtual Record来实现去Model化。</p>\n<p>因为具体的Model是一种很容易引入耦合的做法，在尽可能弱化Model概念的同时，就能够为引入业务和对接业务提供充分的空间。同时，也能通过去Model的设计达到区分强弱业务的目的，这在将来的代码迁移和维护中，是至关重要的。很多设计不好的架构，就在于架构师并没有认识到区分强弱业务的重要性，所以就导致架构腐化的速度很快，越来越难维护。</p>\n<p>所以说回来，持久层与业务层之间的隔离，是通过强弱业务的隔离达到的。而Virtual Record正是因为这种去Model化的设计，从而达到了强弱业务的隔离，进而做到持久层与业务层之间既隔离同时又能交互的平衡。具体Virtual Record是什么样的设计，我在后面会给大家分析。</p>\n<h3 id=\"2-数据库读写隔离\"><a href=\"#2-数据库读写隔离\" class=\"headerlink\" title=\"2. 数据库读写隔离\"></a>2. 数据库读写隔离</h3><p>在网站的架构中，对数据库进行读写分离主要是为了提高响应速度。在iOS应用架构中，对持久层进行读写隔离的设计主要是为了提高代码的可维护性。这也是两个领域要求架构师在设计架构时要求侧重点不同的一个方面。</p>\n<p>在这里我们所谓的读写隔离并不是指将数据的读操作和写操作做隔离。而是以某一条界限为准，在这个界限以外的所有数据模型，都是不可写不可修改，或者修改属性的行为不影响数据库中的数据。在这个界限以内的数据是可写可修改的。一般来说我们在设计时划分的这个界限会和持久层与业务层之间的界限保持一致，也就是业务层从持久层拿到数据之后，都不可写不可修改，或业务层针对这一数据模型的写操作、修改操作都对数据库文件中的内容不产生作用。只有持久层中的操作才能够对数据库文件中的内容产生作用。</p>\n<p>在苹果官方提供的持久层方案Core Data的架构设计中，并没有针对读写作出隔离，数据的结果都是以NSManagedObject扔出。所以只要业务工程师稍微一不小心动一下某个属性，NSManagedObjectContext在save的时候就会把这个修改给存进去了。另外，当我们需要对所有的增删改查操作做AOP的切片时，Core Data技术栈的实现就会非常复杂。</p>\n<p>整体上看，我觉得Core Data相对大部分需求而言是过度设计了。我当时设计安居客聊天模块的持久层时就采用了Core Data，然后为了读写隔离，将所有扔出来的NSManagedObject都转为了普通的对象。另外，由于聊天记录的业务相当复杂，使用Core Data之后为了完成需求不得不引入很多Hack的手段，这种做法在一定程度上降低了这个持久层的可维护性和提高了接手模块的工程师的学习曲线，这是不太好的。在天猫客户端，我去的时候天猫这个App就已经属于基本毫无持久层可言了，比较混乱。只能依靠各个业务线各显神通去解决数据持久化的需求，难以推动统一的持久层方案，这对于项目维护尤其是跨业务项目合作来说，基本就和车祸现场没啥区别。我现在已经从天猫离职，读者中若是有阿里人想升职想刷存在感拿3.75的，可以考虑给天猫搞个统一的持久层方案。</p>\n<p>读写隔离还能够便于加入AOP切点，因为针对数据库的写操作被隔离到一个固定的地方，加AOP时就很容易在正确的地方放入切片。这个会在讲到数据同步方案时看到应用。</p>\n<h3 id=\"3-多线程导致的隔离\"><a href=\"#3-多线程导致的隔离\" class=\"headerlink\" title=\"3. 多线程导致的隔离\"></a>3. 多线程导致的隔离</h3><p><strong>Core Data</strong></p>\n<p>Core Data要求在多线程场景下，为异步操作再生成一个NSManagedObjectContext，然后设置它的ConcurrencyType为NSPrivateQueueConcurrencyType，最后把这个Context的parentContext设为Main线程下的Context。这相比于使用原始的SQLite去做多线程要轻松许多。只不过要注意的是，如果要传递NSManagedObject的时候，不能直接传这个对象的指针，要传NSManagedObjectID。这属于多线程环境下对象传递的隔离，在进行架构设计的时候需要注意。</p>\n<p><strong>SQLite</strong></p>\n<p>纯SQLite其实对于多线程倒是直接支持，SQLite库提供了三种方式：Single Thread，Multi Thread，Serialized。</p>\n<p>Single Thread模式不是线程安全的，不提供任何同步机制。Multi Thread模式要求database connection不能在多线程中共享，其他的在使用上就没什么特殊限制了。Serialized模式顾名思义就是由一个串行队列来执行所有的操作，对于使用者来说除了响应速度会慢一些，基本上就没什么限制了。大多数情况下SQLite的默认模式是Serialized。</p>\n<p>根据Core Data在多线程场景下的表现，我觉得Core Data在使用SQLite作为数据载体时，使用的应该就是Multi Thread模式。SQLite在Multi Thread模式下使用的是读写锁，而且是针对整个数据库加锁，不是表锁也不是行锁，这一点需要提醒各位架构师注意。如果对响应速度要求很高的话，建议开一个辅助数据库，把一个大的写入任务先写入辅助数据库，然后拆成几个小的写入任务见缝插针地隔一段时间往主数据库中写入一次，写完之后再把辅助数据库删掉。</p>\n<p>不过从实际经验上看，本地App的持久化需求的读写操作一般都不会大，只要注意好几个点之后一般都不会影响用户体验。因此相比于Multi Thread模式，Serialized模式我认为是性价比比较高的一种选择，代码容易写容易维护，性能损失不大。为了提高几十毫秒的性能而牺牲代码的维护性，我是觉得划不来的。</p>\n<h3 id=\"4-数据表达和数据操作的隔离\"><a href=\"#4-数据表达和数据操作的隔离\" class=\"headerlink\" title=\"4. 数据表达和数据操作的隔离\"></a>4. 数据表达和数据操作的隔离</h3><p>这是最容易被忽视的一点，数据表达和数据操作的隔离是否能够做好，直接影响的是整个程序的可拓展性。</p>\n<p>长久以来，我们都很习惯Active Record类型的数据操作和表达方式，例如这样：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Record</span> *<span class=\"keyword\">record</span> = [[<span class=\"keyword\">Record</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">record</span>.data = @<span class=\"string\">\"data\"</span>;</span><br><span class=\"line\">[<span class=\"keyword\">record</span> save];</span><br></pre></td></tr></table></figure>\n<p>或者这样</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Record</span> *<span class=\"keyword\">record</span> = [[<span class=\"keyword\">Record</span> alloc] init];</span><br><span class=\"line\">NSArray *<span class=\"keyword\">result</span> = [<span class=\"keyword\">record</span> fetchList];</span><br></pre></td></tr></table></figure>\n<p>简单说就是，让一个对象映射了一个数据库里的表，然后针对这个对象做操作就等同于针对这个表以及这个对象所表达的数据做操作。这里有一个不好的地方就在于，这个Record既是数据库中数据表的映射，又是这个表中某一条数据的映射。我见过很多框架(不仅限于iOS，包括Python, PHP等)都把这两者混在一起去处理。如果按照这种不恰当的方式来组织数据操作和数据表达，在胖Model的实践下会导致强弱业务难以区分从而造成非常大的困难。使用瘦Model这种实践本身就是我认为有缺点的，具体的我在开篇中已经讲过，这里就不细说了。</p>\n<p>强弱业务不能区分带来的最大困难在于代码复用和迁移，因为持久层中的强业务对View层业务的高耦合是无法避免的，然而弱业务相对而言只对下层有耦合关系对上层并不存在耦合关系，当我们做代码迁移或者复用时，往往希望复用的是弱业务而不是强业务，若此时强弱业务分不开，代码复用就无从谈起，迁移时就倍加困难。</p>\n<p>另外，数据操作和数据表达混在一起会导致的问题在于：客观情况下，数据在view层业务上的表达方式多种多样，有可能是个View，也有可能是个别的什么对象。如果采用映射数据库表的数据对象去映射数据，那么这种多样性就会被限制，实际编码时每到使用数据的地方，就不得不多一层转换。</p>\n<p>我认为之所以会产生这样不好的做法原因在于，对象对数据表的映射和对象对数据表达的映射结果非常相似，尤其是在表达Column时，他们几乎就是一模一样。在这里要做好针对数据表或是针对数据的映射要做的区分的关键要点是：这个映射对象的操作着手点相对数据表而言，是对内还是对外操作。如果是对内操作，那么这个操作范围就仅限于当前数据表，这些操作映射给数据表模型就比较合适。如果是对外操作，执行这些操作时有可能涉及其他的数据表，那么这些操作就不应该映射到数据表对象中。</p>\n<p>因此实际操作中，我是以数据表为单位去针对操作进行对象封装，然后再针对数据记录进行对象封装。数据表中的操作都是针对记录的普通增删改查操作，都是弱业务逻辑。数据记录仅仅是数据的表达方式，这些操作最好交付给数据层分管强业务的对象去执行。具体内容我在下文还会继续说。</p>\n"},{"title":"内存管理(六)--循环引用","date":"2018-06-02T17:01:18.000Z","description":"循环引用比较常见，为了让循环引用不在浪费开发，是时候来一篇文章总结了","_content":"\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## 循环引用介绍\n\n循环引用主要可以分为三种类型\n\n* 自循环引用\n* 相互循环引用\n* 多循环引用\n\n**自循环引用**\n\n ![](/img/自循环引用.png)\n \n 假如有一个对象，对象当中有一个成员变量 obj，这个对象是强持有他的成员变量，如果此时给这个成员变量 obj 赋值原对象的话，就造成自循环引用\n \n 相互循坏引用\n  \n ![](/img/相互循坏引用.png)\n \n 比如说有一个对象 A ，其中有一个 id 类型的 obj，还有一个对象 B 它当中也有一个 id 类型的 obj，如果此时对象 A 中的 obj 指向对象 B，同时对象 B 中的 obj 指向对象 A，此时就造成相互循坏引用\n \n 多循环引用\n \n  ![](/img/多循环引用.png)\n  \n  假如在某一个类当中，有对象 1，对象 2，对象 n，每一个对象当中都一个 id 类型的 obj，假如说此时每一个对象的 obj 都指向下一个对象，就产生了一个多循环引用\n  \n **循环引用考点**\n  \n* 代理（相互循环引用）\n* Block\n* NSTimer\n* 大环引用\n\n## 如何破除循环引用\n\n* 避免产生循环引用（比如使用代理过程中，两个对象一个使用强引用，一个使用弱引用）\n* 在合适的时机手动断环\n\n**破除循环引用具体的解决方案**\n\n* _ _weak （在使用代理、Block的时候会用到）\n* _ _block（一般使用在 Block 方面产生的循环引用问题）\n* _ _ unsafe_unretained（由这个关键字修饰的对象也没有增加引用计数，和 _ _weak 在效果上是等效的）\n\n**_ _weak 破解**\n\n避免产生循环应用的常用方案\n\n![](/img/避免产生循环应用的常用方案.png)\n\n假如说左侧的对象 A 和 右侧的对象 B 都有一个成员变量 id 类型的 obj，当把 对象 A 中的成员变量声明为 _ _weak 的时候，就可以破除相互循环引用\n对象 B 强持有 A ，而 A 弱引用 B，此时规避了循环引用\n\n**_ _block 破解**\n\n![](/img/__block破解.png)\n\n**_ _ unsafe_unretained 破解**\n\n![](/img/__unsafe_unretained破解.png)\n\n如果被修饰对象在某一时机被释放，再通过这个指针去访问原对象的话，会由于悬垂指针的原因导致内存泄露\n\n## 循环应用的示例\n\n* Block 的使用示例\n\n* NSTimeer 的使用示例\n\n### Block 的循环应用问题\n\n想了解 Block 的循环引用问题，请移驾 Block 章节的 [Block--Block 的循环应用]()\n\n### NSTimeer 的循环应用问题\n\n![](/img/NSTimeer的循环应用问题1.png)\n\n假如一个实际的场景：比如有一个页面，在这个页面当中有一个 banner 广告栏，需要在每一秒钟滚动一次，一般情况下会把 banner 广告栏的 UI 对象作为 VC 的一个成员变量，由 VC 对它进行强持有，那么由于 banner 需要每个一秒钟进行一个滚动播放，又涉及到定会器的使用，所以需要在这个对象当中去添加一个成员变量 NSTimer，当添加了 NSTimer 之后，在为它分配了一个相应的定时回调事件之后，NSTimer 会对他的 target 进行强引用，这个时候就产生了一个相互循环引用\n\n![](/img/NSTimeer的循环应用问题2.png)\n\n如果把这个对象对 NSTimer 的强引用换为弱引用（如上图）来解除，是大错特错的\n\n![](/img/NSTimeer的循环应用问题3.png)\n\n因为 NSTimer 刚被分派之后，会被当前线程的 RunLoop 强引用，如果说我们这个对象后者说 NSTimer 是在主线程中创建的，那么就由主线程的 RunLoop 持有这个 NSTimer，所以即使这个对象弱引用了 NSTimer，但是由于主线程的 RunLoop 常住内存 通过对 NSTimer 的强引用，再通过 NSTimer 对对象的强引用，仍然对这个对象产生了一个强引用，那么此时，即使 VC 页面退出，对对象的引用去掉的话，这个当前 banner 广告栏由于被 RunLoop 间接的持有，这个对象也不会被释放，此时就产生了内存泄露\n\n关于 NSTimer 是有**重复定时器**和**非重复定时器**之分\n假如我们创建的 NSTimer 是非重复的定时器，一般情况下我们会在定时器的回调方法当中去调用 NSTimer 的 invalidate 方法，同时使 timer 为 nil，通过这种办法，可以把 RunLoop 对 NSTimer 的强引用给解除，同时 NSTimer 也解除了对对象的强引用\n\n**思考：**接入说 NSTimer 是一个重复多次回调的定时器的话，就不能在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作\n\n![](/img/NSTimeer的循环应用问题4.png)\n\n![](/img/NSTimeer的循环应用问题5.png)\n\n在左侧是 RunLoop 对 NSTimer 的强引用，在右侧是 VC 对 对象的强引用，我们可以在 NSTimer 和对象中间添加一个中间对象，然后由 NSTimer 对中间对象执行一个强引用，同时中间对象分别对 NSTimer 和 banner广告栏的对象做一个弱引用，此时对于一个重复的定时器而言，当当前 VC 或者说页面退出之后，VC 就释放了对 banner 广告栏这个对象强引用，当下次 NSTimer 的回调事件回来的时候，我们可以在中间对象当中 NSTimer 的回调方法里面去判断当前中间对象所持有的弱引用对象是否被废弃掉了，实际上就是判断中间对象所持有的 weak 变量是否为 nil，如果为 nil 的话，在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作，这样的话就可以释放 RunLoop 对 NSTimer 的强引用，NSTimer 对中间对象的强引用，NSTimer和中间对象都可以得到内存的释放达到破除循环引用的目的\n\n**代码实现：**\n\n通过对 NSTimer 添加分类文件，添加一个分派定时器的方法\n\n![](/img/NSTimeer的循环应用问题6.png)\n\n定义的中间对象：\n\n在中间对象当中定义了三个成员变量，一个是 用 weak 指向的 target， 另一个是 selector 也就是定时器的回调方法，还持有了一个弱引用实现的成员变量 timer，然后中间对象中还有一个方法 fire，fire方法的实现就是对他所持有的 target 进行判断，如果当前 target 仍然存在的话，那么判断它是否响应这个选择器，如果响应的话就执行对应的回调方法，如果 target 不存在就把 timer 置为无效\n\n![](/img/NSTimeer的循环应用问题7.png)\n\n分类实现：\n\n首先创建中间对象，然后把传递给 NSTimer 分类当中方法的 taeget 和 selector 分别指派给中间对象，然后再调用系统的 NSTimer 方法去创建 timer，同时指定回调事件是中间对象的 fire 方法，会在 fire 方法当中对实际的回调方法进行调用\n\n![](/img/NSTimeer的循环应用问题8.png)\n\n\n### 至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题","source":"_posts/内存管理--循环引用.md","raw":"---\ntitle: 内存管理(六)--循环引用\ndate: 2018-06-03 01:01:18\n\ndescription: 循环引用比较常见，为了让循环引用不在浪费开发，是时候来一篇文章总结了\n\ncategories: 内存管理\ntags: [Objective-C]\n---\n\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## 循环引用介绍\n\n循环引用主要可以分为三种类型\n\n* 自循环引用\n* 相互循环引用\n* 多循环引用\n\n**自循环引用**\n\n ![](/img/自循环引用.png)\n \n 假如有一个对象，对象当中有一个成员变量 obj，这个对象是强持有他的成员变量，如果此时给这个成员变量 obj 赋值原对象的话，就造成自循环引用\n \n 相互循坏引用\n  \n ![](/img/相互循坏引用.png)\n \n 比如说有一个对象 A ，其中有一个 id 类型的 obj，还有一个对象 B 它当中也有一个 id 类型的 obj，如果此时对象 A 中的 obj 指向对象 B，同时对象 B 中的 obj 指向对象 A，此时就造成相互循坏引用\n \n 多循环引用\n \n  ![](/img/多循环引用.png)\n  \n  假如在某一个类当中，有对象 1，对象 2，对象 n，每一个对象当中都一个 id 类型的 obj，假如说此时每一个对象的 obj 都指向下一个对象，就产生了一个多循环引用\n  \n **循环引用考点**\n  \n* 代理（相互循环引用）\n* Block\n* NSTimer\n* 大环引用\n\n## 如何破除循环引用\n\n* 避免产生循环引用（比如使用代理过程中，两个对象一个使用强引用，一个使用弱引用）\n* 在合适的时机手动断环\n\n**破除循环引用具体的解决方案**\n\n* _ _weak （在使用代理、Block的时候会用到）\n* _ _block（一般使用在 Block 方面产生的循环引用问题）\n* _ _ unsafe_unretained（由这个关键字修饰的对象也没有增加引用计数，和 _ _weak 在效果上是等效的）\n\n**_ _weak 破解**\n\n避免产生循环应用的常用方案\n\n![](/img/避免产生循环应用的常用方案.png)\n\n假如说左侧的对象 A 和 右侧的对象 B 都有一个成员变量 id 类型的 obj，当把 对象 A 中的成员变量声明为 _ _weak 的时候，就可以破除相互循环引用\n对象 B 强持有 A ，而 A 弱引用 B，此时规避了循环引用\n\n**_ _block 破解**\n\n![](/img/__block破解.png)\n\n**_ _ unsafe_unretained 破解**\n\n![](/img/__unsafe_unretained破解.png)\n\n如果被修饰对象在某一时机被释放，再通过这个指针去访问原对象的话，会由于悬垂指针的原因导致内存泄露\n\n## 循环应用的示例\n\n* Block 的使用示例\n\n* NSTimeer 的使用示例\n\n### Block 的循环应用问题\n\n想了解 Block 的循环引用问题，请移驾 Block 章节的 [Block--Block 的循环应用]()\n\n### NSTimeer 的循环应用问题\n\n![](/img/NSTimeer的循环应用问题1.png)\n\n假如一个实际的场景：比如有一个页面，在这个页面当中有一个 banner 广告栏，需要在每一秒钟滚动一次，一般情况下会把 banner 广告栏的 UI 对象作为 VC 的一个成员变量，由 VC 对它进行强持有，那么由于 banner 需要每个一秒钟进行一个滚动播放，又涉及到定会器的使用，所以需要在这个对象当中去添加一个成员变量 NSTimer，当添加了 NSTimer 之后，在为它分配了一个相应的定时回调事件之后，NSTimer 会对他的 target 进行强引用，这个时候就产生了一个相互循环引用\n\n![](/img/NSTimeer的循环应用问题2.png)\n\n如果把这个对象对 NSTimer 的强引用换为弱引用（如上图）来解除，是大错特错的\n\n![](/img/NSTimeer的循环应用问题3.png)\n\n因为 NSTimer 刚被分派之后，会被当前线程的 RunLoop 强引用，如果说我们这个对象后者说 NSTimer 是在主线程中创建的，那么就由主线程的 RunLoop 持有这个 NSTimer，所以即使这个对象弱引用了 NSTimer，但是由于主线程的 RunLoop 常住内存 通过对 NSTimer 的强引用，再通过 NSTimer 对对象的强引用，仍然对这个对象产生了一个强引用，那么此时，即使 VC 页面退出，对对象的引用去掉的话，这个当前 banner 广告栏由于被 RunLoop 间接的持有，这个对象也不会被释放，此时就产生了内存泄露\n\n关于 NSTimer 是有**重复定时器**和**非重复定时器**之分\n假如我们创建的 NSTimer 是非重复的定时器，一般情况下我们会在定时器的回调方法当中去调用 NSTimer 的 invalidate 方法，同时使 timer 为 nil，通过这种办法，可以把 RunLoop 对 NSTimer 的强引用给解除，同时 NSTimer 也解除了对对象的强引用\n\n**思考：**接入说 NSTimer 是一个重复多次回调的定时器的话，就不能在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作\n\n![](/img/NSTimeer的循环应用问题4.png)\n\n![](/img/NSTimeer的循环应用问题5.png)\n\n在左侧是 RunLoop 对 NSTimer 的强引用，在右侧是 VC 对 对象的强引用，我们可以在 NSTimer 和对象中间添加一个中间对象，然后由 NSTimer 对中间对象执行一个强引用，同时中间对象分别对 NSTimer 和 banner广告栏的对象做一个弱引用，此时对于一个重复的定时器而言，当当前 VC 或者说页面退出之后，VC 就释放了对 banner 广告栏这个对象强引用，当下次 NSTimer 的回调事件回来的时候，我们可以在中间对象当中 NSTimer 的回调方法里面去判断当前中间对象所持有的弱引用对象是否被废弃掉了，实际上就是判断中间对象所持有的 weak 变量是否为 nil，如果为 nil 的话，在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作，这样的话就可以释放 RunLoop 对 NSTimer 的强引用，NSTimer 对中间对象的强引用，NSTimer和中间对象都可以得到内存的释放达到破除循环引用的目的\n\n**代码实现：**\n\n通过对 NSTimer 添加分类文件，添加一个分派定时器的方法\n\n![](/img/NSTimeer的循环应用问题6.png)\n\n定义的中间对象：\n\n在中间对象当中定义了三个成员变量，一个是 用 weak 指向的 target， 另一个是 selector 也就是定时器的回调方法，还持有了一个弱引用实现的成员变量 timer，然后中间对象中还有一个方法 fire，fire方法的实现就是对他所持有的 target 进行判断，如果当前 target 仍然存在的话，那么判断它是否响应这个选择器，如果响应的话就执行对应的回调方法，如果 target 不存在就把 timer 置为无效\n\n![](/img/NSTimeer的循环应用问题7.png)\n\n分类实现：\n\n首先创建中间对象，然后把传递给 NSTimer 分类当中方法的 taeget 和 selector 分别指派给中间对象，然后再调用系统的 NSTimer 方法去创建 timer，同时指定回调事件是中间对象的 fire 方法，会在 fire 方法当中对实际的回调方法进行调用\n\n![](/img/NSTimeer的循环应用问题8.png)\n\n\n### 至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题","slug":"内存管理--循环引用","published":1,"updated":"2018-09-11T09:51:20.000Z","_id":"cjlxj6gci002y66r2gtueroch","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"循环引用介绍\"><a href=\"#循环引用介绍\" class=\"headerlink\" title=\"循环引用介绍\"></a>循环引用介绍</h2><p>循环引用主要可以分为三种类型</p>\n<ul>\n<li>自循环引用</li>\n<li>相互循环引用</li>\n<li>多循环引用</li>\n</ul>\n<p><strong>自循环引用</strong></p>\n<p> <img src=\"/img/自循环引用.png\" alt=\"\"></p>\n<p> 假如有一个对象，对象当中有一个成员变量 obj，这个对象是强持有他的成员变量，如果此时给这个成员变量 obj 赋值原对象的话，就造成自循环引用</p>\n<p> 相互循坏引用</p>\n<p> <img src=\"/img/相互循坏引用.png\" alt=\"\"></p>\n<p> 比如说有一个对象 A ，其中有一个 id 类型的 obj，还有一个对象 B 它当中也有一个 id 类型的 obj，如果此时对象 A 中的 obj 指向对象 B，同时对象 B 中的 obj 指向对象 A，此时就造成相互循坏引用</p>\n<p> 多循环引用</p>\n<p>  <img src=\"/img/多循环引用.png\" alt=\"\"></p>\n<p>  假如在某一个类当中，有对象 1，对象 2，对象 n，每一个对象当中都一个 id 类型的 obj，假如说此时每一个对象的 obj 都指向下一个对象，就产生了一个多循环引用</p>\n<p> <strong>循环引用考点</strong></p>\n<ul>\n<li>代理（相互循环引用）</li>\n<li>Block</li>\n<li>NSTimer</li>\n<li>大环引用</li>\n</ul>\n<h2 id=\"如何破除循环引用\"><a href=\"#如何破除循环引用\" class=\"headerlink\" title=\"如何破除循环引用\"></a>如何破除循环引用</h2><ul>\n<li>避免产生循环引用（比如使用代理过程中，两个对象一个使用强引用，一个使用弱引用）</li>\n<li>在合适的时机手动断环</li>\n</ul>\n<p><strong>破除循环引用具体的解决方案</strong></p>\n<ul>\n<li>_ _weak （在使用代理、Block的时候会用到）</li>\n<li>_ _block（一般使用在 Block 方面产生的循环引用问题）</li>\n<li><em> </em> unsafe<em>unretained（由这个关键字修饰的对象也没有增加引用计数，和 </em> _weak 在效果上是等效的）</li>\n</ul>\n<p><strong>_ _weak 破解</strong></p>\n<p>避免产生循环应用的常用方案</p>\n<p><img src=\"/img/避免产生循环应用的常用方案.png\" alt=\"\"></p>\n<p>假如说左侧的对象 A 和 右侧的对象 B 都有一个成员变量 id 类型的 obj，当把 对象 A 中的成员变量声明为 _ _weak 的时候，就可以破除相互循环引用<br>对象 B 强持有 A ，而 A 弱引用 B，此时规避了循环引用</p>\n<p><strong>_ _block 破解</strong></p>\n<p><img src=\"/img/__block破解.png\" alt=\"\"></p>\n<p><strong><em> </em> unsafe_unretained 破解</strong></p>\n<p><img src=\"/img/__unsafe_unretained破解.png\" alt=\"\"></p>\n<p>如果被修饰对象在某一时机被释放，再通过这个指针去访问原对象的话，会由于悬垂指针的原因导致内存泄露</p>\n<h2 id=\"循环应用的示例\"><a href=\"#循环应用的示例\" class=\"headerlink\" title=\"循环应用的示例\"></a>循环应用的示例</h2><ul>\n<li><p>Block 的使用示例</p>\n</li>\n<li><p>NSTimeer 的使用示例</p>\n</li>\n</ul>\n<h3 id=\"Block-的循环应用问题\"><a href=\"#Block-的循环应用问题\" class=\"headerlink\" title=\"Block 的循环应用问题\"></a>Block 的循环应用问题</h3><p>想了解 Block 的循环引用问题，请移驾 Block 章节的 <a href=\"\">Block–Block 的循环应用</a></p>\n<h3 id=\"NSTimeer-的循环应用问题\"><a href=\"#NSTimeer-的循环应用问题\" class=\"headerlink\" title=\"NSTimeer 的循环应用问题\"></a>NSTimeer 的循环应用问题</h3><p><img src=\"/img/NSTimeer的循环应用问题1.png\" alt=\"\"></p>\n<p>假如一个实际的场景：比如有一个页面，在这个页面当中有一个 banner 广告栏，需要在每一秒钟滚动一次，一般情况下会把 banner 广告栏的 UI 对象作为 VC 的一个成员变量，由 VC 对它进行强持有，那么由于 banner 需要每个一秒钟进行一个滚动播放，又涉及到定会器的使用，所以需要在这个对象当中去添加一个成员变量 NSTimer，当添加了 NSTimer 之后，在为它分配了一个相应的定时回调事件之后，NSTimer 会对他的 target 进行强引用，这个时候就产生了一个相互循环引用</p>\n<p><img src=\"/img/NSTimeer的循环应用问题2.png\" alt=\"\"></p>\n<p>如果把这个对象对 NSTimer 的强引用换为弱引用（如上图）来解除，是大错特错的</p>\n<p><img src=\"/img/NSTimeer的循环应用问题3.png\" alt=\"\"></p>\n<p>因为 NSTimer 刚被分派之后，会被当前线程的 RunLoop 强引用，如果说我们这个对象后者说 NSTimer 是在主线程中创建的，那么就由主线程的 RunLoop 持有这个 NSTimer，所以即使这个对象弱引用了 NSTimer，但是由于主线程的 RunLoop 常住内存 通过对 NSTimer 的强引用，再通过 NSTimer 对对象的强引用，仍然对这个对象产生了一个强引用，那么此时，即使 VC 页面退出，对对象的引用去掉的话，这个当前 banner 广告栏由于被 RunLoop 间接的持有，这个对象也不会被释放，此时就产生了内存泄露</p>\n<p>关于 NSTimer 是有<strong>重复定时器</strong>和<strong>非重复定时器</strong>之分<br>假如我们创建的 NSTimer 是非重复的定时器，一般情况下我们会在定时器的回调方法当中去调用 NSTimer 的 invalidate 方法，同时使 timer 为 nil，通过这种办法，可以把 RunLoop 对 NSTimer 的强引用给解除，同时 NSTimer 也解除了对对象的强引用</p>\n<p><strong>思考：</strong>接入说 NSTimer 是一个重复多次回调的定时器的话，就不能在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作</p>\n<p><img src=\"/img/NSTimeer的循环应用问题4.png\" alt=\"\"></p>\n<p><img src=\"/img/NSTimeer的循环应用问题5.png\" alt=\"\"></p>\n<p>在左侧是 RunLoop 对 NSTimer 的强引用，在右侧是 VC 对 对象的强引用，我们可以在 NSTimer 和对象中间添加一个中间对象，然后由 NSTimer 对中间对象执行一个强引用，同时中间对象分别对 NSTimer 和 banner广告栏的对象做一个弱引用，此时对于一个重复的定时器而言，当当前 VC 或者说页面退出之后，VC 就释放了对 banner 广告栏这个对象强引用，当下次 NSTimer 的回调事件回来的时候，我们可以在中间对象当中 NSTimer 的回调方法里面去判断当前中间对象所持有的弱引用对象是否被废弃掉了，实际上就是判断中间对象所持有的 weak 变量是否为 nil，如果为 nil 的话，在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作，这样的话就可以释放 RunLoop 对 NSTimer 的强引用，NSTimer 对中间对象的强引用，NSTimer和中间对象都可以得到内存的释放达到破除循环引用的目的</p>\n<p><strong>代码实现：</strong></p>\n<p>通过对 NSTimer 添加分类文件，添加一个分派定时器的方法</p>\n<p><img src=\"/img/NSTimeer的循环应用问题6.png\" alt=\"\"></p>\n<p>定义的中间对象：</p>\n<p>在中间对象当中定义了三个成员变量，一个是 用 weak 指向的 target， 另一个是 selector 也就是定时器的回调方法，还持有了一个弱引用实现的成员变量 timer，然后中间对象中还有一个方法 fire，fire方法的实现就是对他所持有的 target 进行判断，如果当前 target 仍然存在的话，那么判断它是否响应这个选择器，如果响应的话就执行对应的回调方法，如果 target 不存在就把 timer 置为无效</p>\n<p><img src=\"/img/NSTimeer的循环应用问题7.png\" alt=\"\"></p>\n<p>分类实现：</p>\n<p>首先创建中间对象，然后把传递给 NSTimer 分类当中方法的 taeget 和 selector 分别指派给中间对象，然后再调用系统的 NSTimer 方法去创建 timer，同时指定回调事件是中间对象的 fire 方法，会在 fire 方法当中对实际的回调方法进行调用</p>\n<p><img src=\"/img/NSTimeer的循环应用问题8.png\" alt=\"\"></p>\n<h3 id=\"至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题\"><a href=\"#至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题\" class=\"headerlink\" title=\"至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题\"></a>至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题</h3>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"循环引用介绍\"><a href=\"#循环引用介绍\" class=\"headerlink\" title=\"循环引用介绍\"></a>循环引用介绍</h2><p>循环引用主要可以分为三种类型</p>\n<ul>\n<li>自循环引用</li>\n<li>相互循环引用</li>\n<li>多循环引用</li>\n</ul>\n<p><strong>自循环引用</strong></p>\n<p> <img src=\"/img/自循环引用.png\" alt=\"\"></p>\n<p> 假如有一个对象，对象当中有一个成员变量 obj，这个对象是强持有他的成员变量，如果此时给这个成员变量 obj 赋值原对象的话，就造成自循环引用</p>\n<p> 相互循坏引用</p>\n<p> <img src=\"/img/相互循坏引用.png\" alt=\"\"></p>\n<p> 比如说有一个对象 A ，其中有一个 id 类型的 obj，还有一个对象 B 它当中也有一个 id 类型的 obj，如果此时对象 A 中的 obj 指向对象 B，同时对象 B 中的 obj 指向对象 A，此时就造成相互循坏引用</p>\n<p> 多循环引用</p>\n<p>  <img src=\"/img/多循环引用.png\" alt=\"\"></p>\n<p>  假如在某一个类当中，有对象 1，对象 2，对象 n，每一个对象当中都一个 id 类型的 obj，假如说此时每一个对象的 obj 都指向下一个对象，就产生了一个多循环引用</p>\n<p> <strong>循环引用考点</strong></p>\n<ul>\n<li>代理（相互循环引用）</li>\n<li>Block</li>\n<li>NSTimer</li>\n<li>大环引用</li>\n</ul>\n<h2 id=\"如何破除循环引用\"><a href=\"#如何破除循环引用\" class=\"headerlink\" title=\"如何破除循环引用\"></a>如何破除循环引用</h2><ul>\n<li>避免产生循环引用（比如使用代理过程中，两个对象一个使用强引用，一个使用弱引用）</li>\n<li>在合适的时机手动断环</li>\n</ul>\n<p><strong>破除循环引用具体的解决方案</strong></p>\n<ul>\n<li>_ _weak （在使用代理、Block的时候会用到）</li>\n<li>_ _block（一般使用在 Block 方面产生的循环引用问题）</li>\n<li><em> </em> unsafe<em>unretained（由这个关键字修饰的对象也没有增加引用计数，和 </em> _weak 在效果上是等效的）</li>\n</ul>\n<p><strong>_ _weak 破解</strong></p>\n<p>避免产生循环应用的常用方案</p>\n<p><img src=\"/img/避免产生循环应用的常用方案.png\" alt=\"\"></p>\n<p>假如说左侧的对象 A 和 右侧的对象 B 都有一个成员变量 id 类型的 obj，当把 对象 A 中的成员变量声明为 _ _weak 的时候，就可以破除相互循环引用<br>对象 B 强持有 A ，而 A 弱引用 B，此时规避了循环引用</p>\n<p><strong>_ _block 破解</strong></p>\n<p><img src=\"/img/__block破解.png\" alt=\"\"></p>\n<p><strong><em> </em> unsafe_unretained 破解</strong></p>\n<p><img src=\"/img/__unsafe_unretained破解.png\" alt=\"\"></p>\n<p>如果被修饰对象在某一时机被释放，再通过这个指针去访问原对象的话，会由于悬垂指针的原因导致内存泄露</p>\n<h2 id=\"循环应用的示例\"><a href=\"#循环应用的示例\" class=\"headerlink\" title=\"循环应用的示例\"></a>循环应用的示例</h2><ul>\n<li><p>Block 的使用示例</p>\n</li>\n<li><p>NSTimeer 的使用示例</p>\n</li>\n</ul>\n<h3 id=\"Block-的循环应用问题\"><a href=\"#Block-的循环应用问题\" class=\"headerlink\" title=\"Block 的循环应用问题\"></a>Block 的循环应用问题</h3><p>想了解 Block 的循环引用问题，请移驾 Block 章节的 <a href=\"\">Block–Block 的循环应用</a></p>\n<h3 id=\"NSTimeer-的循环应用问题\"><a href=\"#NSTimeer-的循环应用问题\" class=\"headerlink\" title=\"NSTimeer 的循环应用问题\"></a>NSTimeer 的循环应用问题</h3><p><img src=\"/img/NSTimeer的循环应用问题1.png\" alt=\"\"></p>\n<p>假如一个实际的场景：比如有一个页面，在这个页面当中有一个 banner 广告栏，需要在每一秒钟滚动一次，一般情况下会把 banner 广告栏的 UI 对象作为 VC 的一个成员变量，由 VC 对它进行强持有，那么由于 banner 需要每个一秒钟进行一个滚动播放，又涉及到定会器的使用，所以需要在这个对象当中去添加一个成员变量 NSTimer，当添加了 NSTimer 之后，在为它分配了一个相应的定时回调事件之后，NSTimer 会对他的 target 进行强引用，这个时候就产生了一个相互循环引用</p>\n<p><img src=\"/img/NSTimeer的循环应用问题2.png\" alt=\"\"></p>\n<p>如果把这个对象对 NSTimer 的强引用换为弱引用（如上图）来解除，是大错特错的</p>\n<p><img src=\"/img/NSTimeer的循环应用问题3.png\" alt=\"\"></p>\n<p>因为 NSTimer 刚被分派之后，会被当前线程的 RunLoop 强引用，如果说我们这个对象后者说 NSTimer 是在主线程中创建的，那么就由主线程的 RunLoop 持有这个 NSTimer，所以即使这个对象弱引用了 NSTimer，但是由于主线程的 RunLoop 常住内存 通过对 NSTimer 的强引用，再通过 NSTimer 对对象的强引用，仍然对这个对象产生了一个强引用，那么此时，即使 VC 页面退出，对对象的引用去掉的话，这个当前 banner 广告栏由于被 RunLoop 间接的持有，这个对象也不会被释放，此时就产生了内存泄露</p>\n<p>关于 NSTimer 是有<strong>重复定时器</strong>和<strong>非重复定时器</strong>之分<br>假如我们创建的 NSTimer 是非重复的定时器，一般情况下我们会在定时器的回调方法当中去调用 NSTimer 的 invalidate 方法，同时使 timer 为 nil，通过这种办法，可以把 RunLoop 对 NSTimer 的强引用给解除，同时 NSTimer 也解除了对对象的强引用</p>\n<p><strong>思考：</strong>接入说 NSTimer 是一个重复多次回调的定时器的话，就不能在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作</p>\n<p><img src=\"/img/NSTimeer的循环应用问题4.png\" alt=\"\"></p>\n<p><img src=\"/img/NSTimeer的循环应用问题5.png\" alt=\"\"></p>\n<p>在左侧是 RunLoop 对 NSTimer 的强引用，在右侧是 VC 对 对象的强引用，我们可以在 NSTimer 和对象中间添加一个中间对象，然后由 NSTimer 对中间对象执行一个强引用，同时中间对象分别对 NSTimer 和 banner广告栏的对象做一个弱引用，此时对于一个重复的定时器而言，当当前 VC 或者说页面退出之后，VC 就释放了对 banner 广告栏这个对象强引用，当下次 NSTimer 的回调事件回来的时候，我们可以在中间对象当中 NSTimer 的回调方法里面去判断当前中间对象所持有的弱引用对象是否被废弃掉了，实际上就是判断中间对象所持有的 weak 变量是否为 nil，如果为 nil 的话，在定时器的回调方法当中调用 invalidate 和做 timer 置 nil 的操作，这样的话就可以释放 RunLoop 对 NSTimer 的强引用，NSTimer 对中间对象的强引用，NSTimer和中间对象都可以得到内存的释放达到破除循环引用的目的</p>\n<p><strong>代码实现：</strong></p>\n<p>通过对 NSTimer 添加分类文件，添加一个分派定时器的方法</p>\n<p><img src=\"/img/NSTimeer的循环应用问题6.png\" alt=\"\"></p>\n<p>定义的中间对象：</p>\n<p>在中间对象当中定义了三个成员变量，一个是 用 weak 指向的 target， 另一个是 selector 也就是定时器的回调方法，还持有了一个弱引用实现的成员变量 timer，然后中间对象中还有一个方法 fire，fire方法的实现就是对他所持有的 target 进行判断，如果当前 target 仍然存在的话，那么判断它是否响应这个选择器，如果响应的话就执行对应的回调方法，如果 target 不存在就把 timer 置为无效</p>\n<p><img src=\"/img/NSTimeer的循环应用问题7.png\" alt=\"\"></p>\n<p>分类实现：</p>\n<p>首先创建中间对象，然后把传递给 NSTimer 分类当中方法的 taeget 和 selector 分别指派给中间对象，然后再调用系统的 NSTimer 方法去创建 timer，同时指定回调事件是中间对象的 fire 方法，会在 fire 方法当中对实际的回调方法进行调用</p>\n<p><img src=\"/img/NSTimeer的循环应用问题8.png\" alt=\"\"></p>\n<h3 id=\"至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题\"><a href=\"#至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题\" class=\"headerlink\" title=\"至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题\"></a>至此，这些知识足够轻松的解决项目中一些常见的由于循环引用引起的内存问题</h3>"},{"title":"内存管理(二)--有关散列表实现的内存管理方法的数据结构","date":"2018-06-17T17:01:18.000Z","description":"有关散列表实现的内存管理方法的数据结构","_content":"\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n\n### 数据结构\n\n* **Spinlock_t** （自旋锁）\n* RefacountMap （弱用计数表）\n* weak_table _t  (弱引用表)\n\n\n### 自旋锁（Spinlock_t）\n\n* 自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。\n* Spinlock_t 是 “忙等” 的锁\n* 适用于轻量访问\n\n\n自身很大的一个特点：循环等待访问，不释放当前资源\n\n自旋锁本身是一种忙等的锁，忙等指的是：如果当前锁已被其他线程获取，那么当前线程会不断的探测这个锁是否有被释放，如果释放自己第一时间去获取这个锁\n\n是一个循环等待的访问，类似一个 while 循环一直在访问能不能获得当前的锁，如果不能他就继续循环，直到有一次能获得这个锁，它才会停止循环\n\n再比如说其他的锁，比如正常的信号量，如果当他获取不到这个锁的时候，他会把自己这个线程进行阻塞休眠，然后等到其他线程释放这个锁的时候来唤醒当前线程\n\n应用场景\n用于轻量级数据访问，简单的 int 值 +1/-1 操作（在引用计数方面应用）\n\n自旋锁适应于轻量访问，比如说以前讲到的 Side Table 表，如果说我们对某一个对象进行引用计数操作的话，来访问这个表，那么实际上做加一减一的操作是非常快的操作，可以把它定义为轻量访问，在这种轻量访问的场景下可以使用自旋锁\n\n思考：你是否有使用过自旋锁？自旋锁和普通的锁有什么区别？自旋锁适应于哪些场景？\n \n### 引用计数表（RefacountMap）\n\n![](/img/RefacountMap.png)\n\n引用计数表是哈希表，正如名字 Map，可以理解为是一个字典，也就是说通过一个指针可以找到对应对象的引用计数，这个查找过程也是哈希查找，这个哈希查找的哈希算法实际上是对传入对象的指针进行伪装的操作，然后获取对应的引用计数\n\n在这里再次明确一下哈希查找的过程，实际上之所以使用哈希查找就是为了提高查找效率，而查找效率的提高源于我们存储一个对象的引用计数是通过这个函数来计算存储位置的，而获取这个对象所代表的引用计数值的时候，也是通过这个函数来计算应该获取的索引位置，所以插入和获取都是通过同一函数来计算位置的，也就避免了一些循环遍历的操作，所以哈希查找可以提高查找效率\n\n思考：引用计数表是用什么来实现的？为什么用哈希表？\n答：是用哈希表来实现的，答案在上面\n\nsize_t 代表的就是对应对象的引用计数值，实际上就是一个无符号 long 型的变量\n\n**size_t 具体的每一个 bit 位代表的含义：**\n\n比如说引用计数存储使用一个64位来表示的，那么在 size_t 中\n\n* 第一个二进制位 weakly_referenced 表示的是这个对象是否有弱引用，0没有，1有\n* 第二位表示当前对象是否正在进行 dealloc 操作\n* 后面的存储的就是这个对象实际的引用计数值\n那么在计算对象的具体引用计数值，需要对这个值（2-63）向右偏移两位，因为后面这两位要去掉才可以取到真实的引用计数值\n\n### 弱引用表（weak_table _t）\n\n![](/img/weak_table_t.png)\n\n在 Runtime 源码当中，弱引用表系统是通过 weak_table _t 来定义的，weak _ table _ t 实际上也是一张哈希表，同样的给以一个对象的指针作为 Key ，通过一个哈希函数就可以计算出对应的弱引用的对象它的存储位置，weak _ entry_t 是一个结构体数组，这个结构体数组当中存储的每一个对象是弱引用指针，也就是在代码中定义的，比如说 _ _ weak id obj，那么 obj 这个内存地址或者说指针就存储到 weak_entry_t 这个结构体数组当中\n这就是弱引用表的数据结构的描述","source":"_posts/内存管理--有关散列表实现的内存管理方法的数据结构.md","raw":"---\ntitle: 内存管理(二)--有关散列表实现的内存管理方法的数据结构\ndate: 2018-06-18 01:01:18\n\ndescription: 有关散列表实现的内存管理方法的数据结构\n\ncategories: 内存管理\ntags: [Objective-C]\n---\n\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n\n### 数据结构\n\n* **Spinlock_t** （自旋锁）\n* RefacountMap （弱用计数表）\n* weak_table _t  (弱引用表)\n\n\n### 自旋锁（Spinlock_t）\n\n* 自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。\n* Spinlock_t 是 “忙等” 的锁\n* 适用于轻量访问\n\n\n自身很大的一个特点：循环等待访问，不释放当前资源\n\n自旋锁本身是一种忙等的锁，忙等指的是：如果当前锁已被其他线程获取，那么当前线程会不断的探测这个锁是否有被释放，如果释放自己第一时间去获取这个锁\n\n是一个循环等待的访问，类似一个 while 循环一直在访问能不能获得当前的锁，如果不能他就继续循环，直到有一次能获得这个锁，它才会停止循环\n\n再比如说其他的锁，比如正常的信号量，如果当他获取不到这个锁的时候，他会把自己这个线程进行阻塞休眠，然后等到其他线程释放这个锁的时候来唤醒当前线程\n\n应用场景\n用于轻量级数据访问，简单的 int 值 +1/-1 操作（在引用计数方面应用）\n\n自旋锁适应于轻量访问，比如说以前讲到的 Side Table 表，如果说我们对某一个对象进行引用计数操作的话，来访问这个表，那么实际上做加一减一的操作是非常快的操作，可以把它定义为轻量访问，在这种轻量访问的场景下可以使用自旋锁\n\n思考：你是否有使用过自旋锁？自旋锁和普通的锁有什么区别？自旋锁适应于哪些场景？\n \n### 引用计数表（RefacountMap）\n\n![](/img/RefacountMap.png)\n\n引用计数表是哈希表，正如名字 Map，可以理解为是一个字典，也就是说通过一个指针可以找到对应对象的引用计数，这个查找过程也是哈希查找，这个哈希查找的哈希算法实际上是对传入对象的指针进行伪装的操作，然后获取对应的引用计数\n\n在这里再次明确一下哈希查找的过程，实际上之所以使用哈希查找就是为了提高查找效率，而查找效率的提高源于我们存储一个对象的引用计数是通过这个函数来计算存储位置的，而获取这个对象所代表的引用计数值的时候，也是通过这个函数来计算应该获取的索引位置，所以插入和获取都是通过同一函数来计算位置的，也就避免了一些循环遍历的操作，所以哈希查找可以提高查找效率\n\n思考：引用计数表是用什么来实现的？为什么用哈希表？\n答：是用哈希表来实现的，答案在上面\n\nsize_t 代表的就是对应对象的引用计数值，实际上就是一个无符号 long 型的变量\n\n**size_t 具体的每一个 bit 位代表的含义：**\n\n比如说引用计数存储使用一个64位来表示的，那么在 size_t 中\n\n* 第一个二进制位 weakly_referenced 表示的是这个对象是否有弱引用，0没有，1有\n* 第二位表示当前对象是否正在进行 dealloc 操作\n* 后面的存储的就是这个对象实际的引用计数值\n那么在计算对象的具体引用计数值，需要对这个值（2-63）向右偏移两位，因为后面这两位要去掉才可以取到真实的引用计数值\n\n### 弱引用表（weak_table _t）\n\n![](/img/weak_table_t.png)\n\n在 Runtime 源码当中，弱引用表系统是通过 weak_table _t 来定义的，weak _ table _ t 实际上也是一张哈希表，同样的给以一个对象的指针作为 Key ，通过一个哈希函数就可以计算出对应的弱引用的对象它的存储位置，weak _ entry_t 是一个结构体数组，这个结构体数组当中存储的每一个对象是弱引用指针，也就是在代码中定义的，比如说 _ _ weak id obj，那么 obj 这个内存地址或者说指针就存储到 weak_entry_t 这个结构体数组当中\n这就是弱引用表的数据结构的描述","slug":"内存管理--有关散列表实现的内存管理方法的数据结构","published":1,"updated":"2018-09-12T10:28:48.000Z","_id":"cjlxj6gcj003166r2rg0lbmmv","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ul>\n<li><strong>Spinlock_t</strong> （自旋锁）</li>\n<li>RefacountMap （弱用计数表）</li>\n<li>weak_table _t  (弱引用表)</li>\n</ul>\n<h3 id=\"自旋锁（Spinlock-t）\"><a href=\"#自旋锁（Spinlock-t）\" class=\"headerlink\" title=\"自旋锁（Spinlock_t）\"></a>自旋锁（Spinlock_t）</h3><ul>\n<li>自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</li>\n<li>Spinlock_t 是 “忙等” 的锁</li>\n<li>适用于轻量访问</li>\n</ul>\n<p>自身很大的一个特点：循环等待访问，不释放当前资源</p>\n<p>自旋锁本身是一种忙等的锁，忙等指的是：如果当前锁已被其他线程获取，那么当前线程会不断的探测这个锁是否有被释放，如果释放自己第一时间去获取这个锁</p>\n<p>是一个循环等待的访问，类似一个 while 循环一直在访问能不能获得当前的锁，如果不能他就继续循环，直到有一次能获得这个锁，它才会停止循环</p>\n<p>再比如说其他的锁，比如正常的信号量，如果当他获取不到这个锁的时候，他会把自己这个线程进行阻塞休眠，然后等到其他线程释放这个锁的时候来唤醒当前线程</p>\n<p>应用场景<br>用于轻量级数据访问，简单的 int 值 +1/-1 操作（在引用计数方面应用）</p>\n<p>自旋锁适应于轻量访问，比如说以前讲到的 Side Table 表，如果说我们对某一个对象进行引用计数操作的话，来访问这个表，那么实际上做加一减一的操作是非常快的操作，可以把它定义为轻量访问，在这种轻量访问的场景下可以使用自旋锁</p>\n<p>思考：你是否有使用过自旋锁？自旋锁和普通的锁有什么区别？自旋锁适应于哪些场景？</p>\n<h3 id=\"引用计数表（RefacountMap）\"><a href=\"#引用计数表（RefacountMap）\" class=\"headerlink\" title=\"引用计数表（RefacountMap）\"></a>引用计数表（RefacountMap）</h3><p><img src=\"/img/RefacountMap.png\" alt=\"\"></p>\n<p>引用计数表是哈希表，正如名字 Map，可以理解为是一个字典，也就是说通过一个指针可以找到对应对象的引用计数，这个查找过程也是哈希查找，这个哈希查找的哈希算法实际上是对传入对象的指针进行伪装的操作，然后获取对应的引用计数</p>\n<p>在这里再次明确一下哈希查找的过程，实际上之所以使用哈希查找就是为了提高查找效率，而查找效率的提高源于我们存储一个对象的引用计数是通过这个函数来计算存储位置的，而获取这个对象所代表的引用计数值的时候，也是通过这个函数来计算应该获取的索引位置，所以插入和获取都是通过同一函数来计算位置的，也就避免了一些循环遍历的操作，所以哈希查找可以提高查找效率</p>\n<p>思考：引用计数表是用什么来实现的？为什么用哈希表？<br>答：是用哈希表来实现的，答案在上面</p>\n<p>size_t 代表的就是对应对象的引用计数值，实际上就是一个无符号 long 型的变量</p>\n<p><strong>size_t 具体的每一个 bit 位代表的含义：</strong></p>\n<p>比如说引用计数存储使用一个64位来表示的，那么在 size_t 中</p>\n<ul>\n<li>第一个二进制位 weakly_referenced 表示的是这个对象是否有弱引用，0没有，1有</li>\n<li>第二位表示当前对象是否正在进行 dealloc 操作</li>\n<li>后面的存储的就是这个对象实际的引用计数值<br>那么在计算对象的具体引用计数值，需要对这个值（2-63）向右偏移两位，因为后面这两位要去掉才可以取到真实的引用计数值</li>\n</ul>\n<h3 id=\"弱引用表（weak-table-t）\"><a href=\"#弱引用表（weak-table-t）\" class=\"headerlink\" title=\"弱引用表（weak_table _t）\"></a>弱引用表（weak_table _t）</h3><p><img src=\"/img/weak_table_t.png\" alt=\"\"></p>\n<p>在 Runtime 源码当中，弱引用表系统是通过 weak_table <em>t 来定义的，weak </em> table <em> t 实际上也是一张哈希表，同样的给以一个对象的指针作为 Key ，通过一个哈希函数就可以计算出对应的弱引用的对象它的存储位置，weak </em> entry<em>t 是一个结构体数组，这个结构体数组当中存储的每一个对象是弱引用指针，也就是在代码中定义的，比如说 </em> _ weak id obj，那么 obj 这个内存地址或者说指针就存储到 weak_entry_t 这个结构体数组当中<br>这就是弱引用表的数据结构的描述</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ul>\n<li><strong>Spinlock_t</strong> （自旋锁）</li>\n<li>RefacountMap （弱用计数表）</li>\n<li>weak_table _t  (弱引用表)</li>\n</ul>\n<h3 id=\"自旋锁（Spinlock-t）\"><a href=\"#自旋锁（Spinlock-t）\" class=\"headerlink\" title=\"自旋锁（Spinlock_t）\"></a>自旋锁（Spinlock_t）</h3><ul>\n<li>自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。</li>\n<li>Spinlock_t 是 “忙等” 的锁</li>\n<li>适用于轻量访问</li>\n</ul>\n<p>自身很大的一个特点：循环等待访问，不释放当前资源</p>\n<p>自旋锁本身是一种忙等的锁，忙等指的是：如果当前锁已被其他线程获取，那么当前线程会不断的探测这个锁是否有被释放，如果释放自己第一时间去获取这个锁</p>\n<p>是一个循环等待的访问，类似一个 while 循环一直在访问能不能获得当前的锁，如果不能他就继续循环，直到有一次能获得这个锁，它才会停止循环</p>\n<p>再比如说其他的锁，比如正常的信号量，如果当他获取不到这个锁的时候，他会把自己这个线程进行阻塞休眠，然后等到其他线程释放这个锁的时候来唤醒当前线程</p>\n<p>应用场景<br>用于轻量级数据访问，简单的 int 值 +1/-1 操作（在引用计数方面应用）</p>\n<p>自旋锁适应于轻量访问，比如说以前讲到的 Side Table 表，如果说我们对某一个对象进行引用计数操作的话，来访问这个表，那么实际上做加一减一的操作是非常快的操作，可以把它定义为轻量访问，在这种轻量访问的场景下可以使用自旋锁</p>\n<p>思考：你是否有使用过自旋锁？自旋锁和普通的锁有什么区别？自旋锁适应于哪些场景？</p>\n<h3 id=\"引用计数表（RefacountMap）\"><a href=\"#引用计数表（RefacountMap）\" class=\"headerlink\" title=\"引用计数表（RefacountMap）\"></a>引用计数表（RefacountMap）</h3><p><img src=\"/img/RefacountMap.png\" alt=\"\"></p>\n<p>引用计数表是哈希表，正如名字 Map，可以理解为是一个字典，也就是说通过一个指针可以找到对应对象的引用计数，这个查找过程也是哈希查找，这个哈希查找的哈希算法实际上是对传入对象的指针进行伪装的操作，然后获取对应的引用计数</p>\n<p>在这里再次明确一下哈希查找的过程，实际上之所以使用哈希查找就是为了提高查找效率，而查找效率的提高源于我们存储一个对象的引用计数是通过这个函数来计算存储位置的，而获取这个对象所代表的引用计数值的时候，也是通过这个函数来计算应该获取的索引位置，所以插入和获取都是通过同一函数来计算位置的，也就避免了一些循环遍历的操作，所以哈希查找可以提高查找效率</p>\n<p>思考：引用计数表是用什么来实现的？为什么用哈希表？<br>答：是用哈希表来实现的，答案在上面</p>\n<p>size_t 代表的就是对应对象的引用计数值，实际上就是一个无符号 long 型的变量</p>\n<p><strong>size_t 具体的每一个 bit 位代表的含义：</strong></p>\n<p>比如说引用计数存储使用一个64位来表示的，那么在 size_t 中</p>\n<ul>\n<li>第一个二进制位 weakly_referenced 表示的是这个对象是否有弱引用，0没有，1有</li>\n<li>第二位表示当前对象是否正在进行 dealloc 操作</li>\n<li>后面的存储的就是这个对象实际的引用计数值<br>那么在计算对象的具体引用计数值，需要对这个值（2-63）向右偏移两位，因为后面这两位要去掉才可以取到真实的引用计数值</li>\n</ul>\n<h3 id=\"弱引用表（weak-table-t）\"><a href=\"#弱引用表（weak-table-t）\" class=\"headerlink\" title=\"弱引用表（weak_table _t）\"></a>弱引用表（weak_table _t）</h3><p><img src=\"/img/weak_table_t.png\" alt=\"\"></p>\n<p>在 Runtime 源码当中，弱引用表系统是通过 weak_table <em>t 来定义的，weak </em> table <em> t 实际上也是一张哈希表，同样的给以一个对象的指针作为 Key ，通过一个哈希函数就可以计算出对应的弱引用的对象它的存储位置，weak </em> entry<em>t 是一个结构体数组，这个结构体数组当中存储的每一个对象是弱引用指针，也就是在代码中定义的，比如说 </em> _ weak id obj，那么 obj 这个内存地址或者说指针就存储到 weak_entry_t 这个结构体数组当中<br>这就是弱引用表的数据结构的描述</p>\n"},{"title":"内存管理(四)--弱引用管理","date":"2018-06-27T17:01:18.000Z","description":"一个 weak 变量是怎么样被添加到弱引用表当中的？当一个对象被释放后者废弃之后 weak 变量是怎么处理的？","_content":"\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n \n### **思考：一个 weak 变量是怎么样被添加到弱引用表当中的？**\n\n来看一个代码块先：\n\n ![](/img/来看一个代码块.png)\n \n* 在这个代码块当中是使用了一个 杠杠weak 关键字修饰的 obj1 这个变量来指向一个通过 alloc 分配的一个对象 obj，此时就产生了一个 杠杠weak 弱引用指针\n* 这个代码块经过编译之后会变成后者的代码块，这里面实际是调用了 objc_initWeak 函数，传递的两个参数，第一个参数是 obj1 这个弱引用变量的地址，第二个是传递了被修饰的对象\n\n在这个过程中都发生了什么？来看一下 objc_initWeak 的调用栈：\n\n![](/img/添加weak变量.png)\n\n首先 objc_initWeak 这个函数会调用一个叫 storeWeak 的函数，然后会调用 weak-register-no-lock 函数，通过名称可以得知，这个 weak 指针被添加到弱引用表的具体实现就在这个函数当中（register注册）\n\n代码的讲解：\n通过原对象的指针地址进行哈希算法的计算获取到这个对象在弱引用表当中一个对应索引位置，然后通过所查找的这个索引位置返回给调用放相应的这个对象的所对应的弱引用的数组\n获取到的 entry 可以理解为是一个数组，实际上是一个比数组复杂一点的结构，如果获取到了这个结构，就把新产生的弱引用指针添加到数组当中，如果没有获取到被修饰对象的弱引用数组的话，就需要重新创建一个弱引用数组，初始化全是 nil，创建的这个数组的个数大小是为4的限制，之后会把弱引用的数组插入弱引用表的对应位置当中  \n\n**添加 weak 变量总结：**\n\n* 一个被声明为 - -weak 的对象指针经过编译器的编译后，会调用相应的 objc_initWeak 方法，然后经过一系列的函数调用栈，最终在weak-register-no-lock 函数当中进行弱引用变量的添加，具体添加的位置是通过一个哈希算法来进行位置查找的\n* 如果说我们查找对应位置当中已经有了当前对象所对应的一个弱引用数组，就把新的弱引用变量添加到数组当中\n* 如果没有的话，会重新创建一个弱引用数组，然后把第 0 个位置添加上最新的 weak 指针后面的都初始化为 0 或者为 nil\n\n\n### **思考：当一个对象被释放后者废弃之后 weak 变量是怎么处理的？**\n\n![](/img/weak变量是怎么处理的.png)\n\n具体过程：\n\n在调 dealloc 方法之后，进过一系列的调用，在他内部当中最终会调用 weak_chear_no_lock 方法\n\n源码分析系统是如何实现把一个废弃的对象的弱引用指针自动置为 nil 的\n\n总结：当一个对象被 dealloc 之后，在 dealloc 的内部实现当中会去调用它弱引用清楚的相关函数，然后在这个函数的内部实现当中会根据当前对象的指针查找弱引用表，把当前对象相对应的弱引用都拿出来，是一个数组，然后遍历这个数组当中所有的弱引用指针，分别置为 nil ，\n","source":"_posts/内存管理--弱引用管理.md","raw":"---\ntitle: 内存管理(四)--弱引用管理\ndate: 2018-06-28 01:01:18\n\ndescription: 一个 weak 变量是怎么样被添加到弱引用表当中的？当一个对象被释放后者废弃之后 weak 变量是怎么处理的？\n\ncategories: 内存管理\ntags: [Objective-C]\n---\n\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n \n### **思考：一个 weak 变量是怎么样被添加到弱引用表当中的？**\n\n来看一个代码块先：\n\n ![](/img/来看一个代码块.png)\n \n* 在这个代码块当中是使用了一个 杠杠weak 关键字修饰的 obj1 这个变量来指向一个通过 alloc 分配的一个对象 obj，此时就产生了一个 杠杠weak 弱引用指针\n* 这个代码块经过编译之后会变成后者的代码块，这里面实际是调用了 objc_initWeak 函数，传递的两个参数，第一个参数是 obj1 这个弱引用变量的地址，第二个是传递了被修饰的对象\n\n在这个过程中都发生了什么？来看一下 objc_initWeak 的调用栈：\n\n![](/img/添加weak变量.png)\n\n首先 objc_initWeak 这个函数会调用一个叫 storeWeak 的函数，然后会调用 weak-register-no-lock 函数，通过名称可以得知，这个 weak 指针被添加到弱引用表的具体实现就在这个函数当中（register注册）\n\n代码的讲解：\n通过原对象的指针地址进行哈希算法的计算获取到这个对象在弱引用表当中一个对应索引位置，然后通过所查找的这个索引位置返回给调用放相应的这个对象的所对应的弱引用的数组\n获取到的 entry 可以理解为是一个数组，实际上是一个比数组复杂一点的结构，如果获取到了这个结构，就把新产生的弱引用指针添加到数组当中，如果没有获取到被修饰对象的弱引用数组的话，就需要重新创建一个弱引用数组，初始化全是 nil，创建的这个数组的个数大小是为4的限制，之后会把弱引用的数组插入弱引用表的对应位置当中  \n\n**添加 weak 变量总结：**\n\n* 一个被声明为 - -weak 的对象指针经过编译器的编译后，会调用相应的 objc_initWeak 方法，然后经过一系列的函数调用栈，最终在weak-register-no-lock 函数当中进行弱引用变量的添加，具体添加的位置是通过一个哈希算法来进行位置查找的\n* 如果说我们查找对应位置当中已经有了当前对象所对应的一个弱引用数组，就把新的弱引用变量添加到数组当中\n* 如果没有的话，会重新创建一个弱引用数组，然后把第 0 个位置添加上最新的 weak 指针后面的都初始化为 0 或者为 nil\n\n\n### **思考：当一个对象被释放后者废弃之后 weak 变量是怎么处理的？**\n\n![](/img/weak变量是怎么处理的.png)\n\n具体过程：\n\n在调 dealloc 方法之后，进过一系列的调用，在他内部当中最终会调用 weak_chear_no_lock 方法\n\n源码分析系统是如何实现把一个废弃的对象的弱引用指针自动置为 nil 的\n\n总结：当一个对象被 dealloc 之后，在 dealloc 的内部实现当中会去调用它弱引用清楚的相关函数，然后在这个函数的内部实现当中会根据当前对象的指针查找弱引用表，把当前对象相对应的弱引用都拿出来，是一个数组，然后遍历这个数组当中所有的弱引用指针，分别置为 nil ，\n","slug":"内存管理--弱引用管理","published":1,"updated":"2018-09-14T09:02:16.000Z","_id":"cjlxj6gcl003566r23qbz0o9h","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h3 id=\"思考：一个-weak-变量是怎么样被添加到弱引用表当中的？\"><a href=\"#思考：一个-weak-变量是怎么样被添加到弱引用表当中的？\" class=\"headerlink\" title=\"思考：一个 weak 变量是怎么样被添加到弱引用表当中的？\"></a><strong>思考：一个 weak 变量是怎么样被添加到弱引用表当中的？</strong></h3><p>来看一个代码块先：</p>\n<p> <img src=\"/img/来看一个代码块.png\" alt=\"\"></p>\n<ul>\n<li>在这个代码块当中是使用了一个 杠杠weak 关键字修饰的 obj1 这个变量来指向一个通过 alloc 分配的一个对象 obj，此时就产生了一个 杠杠weak 弱引用指针</li>\n<li>这个代码块经过编译之后会变成后者的代码块，这里面实际是调用了 objc_initWeak 函数，传递的两个参数，第一个参数是 obj1 这个弱引用变量的地址，第二个是传递了被修饰的对象</li>\n</ul>\n<p>在这个过程中都发生了什么？来看一下 objc_initWeak 的调用栈：</p>\n<p><img src=\"/img/添加weak变量.png\" alt=\"\"></p>\n<p>首先 objc_initWeak 这个函数会调用一个叫 storeWeak 的函数，然后会调用 weak-register-no-lock 函数，通过名称可以得知，这个 weak 指针被添加到弱引用表的具体实现就在这个函数当中（register注册）</p>\n<p>代码的讲解：<br>通过原对象的指针地址进行哈希算法的计算获取到这个对象在弱引用表当中一个对应索引位置，然后通过所查找的这个索引位置返回给调用放相应的这个对象的所对应的弱引用的数组<br>获取到的 entry 可以理解为是一个数组，实际上是一个比数组复杂一点的结构，如果获取到了这个结构，就把新产生的弱引用指针添加到数组当中，如果没有获取到被修饰对象的弱引用数组的话，就需要重新创建一个弱引用数组，初始化全是 nil，创建的这个数组的个数大小是为4的限制，之后会把弱引用的数组插入弱引用表的对应位置当中  </p>\n<p><strong>添加 weak 变量总结：</strong></p>\n<ul>\n<li>一个被声明为 - -weak 的对象指针经过编译器的编译后，会调用相应的 objc_initWeak 方法，然后经过一系列的函数调用栈，最终在weak-register-no-lock 函数当中进行弱引用变量的添加，具体添加的位置是通过一个哈希算法来进行位置查找的</li>\n<li>如果说我们查找对应位置当中已经有了当前对象所对应的一个弱引用数组，就把新的弱引用变量添加到数组当中</li>\n<li>如果没有的话，会重新创建一个弱引用数组，然后把第 0 个位置添加上最新的 weak 指针后面的都初始化为 0 或者为 nil</li>\n</ul>\n<h3 id=\"思考：当一个对象被释放后者废弃之后-weak-变量是怎么处理的？\"><a href=\"#思考：当一个对象被释放后者废弃之后-weak-变量是怎么处理的？\" class=\"headerlink\" title=\"思考：当一个对象被释放后者废弃之后 weak 变量是怎么处理的？\"></a><strong>思考：当一个对象被释放后者废弃之后 weak 变量是怎么处理的？</strong></h3><p><img src=\"/img/weak变量是怎么处理的.png\" alt=\"\"></p>\n<p>具体过程：</p>\n<p>在调 dealloc 方法之后，进过一系列的调用，在他内部当中最终会调用 weak_chear_no_lock 方法</p>\n<p>源码分析系统是如何实现把一个废弃的对象的弱引用指针自动置为 nil 的</p>\n<p>总结：当一个对象被 dealloc 之后，在 dealloc 的内部实现当中会去调用它弱引用清楚的相关函数，然后在这个函数的内部实现当中会根据当前对象的指针查找弱引用表，把当前对象相对应的弱引用都拿出来，是一个数组，然后遍历这个数组当中所有的弱引用指针，分别置为 nil ，</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h3 id=\"思考：一个-weak-变量是怎么样被添加到弱引用表当中的？\"><a href=\"#思考：一个-weak-变量是怎么样被添加到弱引用表当中的？\" class=\"headerlink\" title=\"思考：一个 weak 变量是怎么样被添加到弱引用表当中的？\"></a><strong>思考：一个 weak 变量是怎么样被添加到弱引用表当中的？</strong></h3><p>来看一个代码块先：</p>\n<p> <img src=\"/img/来看一个代码块.png\" alt=\"\"></p>\n<ul>\n<li>在这个代码块当中是使用了一个 杠杠weak 关键字修饰的 obj1 这个变量来指向一个通过 alloc 分配的一个对象 obj，此时就产生了一个 杠杠weak 弱引用指针</li>\n<li>这个代码块经过编译之后会变成后者的代码块，这里面实际是调用了 objc_initWeak 函数，传递的两个参数，第一个参数是 obj1 这个弱引用变量的地址，第二个是传递了被修饰的对象</li>\n</ul>\n<p>在这个过程中都发生了什么？来看一下 objc_initWeak 的调用栈：</p>\n<p><img src=\"/img/添加weak变量.png\" alt=\"\"></p>\n<p>首先 objc_initWeak 这个函数会调用一个叫 storeWeak 的函数，然后会调用 weak-register-no-lock 函数，通过名称可以得知，这个 weak 指针被添加到弱引用表的具体实现就在这个函数当中（register注册）</p>\n<p>代码的讲解：<br>通过原对象的指针地址进行哈希算法的计算获取到这个对象在弱引用表当中一个对应索引位置，然后通过所查找的这个索引位置返回给调用放相应的这个对象的所对应的弱引用的数组<br>获取到的 entry 可以理解为是一个数组，实际上是一个比数组复杂一点的结构，如果获取到了这个结构，就把新产生的弱引用指针添加到数组当中，如果没有获取到被修饰对象的弱引用数组的话，就需要重新创建一个弱引用数组，初始化全是 nil，创建的这个数组的个数大小是为4的限制，之后会把弱引用的数组插入弱引用表的对应位置当中  </p>\n<p><strong>添加 weak 变量总结：</strong></p>\n<ul>\n<li>一个被声明为 - -weak 的对象指针经过编译器的编译后，会调用相应的 objc_initWeak 方法，然后经过一系列的函数调用栈，最终在weak-register-no-lock 函数当中进行弱引用变量的添加，具体添加的位置是通过一个哈希算法来进行位置查找的</li>\n<li>如果说我们查找对应位置当中已经有了当前对象所对应的一个弱引用数组，就把新的弱引用变量添加到数组当中</li>\n<li>如果没有的话，会重新创建一个弱引用数组，然后把第 0 个位置添加上最新的 weak 指针后面的都初始化为 0 或者为 nil</li>\n</ul>\n<h3 id=\"思考：当一个对象被释放后者废弃之后-weak-变量是怎么处理的？\"><a href=\"#思考：当一个对象被释放后者废弃之后-weak-变量是怎么处理的？\" class=\"headerlink\" title=\"思考：当一个对象被释放后者废弃之后 weak 变量是怎么处理的？\"></a><strong>思考：当一个对象被释放后者废弃之后 weak 变量是怎么处理的？</strong></h3><p><img src=\"/img/weak变量是怎么处理的.png\" alt=\"\"></p>\n<p>具体过程：</p>\n<p>在调 dealloc 方法之后，进过一系列的调用，在他内部当中最终会调用 weak_chear_no_lock 方法</p>\n<p>源码分析系统是如何实现把一个废弃的对象的弱引用指针自动置为 nil 的</p>\n<p>总结：当一个对象被 dealloc 之后，在 dealloc 的内部实现当中会去调用它弱引用清楚的相关函数，然后在这个函数的内部实现当中会根据当前对象的指针查找弱引用表，把当前对象相对应的弱引用都拿出来，是一个数组，然后遍历这个数组当中所有的弱引用指针，分别置为 nil ，</p>\n"},{"title":"如何清空view上的所有子视图","date":"2016-12-03T09:22:09.000Z","description":"本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法","_content":"本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法\n## removeFromSuperview方法\n\n首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：\n\n* Unlinks the receiver from its superview and its window,\nand removes it from the responder chain.\n\n\n* 译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 \n\n\n调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for...in...的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果\n\n```\nfor (UIView *view in [self.view subviews]) {\n\n        [view removeFromSuperview];\n    }\n```\n\n\n\n 注意：\n 1. 永远不要在你的view的drawRect方法中调用removeFromSuperview；\n 2. removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。\n\n## makeObjectsPerformSelector\n\n```\n- (void)makeObjectsPerformSelector:(SEL)aSelector;  \n- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument; \n```\n介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector\n\n一行搞定删除子视图\n\n```\n[self.view.sublayers makeObjectsPerformSelector:@selector(removeFromSuperview)];\n```\n\n带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@YES];  \n```\n这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。\n\n但是若想设置为NO的话，则无效（亲测）。\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@NO];  \n```\n这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看[这里](https://www.cnblogs.com/Apologize/p/5383652.html)。\n\n但是可以用nil达到参数为NO的效果\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:nil];  \n```\n## enumerator ##\n\n```\n- (void)enumerateObjectsUsingBlock:block;\n```\n这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），*stop可以控制遍历何时停止，在需要停止时令*stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。\n\n```\nNSArray *xpArray = @[@\"A\", @\"B\", @\"C\", @\"D\", @\"E\"];\n    \n    [xpArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        \n        NSLog(@\"%@\", obj);\n        \n        if ([obj isEqualToString:@\"C\"]) {\n            \n            *stop = YES;\n        }\n    }];\n```\n不过反向遍历呢？苹果提供了另外一个方法：\n\n```\n[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id obj, NSUInteger idx, BOOLBOOL *stop) {  \n    NSLog(@\"idx=%d, id=%@\", idx, obj);  \n}]; \n```\n这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。\n\n注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。\n","source":"_posts/如何清空view上的所有子视图.md","raw":"---\ntitle: 如何清空view上的所有子视图\ndate: 2016-12-03 17:22:09\ndescription: 本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法\ncategories: 问题记录\ntags: [Objective-C]\n---\n本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法\n## removeFromSuperview方法\n\n首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：\n\n* Unlinks the receiver from its superview and its window,\nand removes it from the responder chain.\n\n\n* 译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 \n\n\n调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for...in...的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果\n\n```\nfor (UIView *view in [self.view subviews]) {\n\n        [view removeFromSuperview];\n    }\n```\n\n\n\n 注意：\n 1. 永远不要在你的view的drawRect方法中调用removeFromSuperview；\n 2. removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。\n\n## makeObjectsPerformSelector\n\n```\n- (void)makeObjectsPerformSelector:(SEL)aSelector;  \n- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument; \n```\n介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector\n\n一行搞定删除子视图\n\n```\n[self.view.sublayers makeObjectsPerformSelector:@selector(removeFromSuperview)];\n```\n\n带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@YES];  \n```\n这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。\n\n但是若想设置为NO的话，则无效（亲测）。\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@NO];  \n```\n这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看[这里](https://www.cnblogs.com/Apologize/p/5383652.html)。\n\n但是可以用nil达到参数为NO的效果\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:nil];  \n```\n## enumerator ##\n\n```\n- (void)enumerateObjectsUsingBlock:block;\n```\n这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），*stop可以控制遍历何时停止，在需要停止时令*stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。\n\n```\nNSArray *xpArray = @[@\"A\", @\"B\", @\"C\", @\"D\", @\"E\"];\n    \n    [xpArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        \n        NSLog(@\"%@\", obj);\n        \n        if ([obj isEqualToString:@\"C\"]) {\n            \n            *stop = YES;\n        }\n    }];\n```\n不过反向遍历呢？苹果提供了另外一个方法：\n\n```\n[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id obj, NSUInteger idx, BOOLBOOL *stop) {  \n    NSLog(@\"idx=%d, id=%@\", idx, obj);  \n}]; \n```\n这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。\n\n注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。\n","slug":"如何清空view上的所有子视图","published":1,"updated":"2018-08-31T03:05:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlxj6gcn003866r2ybzkyoga","content":"<p>本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法</p>\n<h2 id=\"removeFromSuperview方法\"><a href=\"#removeFromSuperview方法\" class=\"headerlink\" title=\"removeFromSuperview方法\"></a>removeFromSuperview方法</h2><p>首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：</p>\n<ul>\n<li>Unlinks the receiver from its superview and its window,<br>and removes it from the responder chain.</li>\n</ul>\n<ul>\n<li>译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 </li>\n</ul>\n<p>调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for…in…的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (UIView *<span class=\"built_in\">view</span> <span class=\"keyword\">in</span> [self.<span class=\"built_in\">view</span> subviews]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"built_in\">view</span> removeFromSuperview];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p> 注意：</p>\n<ol>\n<li>永远不要在你的view的drawRect方法中调用removeFromSuperview；</li>\n<li>removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。</li>\n</ol>\n<h2 id=\"makeObjectsPerformSelector\"><a href=\"#makeObjectsPerformSelector\" class=\"headerlink\" title=\"makeObjectsPerformSelector\"></a>makeObjectsPerformSelector</h2><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector;  </span><br><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector withObject:<span class=\"params\">(id)</span>argument;</span><br></pre></td></tr></table></figure>\n<p>介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector</p>\n<p>一行搞定删除子视图</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">self.view.sublayers</span> makeObjectsPerformSelector:@selector(<span class=\"name\">removeFromSuperview</span>)]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。</p>\n<p>但是若想设置为NO的话，则无效（亲测）。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@NO</span>];</span><br></pre></td></tr></table></figure>\n<p>这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看<a href=\"https://www.cnblogs.com/Apologize/p/5383652.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>但是可以用nil达到参数为NO的效果</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"enumerator\"><a href=\"#enumerator\" class=\"headerlink\" title=\"enumerator\"></a>enumerator</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">enumerateObjectsUsingBlock:</span>block;</span><br></pre></td></tr></table></figure>\n<p>这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），<em>stop可以控制遍历何时停止，在需要停止时令</em>stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *xpArray = @[<span class=\"string\">@\"A\"</span>, <span class=\"string\">@\"B\"</span>, <span class=\"string\">@\"C\"</span>, <span class=\"string\">@\"D\"</span>, <span class=\"string\">@\"E\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [xpArray enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, obj);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"C\"</span>]) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>不过反向遍历呢？苹果提供了另外一个方法：</p>\n<figure class=\"highlight hy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(<span class=\"name\"><span class=\"builtin-name\">id</span></span> obj, NSUInteger idx, BOOLBOOL *stop) &#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"idx=%d, id=%@\"</span>, idx, obj)<span class=\"comment\">;  </span></span><br><span class=\"line\">&#125;]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。</p>\n<p>注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法</p>\n<h2 id=\"removeFromSuperview方法\"><a href=\"#removeFromSuperview方法\" class=\"headerlink\" title=\"removeFromSuperview方法\"></a>removeFromSuperview方法</h2><p>首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：</p>\n<ul>\n<li>Unlinks the receiver from its superview and its window,<br>and removes it from the responder chain.</li>\n</ul>\n<ul>\n<li>译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 </li>\n</ul>\n<p>调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for…in…的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (UIView *<span class=\"built_in\">view</span> <span class=\"keyword\">in</span> [self.<span class=\"built_in\">view</span> subviews]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"built_in\">view</span> removeFromSuperview];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p> 注意：</p>\n<ol>\n<li>永远不要在你的view的drawRect方法中调用removeFromSuperview；</li>\n<li>removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。</li>\n</ol>\n<h2 id=\"makeObjectsPerformSelector\"><a href=\"#makeObjectsPerformSelector\" class=\"headerlink\" title=\"makeObjectsPerformSelector\"></a>makeObjectsPerformSelector</h2><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector;  </span><br><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector withObject:<span class=\"params\">(id)</span>argument;</span><br></pre></td></tr></table></figure>\n<p>介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector</p>\n<p>一行搞定删除子视图</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">self.view.sublayers</span> makeObjectsPerformSelector:@selector(<span class=\"name\">removeFromSuperview</span>)]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。</p>\n<p>但是若想设置为NO的话，则无效（亲测）。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@NO</span>];</span><br></pre></td></tr></table></figure>\n<p>这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看<a href=\"https://www.cnblogs.com/Apologize/p/5383652.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>但是可以用nil达到参数为NO的效果</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"enumerator\"><a href=\"#enumerator\" class=\"headerlink\" title=\"enumerator\"></a>enumerator</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">enumerateObjectsUsingBlock:</span>block;</span><br></pre></td></tr></table></figure>\n<p>这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），<em>stop可以控制遍历何时停止，在需要停止时令</em>stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *xpArray = @[<span class=\"string\">@\"A\"</span>, <span class=\"string\">@\"B\"</span>, <span class=\"string\">@\"C\"</span>, <span class=\"string\">@\"D\"</span>, <span class=\"string\">@\"E\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [xpArray enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, obj);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"C\"</span>]) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>不过反向遍历呢？苹果提供了另外一个方法：</p>\n<figure class=\"highlight hy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(<span class=\"name\"><span class=\"builtin-name\">id</span></span> obj, NSUInteger idx, BOOLBOOL *stop) &#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"idx=%d, id=%@\"</span>, idx, obj)<span class=\"comment\">;  </span></span><br><span class=\"line\">&#125;]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。</p>\n<p>注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。</p>\n"},{"title":"内存管理(五)--自动释放池","date":"2018-07-07T17:01:18.000Z","description":"自动释放池","_content":"\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## 内存布局\n\n ![](/img/内存布局.png)\n \n ```\n - (void)viewDidLoad\n {\n    [super viewDidLoad];\n    \n    NSMutableArray *array = [NSMutableArray array];\n    NSLog(@\"%@\",array);\n }\n ```","source":"_posts/内存管理--自动释放池.md","raw":"---\ntitle: 内存管理(五)--自动释放池\ndate: 2018-07-08 01:01:18\n\ndescription: 自动释放池\n\ncategories: 内存管理\ntags: [Objective-C]\n---\n\n***\n[内存管理(一) -- 内存管理方案](https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/)\n[内存管理(二) -- 有关散列表实现的内存管理方法的数据结构](https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)\n[内存管理(三) -- 引用计数管理](https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/)\n[内存管理(四) -- 弱引用管理](https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/)\n[内存管理(五) -- 自动释放池](https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/)\n[内存管理(六) -- 循环引用](https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n[Block(四) -- Block 的循环引用](https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/)\n***\n\n## 内存布局\n\n ![](/img/内存布局.png)\n \n ```\n - (void)viewDidLoad\n {\n    [super viewDidLoad];\n    \n    NSMutableArray *array = [NSMutableArray array];\n    NSLog(@\"%@\",array);\n }\n ```","slug":"内存管理--自动释放池","published":1,"updated":"2018-09-14T09:17:09.000Z","_id":"cjlxj6gco003b66r2i7wfr66a","comments":1,"layout":"post","photos":[],"link":"","content":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><p> <img src=\"/img/内存布局.png\" alt=\"\"></p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<hr>\n<p><a href=\"https://xiaopengmonsters.github.io/2018/06/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"noopener\">内存管理(一) – 内存管理方案</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/18/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E6%9C%89%E5%85%B3%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\" target=\"_blank\" rel=\"noopener\">内存管理(二) – 有关散列表实现的内存管理方法的数据结构</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(三) – 引用计数管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/28/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BC%B1%E5%BC%95%E7%94%A8%E7%AE%A1%E7%90%86/\" target=\"_blank\" rel=\"noopener\">内存管理(四) – 弱引用管理</a><br><a href=\"https://xiaopengmonsters.github.io/2018/07/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0/\" target=\"_blank\" rel=\"noopener\">内存管理(五) – 自动释放池</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/03/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">内存管理(六) – 循环引用</a><br><a href=\"https://xiaopengmonsters.github.io/2018/06/05/Block--Block%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/\" target=\"_blank\" rel=\"noopener\">Block(四) – Block 的循环引用</a></p>\n<hr>\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><p> <img src=\"/img/内存布局.png\" alt=\"\"></p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">   <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,array);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjlxj6fn5000a66r2c229t2ox","category_id":"cjlxj6fn3000766r2mn2g53bn","_id":"cjlxj6fnb000j66r2by27msv3"},{"post_id":"cjlxj6fmw000166r2vtiy70qs","category_id":"cjlxj6fn3000766r2mn2g53bn","_id":"cjlxj6fng000n66r29rhmq3ch"},{"post_id":"cjlxj6fn7000c66r28gcw1qm2","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6fni000q66r2ky4356j6"},{"post_id":"cjlxj6fn9000g66r2dc71i68e","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6fnl000u66r28bfxlgwu"},{"post_id":"cjlxj6fn0000466r22aj3urwj","category_id":"cjlxj6fn3000766r2mn2g53bn","_id":"cjlxj6fnm000y66r2t6e28m04"},{"post_id":"cjlxj6fn1000566r25nfmq9dj","category_id":"cjlxj6fn3000766r2mn2g53bn","_id":"cjlxj6fnn001266r2iz4714ue"},{"post_id":"cjlxj6fmt000066r29xuk6rvq","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6fno001566r276w1h8lb"},{"post_id":"cjlxj6fmt000066r29xuk6rvq","category_id":"cjlxj6fnj000r66r2bmzr7t17","_id":"cjlxj6fnp001966r2cw7bzji3"},{"post_id":"cjlxj6fn2000666r2978utfjv","category_id":"cjlxj6fnm000z66r2hm0d2xnb","_id":"cjlxj6fnr001d66r20pk050oq"},{"post_id":"cjlxj6fnn001466r2moz207gh","category_id":"cjlxj6fnm000z66r2hm0d2xnb","_id":"cjlxj6fns001i66r21jvxbu5x"},{"post_id":"cjlxj6fnq001b66r284q2getl","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6fns001k66r2gwock426"},{"post_id":"cjlxj6fna000i66r2zl8bwgoo","category_id":"cjlxj6fno001766r2ry9ylfcu","_id":"cjlxj6fnt001n66r2ht0opa3t"},{"post_id":"cjlxj6fnf000m66r200lk77vf","category_id":"cjlxj6fnr001f66r2thif695s","_id":"cjlxj6fnt001p66r2y6mx8lag"},{"post_id":"cjlxj6fnh000p66r28zaji05o","category_id":"cjlxj6fnt001l66r20jkyuckv","_id":"cjlxj6fnu001u66r2qn79odqh"},{"post_id":"cjlxj6fnk000t66r2zqm53fxg","category_id":"cjlxj6fnt001l66r20jkyuckv","_id":"cjlxj6fnv001y66r2bohwl634"},{"post_id":"cjlxj6fnl000x66r2ubmetk61","category_id":"cjlxj6fnt001l66r20jkyuckv","_id":"cjlxj6fnv002166r2l9n4rbtc"},{"post_id":"cjlxj6fnm001166r2oxwehg9u","category_id":"cjlxj6fnt001l66r20jkyuckv","_id":"cjlxj6fnw002366r2wakgo2fg"},{"post_id":"cjlxj6fno001866r204rec30r","category_id":"cjlxj6fnt001l66r20jkyuckv","_id":"cjlxj6fnw002466r2p6zhhh88"},{"post_id":"cjlxj6fnr001e66r2erxm1o7j","category_id":"cjlxj6fnw002266r25kd7wmlh","_id":"cjlxj6fnw002566r2bv30pq6f"},{"post_id":"cjlxj6gc1002666r20pt8y1k2","category_id":"cjlxj6fnw002266r25kd7wmlh","_id":"cjlxj6gc8002d66r2vgity6hl"},{"post_id":"cjlxj6gc4002866r2u1aefjae","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6gca002g66r2llp7ie74"},{"post_id":"cjlxj6gc5002a66r2sruty54q","category_id":"cjlxj6fno001766r2ry9ylfcu","_id":"cjlxj6gcb002j66r2yd54xnjp"},{"post_id":"cjlxj6gc7002c66r2bkrim5vr","category_id":"cjlxj6fnw002266r25kd7wmlh","_id":"cjlxj6gcc002m66r2o837pd5s"},{"post_id":"cjlxj6gc9002f66r2nqvk0pgs","category_id":"cjlxj6fnm000z66r2hm0d2xnb","_id":"cjlxj6gcd002p66r2dwmty6mb"},{"post_id":"cjlxj6gca002i66r20c001g3c","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6gcg002s66r2ty6c8vq4"},{"post_id":"cjlxj6gca002i66r20c001g3c","category_id":"cjlxj6fnj000r66r2bmzr7t17","_id":"cjlxj6gci002w66r2n5ogeh0v"},{"post_id":"cjlxj6gcb002l66r2biew3lif","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6gcj002z66r2ladh7rlf"},{"post_id":"cjlxj6gcb002l66r2biew3lif","category_id":"cjlxj6fnj000r66r2bmzr7t17","_id":"cjlxj6gcl003366r27sa0f1qz"},{"post_id":"cjlxj6gcg002v66r2pi5ao9jn","category_id":"cjlxj6fmy000266r266ohbsm2","_id":"cjlxj6gcm003666r2ovg10sot"},{"post_id":"cjlxj6gcg002v66r2pi5ao9jn","category_id":"cjlxj6fnj000r66r2bmzr7t17","_id":"cjlxj6gco003966r2zb0sb8s4"},{"post_id":"cjlxj6gci002y66r2gtueroch","category_id":"cjlxj6gcg002t66r2yho4h9dq","_id":"cjlxj6gcp003c66r2hzzj10w4"},{"post_id":"cjlxj6gcd002o66r2ob8qpe7a","category_id":"cjlxj6gcg002t66r2yho4h9dq","_id":"cjlxj6gcp003e66r2g9mc2zgw"},{"post_id":"cjlxj6gcj003166r2rg0lbmmv","category_id":"cjlxj6gcg002t66r2yho4h9dq","_id":"cjlxj6gcq003g66r2cmnnqsyo"},{"post_id":"cjlxj6gcl003566r23qbz0o9h","category_id":"cjlxj6gcg002t66r2yho4h9dq","_id":"cjlxj6gcq003h66r2n40jt6jp"},{"post_id":"cjlxj6gce002r66r2uffmckxo","category_id":"cjlxj6gcg002t66r2yho4h9dq","_id":"cjlxj6gcq003i66r2mhvn7qf7"},{"post_id":"cjlxj6gcn003866r2ybzkyoga","category_id":"cjlxj6fno001766r2ry9ylfcu","_id":"cjlxj6gcr003j66r2245pvjlm"},{"post_id":"cjlxj6gco003b66r2i7wfr66a","category_id":"cjlxj6gcg002t66r2yho4h9dq","_id":"cjlxj6gcs003k66r291l1vvrz"}],"PostTag":[{"post_id":"cjlxj6fn1000566r25nfmq9dj","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fn5000966r2n54rubcc"},{"post_id":"cjlxj6fmt000066r29xuk6rvq","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fn6000b66r2f08fv0uh"},{"post_id":"cjlxj6fn2000666r2978utfjv","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fn8000f66r2azlsd5k7"},{"post_id":"cjlxj6fn5000a66r2c229t2ox","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fna000h66r2owjiz5ks"},{"post_id":"cjlxj6fmw000166r2vtiy70qs","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnb000l66r2eysgk6t7"},{"post_id":"cjlxj6fn7000c66r28gcw1qm2","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnh000o66r2ezp9xv13"},{"post_id":"cjlxj6fn9000g66r2dc71i68e","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnk000s66r2dtq4pn0a"},{"post_id":"cjlxj6fn0000466r22aj3urwj","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnl000w66r28rv2qh97"},{"post_id":"cjlxj6fna000i66r2zl8bwgoo","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnm001066r2czt4osma"},{"post_id":"cjlxj6fnf000m66r200lk77vf","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnn001366r21f0r2xru"},{"post_id":"cjlxj6fnk000t66r2zqm53fxg","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fno001666r2lt1s6dgc"},{"post_id":"cjlxj6fnl000x66r2ubmetk61","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnp001a66r2fr6nywx0"},{"post_id":"cjlxj6fnm001166r2oxwehg9u","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnr001c66r20g2ofd14"},{"post_id":"cjlxj6fnm001166r2oxwehg9u","tag_id":"cjlxj6fnl000v66r2fwm6p3tw","_id":"cjlxj6fns001h66r2veieo1io"},{"post_id":"cjlxj6fnh000p66r28zaji05o","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fns001j66r2vprf4ckx"},{"post_id":"cjlxj6fnh000p66r28zaji05o","tag_id":"cjlxj6fnl000v66r2fwm6p3tw","_id":"cjlxj6fnt001m66r2patobmio"},{"post_id":"cjlxj6fnn001466r2moz207gh","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnt001o66r2d0x54qej"},{"post_id":"cjlxj6fno001866r204rec30r","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnt001r66r27oh6kb5c"},{"post_id":"cjlxj6fno001866r204rec30r","tag_id":"cjlxj6fnl000v66r2fwm6p3tw","_id":"cjlxj6fnu001s66r2h7hzxb2o"},{"post_id":"cjlxj6fnr001e66r2erxm1o7j","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnu001v66r26mt7ws58"},{"post_id":"cjlxj6fnq001b66r284q2getl","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6fnu001w66r2ug4c9jxe"},{"post_id":"cjlxj6fnq001b66r284q2getl","tag_id":"cjlxj6fns001g66r2l1eqaog7","_id":"cjlxj6fnv001z66r2tffkn3qu"},{"post_id":"cjlxj6gc1002666r20pt8y1k2","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gc5002966r2hpwdr9ce"},{"post_id":"cjlxj6gc4002866r2u1aefjae","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gc7002b66r27jycf57w"},{"post_id":"cjlxj6gc5002a66r2sruty54q","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gc9002e66r2p845gfiq"},{"post_id":"cjlxj6gc7002c66r2bkrim5vr","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gca002h66r24m84vp3i"},{"post_id":"cjlxj6gc9002f66r2nqvk0pgs","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcb002k66r2utom9ebp"},{"post_id":"cjlxj6gca002i66r20c001g3c","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcc002n66r2xmgjoge0"},{"post_id":"cjlxj6gcb002l66r2biew3lif","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gce002q66r2ht1d5xjf"},{"post_id":"cjlxj6gcd002o66r2ob8qpe7a","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcg002u66r27os2lvgu"},{"post_id":"cjlxj6gce002r66r2uffmckxo","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gci002x66r2yowny3yb"},{"post_id":"cjlxj6gcg002v66r2pi5ao9jn","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcj003066r2rnfzotev"},{"post_id":"cjlxj6gci002y66r2gtueroch","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcl003466r2zxic6mbi"},{"post_id":"cjlxj6gcj003166r2rg0lbmmv","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcn003766r24cn76zme"},{"post_id":"cjlxj6gcl003566r23qbz0o9h","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gco003a66r2vyrj43p0"},{"post_id":"cjlxj6gcn003866r2ybzkyoga","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcp003d66r2dn8bq7k0"},{"post_id":"cjlxj6gco003b66r2i7wfr66a","tag_id":"cjlxj6fmz000366r2m1zkrg6l","_id":"cjlxj6gcq003f66r2gsepwi2f"}],"Tag":[{"name":"Objective-C","_id":"cjlxj6fmz000366r2m1zkrg6l"},{"name":"Runtime","_id":"cjlxj6fnl000v66r2fwm6p3tw"},{"name":"Swift","_id":"cjlxj6fns001g66r2l1eqaog7"}]}}