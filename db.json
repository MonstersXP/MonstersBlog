{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/五角星.png","path":"img/五角星.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/正方形.png","path":"img/正方形.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f89e1a1e7268f4e1768aa0184cae6392233e85ec","modified":1524054349000},{"_id":"source/_posts/AFNetworking框架分析.md","hash":"b733d3271d9f4d39d8a96229083ed93228a643ce","modified":1524053999000},{"_id":"source/_posts/APP的优化.md","hash":"ba34585772d2b6bb19f2c4e5c46215a1aef2bfc0","modified":1524053999000},{"_id":"source/_posts/CAlayer.md","hash":"7245dd8a3d3bcacd2dc9b2393c34c63796e05260","modified":1524053999000},{"_id":"source/_posts/LLDB.md","hash":"9dac11ce21a85affa94f67da1622e4f139913451","modified":1524053999000},{"_id":"source/_posts/NStimer准确吗.md","hash":"e3a4366d7fa9face6983c810ba8b0f78dc4673cb","modified":1524053999000},{"_id":"source/_posts/RunLoop.md","hash":"6c932d8aef0dbfeadae89d1965400d82fecd6406","modified":1524053999000},{"_id":"source/_posts/Runtime.md","hash":"3e6e8c68c3dfa04583e12608031f3dfbaac951d5","modified":1524053999000},{"_id":"source/_posts/Runtime之动态添加属性.md","hash":"795763ae711d67de224b6d5a1999a307c7c642a4","modified":1524053999000},{"_id":"source/_posts/Runtime之动态添加方法.md","hash":"e9c776c39fdb5436ab25dabca024d1ecf69e3194","modified":1524053999000},{"_id":"source/_posts/UITableView的优化.md","hash":"4a7547c191136c551a941696fbae2edca8aa5522","modified":1524053999000},{"_id":"source/_posts/hello-world.md","hash":"485a00b40bdb71b56acace162599121493365e34","modified":1524053999000},{"_id":"source/_posts/iOS中的多线程.md","hash":"fc908472c2c3a4aa0cec45eac58a6b9efdb6ea74","modified":1524053999000},{"_id":"source/_posts/如何清空view上的所有子视图.md","hash":"abb80a6e7ed8b900d659a6dca54364d4eb6fb357","modified":1524053999000},{"_id":"source/about/index.md","hash":"0e2ec2dd0cbfba774e6ee085d440011ef7f2744f","modified":1524053999000},{"_id":"themes/maupassant/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1524053999000},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1514278075000},{"_id":"themes/maupassant/README.md","hash":"253b7eead5dac44c0cbc86dfc25aa352a56850c4","modified":1514278075000},{"_id":"themes/maupassant/_config.yml","hash":"b972b6144da8b0f70dc4542944c27d7a887d97c5","modified":1524045565000},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1514278075000},{"_id":"themes/maupassant/languages/de.yml","hash":"4b812b700dd79b8a2e8d83afb3fab0552b73f5f2","modified":1524053999000},{"_id":"themes/maupassant/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1524053999000},{"_id":"themes/maupassant/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1524053999000},{"_id":"themes/maupassant/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1524053999000},{"_id":"themes/maupassant/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1524053999000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1514278075000},{"_id":"themes/maupassant/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1524053999000},{"_id":"themes/maupassant/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1524053999000},{"_id":"themes/maupassant/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1524053999000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1514278075000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"418b6fa3b2bb3d21bf91b61a8e100a5f543ec31d","modified":1514441583000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1514278075000},{"_id":"themes/maupassant/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1524053999000},{"_id":"themes/maupassant/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1524053999000},{"_id":"themes/maupassant/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1524053999000},{"_id":"themes/maupassant/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1524053999000},{"_id":"themes/maupassant/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1524053999000},{"_id":"themes/maupassant/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1524053999000},{"_id":"themes/maupassant/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1524053999000},{"_id":"themes/maupassant/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1524053999000},{"_id":"themes/maupassant/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1524053999000},{"_id":"themes/maupassant/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1524053999000},{"_id":"themes/maupassant/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1524053999000},{"_id":"themes/maupassant/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1524053999000},{"_id":"themes/maupassant/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1524053999000},{"_id":"themes/maupassant/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1524053999000},{"_id":"themes/maupassant/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1524053999000},{"_id":"themes/maupassant/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1524053999000},{"_id":"themes/maupassant/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1524053999000},{"_id":"themes/maupassant/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1524053999000},{"_id":"themes/maupassant/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1524053999000},{"_id":"themes/maupassant/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1524053999000},{"_id":"themes/maupassant/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1524053999000},{"_id":"themes/maupassant/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1524053999000},{"_id":"themes/maupassant/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1524053999000},{"_id":"themes/maupassant/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1524053999000},{"_id":"themes/maupassant/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1524053999000},{"_id":"themes/maupassant/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1524053999000},{"_id":"themes/maupassant/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1524053999000},{"_id":"themes/maupassant/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1524053999000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"29a7db76d360de5164e3a9efcc41e1d15b72365d","modified":1514341248000},{"_id":"themes/maupassant/languages/en.yml","hash":"053b2cb18e3e2804277faf2cb78651be2aa066d9","modified":1514441579000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1514278075000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/.DS_Store","hash":"510c519945703d81aa040f6124020ac16b642ca8","modified":1514453555000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"532f540d1813bb7184b688cc22b292943c38fd0f","modified":1514520285000},{"_id":"themes/maupassant/layout/_partial/cnzz_tongji.pug","hash":"07036cfbfa82e16826cee2a795bee9216c815c9b","modified":1514392012000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ae5537e123f7e95e2a423dce3147ef5f3d3114b6","modified":1514453509000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"6a46b9b4400aca5d1bd4db8243a5f25d0ed40be5","modified":1516330445000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"974db7838079076f380effcb291e27b89799f0ed","modified":1514514724000},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"eb38a1b1bbde2556562edbab78c2f90fd7927e9d","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"0e2f902fd2f096ff9fcc84f4e60a8b2588962fe3","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1514278075000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1514278075000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1514278075000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1514278075000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1514278075000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1514278075000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1514278075000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1514278075000},{"_id":"themes/maupassant/layout/.DS_Store","hash":"c65c9d1aa3e98324aaca09da74ae56a88212485c","modified":1514443572000},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1514278075000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1514278075000},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1514278075000},{"_id":"themes/maupassant/layout/index.pug","hash":"ebe5495c3514e570af033728e664be4b1d4cd659","modified":1514453564000},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1514278075000},{"_id":"themes/maupassant/layout/post.pug","hash":"db3d124ee6c9d21a65996c9adc48f4d80134bd34","modified":1514514458000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1514278075000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1514278075000},{"_id":"themes/maupassant/source/css/.DS_Store","hash":"5558f0b5085f6a953fb014f6b7aa804f44c3b597","modified":1514399367000},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1514360728000},{"_id":"themes/maupassant/source/css/donate.css","hash":"d0079ba8202d925a93ab1cb44f2087b81f476755","modified":1514278075000},{"_id":"themes/maupassant/source/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1514346177000},{"_id":"themes/maupassant/source/css/style.scss","hash":"fd8349ff25385b2dea1b3edc8e62275448a66bcd","modified":1514278075000},{"_id":"themes/maupassant/source/donate/index.html","hash":"58260d8d8b5cfa3f46705914e6df164d9f08d9dd","modified":1514278075000},{"_id":"themes/maupassant/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1514375064000},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1514278075000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1514278075000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1514278075000},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1514278075000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1514278075000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1514278075000},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1514278075000},{"_id":"themes/maupassant/source/img/五角星.png","hash":"79b5e875f19125fd621a35cb927e8b1bd2eeda6d","modified":1514540998000},{"_id":"themes/maupassant/source/img/正方形.png","hash":"14c10989435d450a2aa211c1f44ff6faa1784bb2","modified":1514540397000},{"_id":"themes/maupassant/source/js/.DS_Store","hash":"879c7b0ce2d4da02d43d3c312b9f1599200ef132","modified":1514399373000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1514278075000},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1514520129000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1514278075000},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1514520288000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1514278075000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1514278075000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1514512705000},{"_id":"themes/maupassant/source/.DS_Store","hash":"866e418b16b1ef97f4f081201d84735cfada0fc2","modified":1514284977000},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"69d5a3fc3e229c3b4713b72798ba0cb974d5de37","modified":1514375011000},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"153e9353c736795d9386f006a7c850f502aa25cc","modified":1514353102000},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1514360739000},{"_id":"themes/maupassant/source/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1514346207000}],"Category":[{"name":"原理","_id":"cjg52i3ir00034hfbpoqjia7v"},{"name":"性能","_id":"cjg52i3j200084hfbyevhgscp"},{"name":"iOS","_id":"cjg52i3jd000g4hfb78h1trn5"}],"Data":[],"Page":[{"title":"关于","date":"2017-12-21T08:23:08.000Z","donate":true,"_content":"\nNickname: [monsters]()\n\nEmail: [xiaopeng__w@163.com]()\n\nGithub: [xiaopengmonsters](https://github.com/xiaopengmonsters)\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-12-21 16:23:08\ndonate: true\n---\n\nNickname: [monsters]()\n\nEmail: [xiaopeng__w@163.com]()\n\nGithub: [xiaopengmonsters](https://github.com/xiaopengmonsters)\n","updated":"2018-04-18T12:19:59.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjg52i3il00014hfbjecu7fof","content":"<p>Nickname: <a href=\"\">monsters</a></p>\n<p>Email: <a href=\"\">xiaopeng__w@163.com</a></p>\n<p>Github: <a href=\"https://github.com/xiaopengmonsters\" target=\"_blank\" rel=\"noopener\">xiaopengmonsters</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Nickname: <a href=\"\">monsters</a></p>\n<p>Email: <a href=\"\">xiaopeng__w@163.com</a></p>\n<p>Github: <a href=\"https://github.com/xiaopengmonsters\" target=\"_blank\" rel=\"noopener\">xiaopengmonsters</a></p>\n"}],"Post":[{"title":"AFNetworking框架分析","date":"2017-03-16T05:23:28.000Z","description":"想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。","toc":false,"_content":"\n想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。\n\n说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。\n\n## AFN的结构\n\n首先我们来看看AFN的结构：\n\n![](/img/AFN结构图.png)\n\n从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。\n\n1. **NSURLSession**：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。\n2. **Reachability**：网络状态监听模块\n3. **Security**：网络通讯安全策略模块 \n3. **Seriaalization**：网络通信信息序列化、反序列化模块\n4. **UIKit**：对于IOSUIKit的扩展库\n\n## 核心模块NSURLSession\n\n### 1、NSURLSession由三个基本模块构成：\n\n* NSURLSession\n* NSURLSessionConfiguation\n* NSURLSessionTask\n\nNSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求\n\nNSURLSession的行为取决于三个方面。包括\n\n* NSURLSession的类型\n* NSURLSessionTask的类型\n* 在创建task时APP是否处于前端\n\n\n### 2、NSURLSession有三种类型\n\n* defaultSession（默认会话模式）：将cache和creditials储存于本地\n\n* Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。\n\n* backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。\n\n**在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。**\n\n### 3、NSURLSessionTask包括三种Task类型\n\n* NSURLSessionDataTask\n* NSURLSessionDownLoadTask\n* NSURLSessionUploadTask\n\n所有的Task状态都是暂停的，需要用[Task resume]启动Task\n\n### 4、NSURLSession有两种获取数据的方式\n\n* 初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法\n* 初始化Session时未指定delegate的，通过block回调返回数据。\n\n### 5、NSURLSession对象的销毁，有两种销毁模式\n\n* - (void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用\n* - (void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate\n\n这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。\n\n**使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。**\n\n## 网络请求的过程\n\n创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。\n\nAFURLSessionManager封装了上述网络交互功能\nAFURLSessionManager请求过程：\n\n1. 初始化AFURLSessionManager\n2. 获取AFURLSessionManager的Task对象\n3. 启动Task\n\nAFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理\n\n初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度\n\n### NSURLSessionDelegate的响应\n\n因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。\n\n\n### 参考文章\n\n[AFNetworking实现原理理解](https://www.jianshu.com/p/02b25f6d1e1f)\n","source":"_posts/AFNetworking框架分析.md","raw":"---\ntitle: AFNetworking框架分析\ndate: 2017-3-16 13:23:28\n\ndescription: 想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。\ncategories: 原理\ntags: [Objective-C]\ntoc: false \n---\n\n想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。\n\n说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。\n\n## AFN的结构\n\n首先我们来看看AFN的结构：\n\n![](/img/AFN结构图.png)\n\n从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。\n\n1. **NSURLSession**：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。\n2. **Reachability**：网络状态监听模块\n3. **Security**：网络通讯安全策略模块 \n3. **Seriaalization**：网络通信信息序列化、反序列化模块\n4. **UIKit**：对于IOSUIKit的扩展库\n\n## 核心模块NSURLSession\n\n### 1、NSURLSession由三个基本模块构成：\n\n* NSURLSession\n* NSURLSessionConfiguation\n* NSURLSessionTask\n\nNSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求\n\nNSURLSession的行为取决于三个方面。包括\n\n* NSURLSession的类型\n* NSURLSessionTask的类型\n* 在创建task时APP是否处于前端\n\n\n### 2、NSURLSession有三种类型\n\n* defaultSession（默认会话模式）：将cache和creditials储存于本地\n\n* Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。\n\n* backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。\n\n**在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。**\n\n### 3、NSURLSessionTask包括三种Task类型\n\n* NSURLSessionDataTask\n* NSURLSessionDownLoadTask\n* NSURLSessionUploadTask\n\n所有的Task状态都是暂停的，需要用[Task resume]启动Task\n\n### 4、NSURLSession有两种获取数据的方式\n\n* 初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法\n* 初始化Session时未指定delegate的，通过block回调返回数据。\n\n### 5、NSURLSession对象的销毁，有两种销毁模式\n\n* - (void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用\n* - (void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate\n\n这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。\n\n**使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。**\n\n## 网络请求的过程\n\n创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。\n\nAFURLSessionManager封装了上述网络交互功能\nAFURLSessionManager请求过程：\n\n1. 初始化AFURLSessionManager\n2. 获取AFURLSessionManager的Task对象\n3. 启动Task\n\nAFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理\n\n初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度\n\n### NSURLSessionDelegate的响应\n\n因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。\n\n\n### 参考文章\n\n[AFNetworking实现原理理解](https://www.jianshu.com/p/02b25f6d1e1f)\n","slug":"AFNetworking框架分析","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3id00004hfbzknms9fk","content":"<p>想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。</p>\n<p>说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。</p>\n<h2 id=\"AFN的结构\"><a href=\"#AFN的结构\" class=\"headerlink\" title=\"AFN的结构\"></a>AFN的结构</h2><p>首先我们来看看AFN的结构：</p>\n<p><img src=\"/img/AFN结构图.png\" alt=\"\"></p>\n<p>从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。</p>\n<ol>\n<li><strong>NSURLSession</strong>：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。</li>\n<li><strong>Reachability</strong>：网络状态监听模块</li>\n<li><strong>Security</strong>：网络通讯安全策略模块 </li>\n<li><strong>Seriaalization</strong>：网络通信信息序列化、反序列化模块</li>\n<li><strong>UIKit</strong>：对于IOSUIKit的扩展库</li>\n</ol>\n<h2 id=\"核心模块NSURLSession\"><a href=\"#核心模块NSURLSession\" class=\"headerlink\" title=\"核心模块NSURLSession\"></a>核心模块NSURLSession</h2><h3 id=\"1、NSURLSession由三个基本模块构成：\"><a href=\"#1、NSURLSession由三个基本模块构成：\" class=\"headerlink\" title=\"1、NSURLSession由三个基本模块构成：\"></a>1、NSURLSession由三个基本模块构成：</h3><ul>\n<li>NSURLSession</li>\n<li>NSURLSessionConfiguation</li>\n<li>NSURLSessionTask</li>\n</ul>\n<p>NSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求</p>\n<p>NSURLSession的行为取决于三个方面。包括</p>\n<ul>\n<li>NSURLSession的类型</li>\n<li>NSURLSessionTask的类型</li>\n<li>在创建task时APP是否处于前端</li>\n</ul>\n<h3 id=\"2、NSURLSession有三种类型\"><a href=\"#2、NSURLSession有三种类型\" class=\"headerlink\" title=\"2、NSURLSession有三种类型\"></a>2、NSURLSession有三种类型</h3><ul>\n<li><p>defaultSession（默认会话模式）：将cache和creditials储存于本地</p>\n</li>\n<li><p>Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。</p>\n</li>\n<li><p>backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。</p>\n</li>\n</ul>\n<p><strong>在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。</strong></p>\n<h3 id=\"3、NSURLSessionTask包括三种Task类型\"><a href=\"#3、NSURLSessionTask包括三种Task类型\" class=\"headerlink\" title=\"3、NSURLSessionTask包括三种Task类型\"></a>3、NSURLSessionTask包括三种Task类型</h3><ul>\n<li>NSURLSessionDataTask</li>\n<li>NSURLSessionDownLoadTask</li>\n<li>NSURLSessionUploadTask</li>\n</ul>\n<p>所有的Task状态都是暂停的，需要用[Task resume]启动Task</p>\n<h3 id=\"4、NSURLSession有两种获取数据的方式\"><a href=\"#4、NSURLSession有两种获取数据的方式\" class=\"headerlink\" title=\"4、NSURLSession有两种获取数据的方式\"></a>4、NSURLSession有两种获取数据的方式</h3><ul>\n<li>初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法</li>\n<li>初始化Session时未指定delegate的，通过block回调返回数据。</li>\n</ul>\n<h3 id=\"5、NSURLSession对象的销毁，有两种销毁模式\"><a href=\"#5、NSURLSession对象的销毁，有两种销毁模式\" class=\"headerlink\" title=\"5、NSURLSession对象的销毁，有两种销毁模式\"></a>5、NSURLSession对象的销毁，有两种销毁模式</h3><ul>\n<li><ul>\n<li>(void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用</li>\n</ul>\n</li>\n<li><ul>\n<li>(void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate</li>\n</ul>\n</li>\n</ul>\n<p>这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。</p>\n<p><strong>使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。</strong></p>\n<h2 id=\"网络请求的过程\"><a href=\"#网络请求的过程\" class=\"headerlink\" title=\"网络请求的过程\"></a>网络请求的过程</h2><p>创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。</p>\n<p>AFURLSessionManager封装了上述网络交互功能<br>AFURLSessionManager请求过程：</p>\n<ol>\n<li>初始化AFURLSessionManager</li>\n<li>获取AFURLSessionManager的Task对象</li>\n<li>启动Task</li>\n</ol>\n<p>AFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理</p>\n<p>初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度</p>\n<h3 id=\"NSURLSessionDelegate的响应\"><a href=\"#NSURLSessionDelegate的响应\" class=\"headerlink\" title=\"NSURLSessionDelegate的响应\"></a>NSURLSessionDelegate的响应</h3><p>因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.jianshu.com/p/02b25f6d1e1f\" target=\"_blank\" rel=\"noopener\">AFNetworking实现原理理解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>想必AFNetworking网络请求框架，每个iOS开发攻城狮都晓得，也会使用，但是其内部构造及原理对小白来说还是有些生疏，这篇文章我们就来探索AFNetworking的神秘。</p>\n<p>说明：本篇文章并非原创，文章底部有原文链接，之所以整理，是因为这是学习的过程，也是整理零散知识的过程，每一遍的来过都会有意外收获。</p>\n<h2 id=\"AFN的结构\"><a href=\"#AFN的结构\" class=\"headerlink\" title=\"AFN的结构\"></a>AFN的结构</h2><p>首先我们来看看AFN的结构：</p>\n<p><img src=\"/img/AFN结构图.png\" alt=\"\"></p>\n<p>从上图可以看出，除了头文件和Support Files，AFNetworking是由NSURLSession、Reachability、Security、Serialization、UIKit五部分组成。</p>\n<ol>\n<li><strong>NSURLSession</strong>：网络通信模块（核心模块）对应AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager，AFHTTPSessionManager是继承于AFURLSessionmanager的。</li>\n<li><strong>Reachability</strong>：网络状态监听模块</li>\n<li><strong>Security</strong>：网络通讯安全策略模块 </li>\n<li><strong>Seriaalization</strong>：网络通信信息序列化、反序列化模块</li>\n<li><strong>UIKit</strong>：对于IOSUIKit的扩展库</li>\n</ol>\n<h2 id=\"核心模块NSURLSession\"><a href=\"#核心模块NSURLSession\" class=\"headerlink\" title=\"核心模块NSURLSession\"></a>核心模块NSURLSession</h2><h3 id=\"1、NSURLSession由三个基本模块构成：\"><a href=\"#1、NSURLSession由三个基本模块构成：\" class=\"headerlink\" title=\"1、NSURLSession由三个基本模块构成：\"></a>1、NSURLSession由三个基本模块构成：</h3><ul>\n<li>NSURLSession</li>\n<li>NSURLSessionConfiguation</li>\n<li>NSURLSessionTask</li>\n</ul>\n<p>NSURLSession相对于平时通信中的会话，但本身却不会进行网络数据传输，它会通过多个NSURLSessionTask去执行每次的网络请求</p>\n<p>NSURLSession的行为取决于三个方面。包括</p>\n<ul>\n<li>NSURLSession的类型</li>\n<li>NSURLSessionTask的类型</li>\n<li>在创建task时APP是否处于前端</li>\n</ul>\n<h3 id=\"2、NSURLSession有三种类型\"><a href=\"#2、NSURLSession有三种类型\" class=\"headerlink\" title=\"2、NSURLSession有三种类型\"></a>2、NSURLSession有三种类型</h3><ul>\n<li><p>defaultSession（默认会话模式）：将cache和creditials储存于本地</p>\n</li>\n<li><p>Ephemeral Session（瞬时会话模式）：对数据更加保密安全，并不会向本地储存任何数据，将cache和creditials储存在内存中，并和Session绑定，当Session销毁时，对应的数据也会被销毁。</p>\n</li>\n<li><p>backgroundSession（后台会话模式）：可以时APP处于后台时继续数据传输，其行为与defaultSession类似，但是所有的数据传输均由一个非本APP的进程来管理。也有一些功能上的限制。</p>\n</li>\n</ul>\n<p><strong>在创建Session对象时通过NSURLSessionConfigration来配置，可设置Session的delegate，Session一但配置完成，就不能修改，除非创建一个新的Session对象。</strong></p>\n<h3 id=\"3、NSURLSessionTask包括三种Task类型\"><a href=\"#3、NSURLSessionTask包括三种Task类型\" class=\"headerlink\" title=\"3、NSURLSessionTask包括三种Task类型\"></a>3、NSURLSessionTask包括三种Task类型</h3><ul>\n<li>NSURLSessionDataTask</li>\n<li>NSURLSessionDownLoadTask</li>\n<li>NSURLSessionUploadTask</li>\n</ul>\n<p>所有的Task状态都是暂停的，需要用[Task resume]启动Task</p>\n<h3 id=\"4、NSURLSession有两种获取数据的方式\"><a href=\"#4、NSURLSession有两种获取数据的方式\" class=\"headerlink\" title=\"4、NSURLSession有两种获取数据的方式\"></a>4、NSURLSession有两种获取数据的方式</h3><ul>\n<li>初始化session时指定delegate，在代理方法中返回数据，需要实现NSURLSession的两个代理方法</li>\n<li>初始化Session时未指定delegate的，通过block回调返回数据。</li>\n</ul>\n<h3 id=\"5、NSURLSession对象的销毁，有两种销毁模式\"><a href=\"#5、NSURLSession对象的销毁，有两种销毁模式\" class=\"headerlink\" title=\"5、NSURLSession对象的销毁，有两种销毁模式\"></a>5、NSURLSession对象的销毁，有两种销毁模式</h3><ul>\n<li><ul>\n<li>(void)invalidateAndCancel 取消该Session中的所有Task，销毁所有delegate、block和Session自身，调用后Session不能再复用</li>\n</ul>\n</li>\n<li><ul>\n<li>(void)finishTasksAndInvalidate 会立即返回，但不会取消已启动的task，而是当这些task完成时，调用delegate</li>\n</ul>\n</li>\n</ul>\n<p>这里有个地方需要注意，即：NSURLSession对象对其delegate都是强引用的，只有当Session对象invalidate， 才会释放delegate，否则会出现memory leak。</p>\n<p><strong>使用Session加速网络访问速度，使用同一个Session中的task访问数据，不用每次都实现三次握手，复用之前服务器和客户端之间的网络链接，从而加快访问速度。</strong></p>\n<h2 id=\"网络请求的过程\"><a href=\"#网络请求的过程\" class=\"headerlink\" title=\"网络请求的过程\"></a>网络请求的过程</h2><p>创建NSURLSessionConfig对象，用创建的config对象配置初始化NSURLSession，创建NSURLSessionTask对象并resume执行，用delegate或者block回调返回数据。</p>\n<p>AFURLSessionManager封装了上述网络交互功能<br>AFURLSessionManager请求过程：</p>\n<ol>\n<li>初始化AFURLSessionManager</li>\n<li>获取AFURLSessionManager的Task对象</li>\n<li>启动Task</li>\n</ol>\n<p>AFURLSessionManager会为每一个Task创建一个AFURLSessionmanagerTaskDelegate对象，manager会让其处理各个Task的具体事务，从而实现了manager对多个Task的管理</p>\n<p>初始化好manager后，获取一个网络请求的Task，生成一个Task对象，并创建了一个AFURLSessionmanagerTaskDelegate并将其关联，设置Task的上传和下载delegate，通过KVO监听download进度和upload进度</p>\n<h3 id=\"NSURLSessionDelegate的响应\"><a href=\"#NSURLSessionDelegate的响应\" class=\"headerlink\" title=\"NSURLSessionDelegate的响应\"></a>NSURLSessionDelegate的响应</h3><p>因为AFURLSessionmanager所管理的AFURLSession的delegate指向其自身，因此所有的NSURLSessiondelegate的回调地址都是AFURLSessionmanager，而AFURLSessionmanager又会根据是否需要具体处理会将AF delegate所响应的delegate，传递到对应的AF delegate去。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://www.jianshu.com/p/02b25f6d1e1f\" target=\"_blank\" rel=\"noopener\">AFNetworking实现原理理解</a></p>\n"},{"title":"APP的优化","date":"2018-01-08T07:21:18.000Z","description":"一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。","toc":"fales","_content":"\n一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。\n\n# 1、启动优化\n\n[iOS App 启动性能优化](https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA)这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。\n\n在这里只对启动优化做一个概括，大概分为以下几种：\n\n1. 移除不需要用到的动态库\n2. 移除不需要用到的类\n3. 合并功能类似的类和扩展（Category）\n4. 压缩资源图片\n5. 优化applicationWillFinishLaunching\n6. 优化rootViewController加载\n\n总结：\n\n* 利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时\n\n   1. 重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目\n   2. 定期扫描不再使用的动态库、类、函数，例如每两个迭代一次\n   3. 用dispatchonce()代替所有的__attribute__((constructor))函数、C++静态对象初始化、ObjC的+load \n   4. 在设计师可接受的范围内压缩图片的大小，会有意外收获\n\n\n* 利用锚点分析applicationWillFinishLaunching的耗时\n\n   1. 将不需要马上在applicationWillFinishLaunching执行的代码延后执行\n   2. rootViewController的加载，适当将某一级的childViewController或subviews延后加载\n   3. 如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController\n\n   \n* 不应放过的一些小细节\n\n   1. 异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵\n   2. 有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画\n\n\n计算代码执行耗时（用Instruments也可以）：\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    \n    CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n    \n    // do something\n    \n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    \n    NSLog(@\"%fms\",(end -start)*1000);\n     \n}\n\n```\n\n# 2、UITableView的优化\n\nUITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解[UITableView优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)的文章，在这里就不具体描述。\n\n# 3、未完待续。。。\n","source":"_posts/APP的优化.md","raw":"---\ntitle: APP的优化\ndate: 2018-1-8 15:21:18\n\ndescription: 一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。\n\ncategories: [性能]\ntags: [Objective-C]\ntoc: fales \n---\n\n一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。\n\n# 1、启动优化\n\n[iOS App 启动性能优化](https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA)这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。\n\n在这里只对启动优化做一个概括，大概分为以下几种：\n\n1. 移除不需要用到的动态库\n2. 移除不需要用到的类\n3. 合并功能类似的类和扩展（Category）\n4. 压缩资源图片\n5. 优化applicationWillFinishLaunching\n6. 优化rootViewController加载\n\n总结：\n\n* 利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时\n\n   1. 重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目\n   2. 定期扫描不再使用的动态库、类、函数，例如每两个迭代一次\n   3. 用dispatchonce()代替所有的__attribute__((constructor))函数、C++静态对象初始化、ObjC的+load \n   4. 在设计师可接受的范围内压缩图片的大小，会有意外收获\n\n\n* 利用锚点分析applicationWillFinishLaunching的耗时\n\n   1. 将不需要马上在applicationWillFinishLaunching执行的代码延后执行\n   2. rootViewController的加载，适当将某一级的childViewController或subviews延后加载\n   3. 如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController\n\n   \n* 不应放过的一些小细节\n\n   1. 异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵\n   2. 有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画\n\n\n计算代码执行耗时（用Instruments也可以）：\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    \n    CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();\n    \n    // do something\n    \n    CFAbsoluteTime end = CFAbsoluteTimeGetCurrent();\n    \n    NSLog(@\"%fms\",(end -start)*1000);\n     \n}\n\n```\n\n# 2、UITableView的优化\n\nUITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解[UITableView优化](https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/)的文章，在这里就不具体描述。\n\n# 3、未完待续。。。\n","slug":"APP的优化","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3im00024hfb5glkqce2","content":"<p>一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。</p>\n<h1 id=\"1、启动优化\"><a href=\"#1、启动优化\" class=\"headerlink\" title=\"1、启动优化\"></a>1、启动优化</h1><p><a href=\"https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA\" target=\"_blank\" rel=\"noopener\">iOS App 启动性能优化</a>这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。</p>\n<p>在这里只对启动优化做一个概括，大概分为以下几种：</p>\n<ol>\n<li>移除不需要用到的动态库</li>\n<li>移除不需要用到的类</li>\n<li>合并功能类似的类和扩展（Category）</li>\n<li>压缩资源图片</li>\n<li>优化applicationWillFinishLaunching</li>\n<li>优化rootViewController加载</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><p>利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时</p>\n<ol>\n<li>重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目</li>\n<li>定期扫描不再使用的动态库、类、函数，例如每两个迭代一次</li>\n<li>用dispatchonce()代替所有的<strong>attribute</strong>((constructor))函数、C++静态对象初始化、ObjC的+load </li>\n<li>在设计师可接受的范围内压缩图片的大小，会有意外收获</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>利用锚点分析applicationWillFinishLaunching的耗时</p>\n<ol>\n<li>将不需要马上在applicationWillFinishLaunching执行的代码延后执行</li>\n<li>rootViewController的加载，适当将某一级的childViewController或subviews延后加载</li>\n<li>如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>不应放过的一些小细节</p>\n<ol>\n<li>异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵</li>\n<li>有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画</li>\n</ol>\n</li>\n</ul>\n<p>计算代码执行耗时（用Instruments也可以）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%fms\"</span>,(end -start)*<span class=\"number\">1000</span>);</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、UITableView的优化\"><a href=\"#2、UITableView的优化\" class=\"headerlink\" title=\"2、UITableView的优化\"></a>2、UITableView的优化</h1><p>UITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解<a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView优化</a>的文章，在这里就不具体描述。</p>\n<h1 id=\"3、未完待续。。。\"><a href=\"#3、未完待续。。。\" class=\"headerlink\" title=\"3、未完待续。。。\"></a>3、未完待续。。。</h1>","site":{"data":{}},"excerpt":"","more":"<p>一款APP开发出来以后，并不能单单关注的它的功能，重中之重是其性能，只有性能优越，用户体验才能提高，这样才能留住用户，让用户觉得我们是在用心最开发✧(≖ ◡ ≖✿)。</p>\n<h1 id=\"1、启动优化\"><a href=\"#1、启动优化\" class=\"headerlink\" title=\"1、启动优化\"></a>1、启动优化</h1><p><a href=\"https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA\" target=\"_blank\" rel=\"noopener\">iOS App 启动性能优化</a>这篇文章很详细的介绍了启动的性能优化，其中还介绍了一些与启动相关的知识，值得一看。</p>\n<p>在这里只对启动优化做一个概括，大概分为以下几种：</p>\n<ol>\n<li>移除不需要用到的动态库</li>\n<li>移除不需要用到的类</li>\n<li>合并功能类似的类和扩展（Category）</li>\n<li>压缩资源图片</li>\n<li>优化applicationWillFinishLaunching</li>\n<li>优化rootViewController加载</li>\n</ol>\n<p>总结：</p>\n<ul>\n<li><p>利用DYLD_PRINT_STATISTICS分析main()函数之前的耗时</p>\n<ol>\n<li>重新梳理架构，减少动态库、ObjC类的数目，减少Category的数目</li>\n<li>定期扫描不再使用的动态库、类、函数，例如每两个迭代一次</li>\n<li>用dispatchonce()代替所有的<strong>attribute</strong>((constructor))函数、C++静态对象初始化、ObjC的+load </li>\n<li>在设计师可接受的范围内压缩图片的大小，会有意外收获</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>利用锚点分析applicationWillFinishLaunching的耗时</p>\n<ol>\n<li>将不需要马上在applicationWillFinishLaunching执行的代码延后执行</li>\n<li>rootViewController的加载，适当将某一级的childViewController或subviews延后加载</li>\n<li>如果你的App可能会被后台拉起并冷启动，可考虑不加载rootViewController</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><p>不应放过的一些小细节</p>\n<ol>\n<li>异步操作并不影响指标，但有可能影响交互体验，例如大量网络请求导致数据拥堵</li>\n<li>有时候一些交互上的优化比技术手段效果更明显，视觉上的快决不是冰冷的数据可以解释的，好好和你们的设计师谈谈动画</li>\n</ol>\n</li>\n</ul>\n<p>计算代码执行耗时（用Instruments也可以）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> start = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CFAbsoluteTime</span> end = <span class=\"built_in\">CFAbsoluteTimeGetCurrent</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%fms\"</span>,(end -start)*<span class=\"number\">1000</span>);</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、UITableView的优化\"><a href=\"#2、UITableView的优化\" class=\"headerlink\" title=\"2、UITableView的优化\"></a>2、UITableView的优化</h1><p>UITableView是APP最重要的控件之一，几乎所有APP都会用到UITableView，因此它的优化也为APP优化重中之重，是优化APP必不可少的以部门。前面写过一篇专门讲解<a href=\"https://xiaopengmonsters.github.io/2017/12/26/UITableView%E7%9A%84%E4%BC%98%E5%8C%96/\" target=\"_blank\" rel=\"noopener\">UITableView优化</a>的文章，在这里就不具体描述。</p>\n<h1 id=\"3、未完待续。。。\"><a href=\"#3、未完待续。。。\" class=\"headerlink\" title=\"3、未完待续。。。\"></a>3、未完待续。。。</h1>"},{"title":"CAlayer","date":"2016-12-18T05:54:01.000Z","description":"在平时开发中，我们经常使用到UILable、UIButton、UIImageView、UITextField等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。","_content":"\n主要从以下几个方面了解CAlayer：\n\n1. CALayer和UIView的关系\n2. CALayer的基本属性\n3. position和anchorPoint的作用\n4. CALayer和UIView的选择\n3. CALayer所属框架\n4. CALayer的隐式动画\n4. 自定义图层\n\n\n在平时开发中，我们经常使用到`UILable`、`UIButton`、`UIImageView`、`UITextField`等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。\n\n\n这里有[UIKit框架结构图](https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2)，此图来自简书@不懂技术的爱迪生。\n\n这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。\n\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\n\n# CALayer和UIView的关系\n* 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。\n\n```\n@property(nonatomic,readonly,retain) CALayer *layer; \n\n```\n\n* CALayer的基本属性\n\n``` bash\n 宽度和高度\n @property CGRect bounds;\n \n 位置(默认指中点，具体由anchorPoint决定)\n @property CGPoint position;\n \n 锚点(x,y的范围都是0-1)，决定了position的含义\n @property CGPoint anchorPoint;\n \n 背景颜色(CGColorRef类型)\n @property CGColorRef backgroundColor;\n \n 形变属性\n @property CATransform3D transform;\n \n 让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)\n @property CGRect contentsRect;\n \n 边框颜色(CGColorRef类型)\n @property CGColorRef borderColor;\n \n 边框宽度\n @property CGFloat borderWidth;\n \n 圆角半径\n @property CGFloat cornerRadius;\n \n 内容(比如设置为图片CGImageRef)\n @property(retain) id contents;\n```\n* CALayer的阴影属性\n\n```\n阴影颜色\n@property CGColorRef shadowColor;\n \n阴影不透明(0.0 ~ 1.0)\n@property float shadowOpacity;\n \n阴影偏移位置\n@property CGSize shadowOffset;\n```\n\n* CALayer的使用时的问题（存在的疑惑）\n\n首先，CALayer是定义在QuartzCore框架中的(Core Animation)\nCGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的\n \n其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。\n \n为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。\n\n## CALayer的position和anchorPoint\n\n position和anchorPoint是CALayer非常重要的2个属性\n\n\n```\n@property CGPoint position;\n```\n\n* position:它是用来设置当前的layer在父控件当中的位置的,\n所以它的坐标原点.以父控件的左上角为(0.0)点.\n\n```\n@property CGPoint anchorPoint;\n```\n\n\n\n* anchorPoint称为“定位点”、“锚点”\n决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.\n\n\n\n# UIView和CALayer的选择\n\n\n通过CALayer，就能做出跟UIView一样的界面效果\n \n但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，\n所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。\n当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。\n\n\n那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。\n\n# 隐式动画\n\n先了解是什么根层和非根层.\n\n\n* 根层:UIView内部自动关联着的那个layer我们称它是根层\n* 非根层:自己手动创建的层,称为非根层\n\n什么是隐式动画？\n\n* 隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.\n我们称这个默认产生的动画为隐式动画.\n\n关闭隐式动画效果\n\n\n* 首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.\n* 什么是事务?\n很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.\n\n```\n开启事务\n[CATransaction begin];\n\n设置事务没有动画\n[CATransaction setDisableActions:NO];\n\n设置隐式动画执行的时长\n[CATransaction setAnimationDuration:2];\n\n提交事务\n[CATransaction commit];\n```\n\n\n# 自定义图层\n\n## 方法一\n\n### 方法描述：\n\n\n设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n\n```\n//创建图层\nCALayer *layer = [CALayer layer];\n// 设置delegate  设置了CALayer的delegate，这里的self是指控制器\n\nlayer.delegate = self;\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n\n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n\n// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图\n[layer setNeedsDisplay];\n\n//将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n\n```\n\n```\n#pragma mark 画一个矩形框\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {\n    \n    // 设置蓝色\n    CGContextSetRGBStrokeColor(ctx, 0, 0, 1, 1);\n    \n    // 设置边框宽度\n    CGContextSetLineWidth(ctx, 10);\n    \n    // 添加一个跟层一样大的矩形到路径中\n    CGContextAddRect(ctx, layer.bounds);\n    \n    // 绘制路径\n    CGContextStrokePath(ctx);\n}\n\n```\n### 效果\n\n![](/img/五角星.png)\n\n## 方法二\n\n### 方法描述：\n* 创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图\n\n```\n//创建自定义图层类\nXPCALayer *layer = [XPCALayer layer];\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n \n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n    \n// 设置图层颜色\nlayer.backgroundColor = [UIColor redColor].CGColor;\n    \n// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图\n[layer setNeedsDisplay];\n    \n // 将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n```\n\n* 类内的实现，重写父类方法，绘制一个实心三角\n\n```\n- (void)drawInContext:(CGContextRef)ctx{\n    \n    // 设置为蓝色\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    \n    // 设置起点\n    CGContextMoveToPoint(ctx, 50, 0);\n    \n    // 从(50, 0)连线到(0, 100)\n    CGContextAddLineToPoint(ctx, 0, 100);\n    \n    // 从(0, 100)连线到(100, 100)\n    CGContextAddLineToPoint(ctx, 100, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 0, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 100, 100);\n    \n    // 合并路径，连接起点和终点\n    CGContextClosePath(ctx);\n    \n    // 绘制路径\n    CGContextFillPath(ctx);\n}\n\n```\n### 效果\n\n![](/img/正方形.png)\n\n\n## 总结\n\n### 1.注意\n\n\n* 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n \n###  2.UIView的详细显示过程\n * 当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法\n * 平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕\n  \n","source":"_posts/CAlayer.md","raw":"---\ntitle: CAlayer\ndate: 2016-12-18 13:54:01\ncategories: iOS\ndescription: 在平时开发中，我们经常使用到UILable、UIButton、UIImageView、UITextField等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。\ntags: [Objective-C]\n---\n\n主要从以下几个方面了解CAlayer：\n\n1. CALayer和UIView的关系\n2. CALayer的基本属性\n3. position和anchorPoint的作用\n4. CALayer和UIView的选择\n3. CALayer所属框架\n4. CALayer的隐式动画\n4. 自定义图层\n\n\n在平时开发中，我们经常使用到`UILable`、`UIButton`、`UIImageView`、`UITextField`等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。\n\n\n这里有[UIKit框架结构图](https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2)，此图来自简书@不懂技术的爱迪生。\n\n这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。\n\n当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。\n\n# CALayer和UIView的关系\n* 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。\n\n```\n@property(nonatomic,readonly,retain) CALayer *layer; \n\n```\n\n* CALayer的基本属性\n\n``` bash\n 宽度和高度\n @property CGRect bounds;\n \n 位置(默认指中点，具体由anchorPoint决定)\n @property CGPoint position;\n \n 锚点(x,y的范围都是0-1)，决定了position的含义\n @property CGPoint anchorPoint;\n \n 背景颜色(CGColorRef类型)\n @property CGColorRef backgroundColor;\n \n 形变属性\n @property CATransform3D transform;\n \n 让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)\n @property CGRect contentsRect;\n \n 边框颜色(CGColorRef类型)\n @property CGColorRef borderColor;\n \n 边框宽度\n @property CGFloat borderWidth;\n \n 圆角半径\n @property CGFloat cornerRadius;\n \n 内容(比如设置为图片CGImageRef)\n @property(retain) id contents;\n```\n* CALayer的阴影属性\n\n```\n阴影颜色\n@property CGColorRef shadowColor;\n \n阴影不透明(0.0 ~ 1.0)\n@property float shadowOpacity;\n \n阴影偏移位置\n@property CGSize shadowOffset;\n```\n\n* CALayer的使用时的问题（存在的疑惑）\n\n首先，CALayer是定义在QuartzCore框架中的(Core Animation)\nCGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的\n \n其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。\n \n为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。\n\n## CALayer的position和anchorPoint\n\n position和anchorPoint是CALayer非常重要的2个属性\n\n\n```\n@property CGPoint position;\n```\n\n* position:它是用来设置当前的layer在父控件当中的位置的,\n所以它的坐标原点.以父控件的左上角为(0.0)点.\n\n```\n@property CGPoint anchorPoint;\n```\n\n\n\n* anchorPoint称为“定位点”、“锚点”\n决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.\n\n\n\n# UIView和CALayer的选择\n\n\n通过CALayer，就能做出跟UIView一样的界面效果\n \n但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，\n所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。\n当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。\n\n\n那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。\n\n# 隐式动画\n\n先了解是什么根层和非根层.\n\n\n* 根层:UIView内部自动关联着的那个layer我们称它是根层\n* 非根层:自己手动创建的层,称为非根层\n\n什么是隐式动画？\n\n* 隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.\n我们称这个默认产生的动画为隐式动画.\n\n关闭隐式动画效果\n\n\n* 首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.\n* 什么是事务?\n很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.\n\n```\n开启事务\n[CATransaction begin];\n\n设置事务没有动画\n[CATransaction setDisableActions:NO];\n\n设置隐式动画执行的时长\n[CATransaction setAnimationDuration:2];\n\n提交事务\n[CATransaction commit];\n```\n\n\n# 自定义图层\n\n## 方法一\n\n### 方法描述：\n\n\n设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。\n\n```\n//创建图层\nCALayer *layer = [CALayer layer];\n// 设置delegate  设置了CALayer的delegate，这里的self是指控制器\n\nlayer.delegate = self;\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n\n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n\n// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图\n[layer setNeedsDisplay];\n\n//将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n\n```\n\n```\n#pragma mark 画一个矩形框\n- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {\n    \n    // 设置蓝色\n    CGContextSetRGBStrokeColor(ctx, 0, 0, 1, 1);\n    \n    // 设置边框宽度\n    CGContextSetLineWidth(ctx, 10);\n    \n    // 添加一个跟层一样大的矩形到路径中\n    CGContextAddRect(ctx, layer.bounds);\n    \n    // 绘制路径\n    CGContextStrokePath(ctx);\n}\n\n```\n### 效果\n\n![](/img/五角星.png)\n\n## 方法二\n\n### 方法描述：\n* 创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图\n\n```\n//创建自定义图层类\nXPCALayer *layer = [XPCALayer layer];\n\n// 设置层的宽高\nlayer.bounds = CGRectMake(0, 0, 100, 100);\n \n// 设置层的位置\nlayer.position = CGPointMake(100, 100);\n    \n// 设置图层颜色\nlayer.backgroundColor = [UIColor redColor].CGColor;\n    \n// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图\n[layer setNeedsDisplay];\n    \n // 将图层添加到view的根层上\n[self.view.layer addSublayer:layer];\n```\n\n* 类内的实现，重写父类方法，绘制一个实心三角\n\n```\n- (void)drawInContext:(CGContextRef)ctx{\n    \n    // 设置为蓝色\n    CGContextSetRGBFillColor(ctx, 0, 0, 1, 1);\n    \n    // 设置起点\n    CGContextMoveToPoint(ctx, 50, 0);\n    \n    // 从(50, 0)连线到(0, 100)\n    CGContextAddLineToPoint(ctx, 0, 100);\n    \n    // 从(0, 100)连线到(100, 100)\n    CGContextAddLineToPoint(ctx, 100, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 0, 100/3);\n    \n    CGContextAddLineToPoint(ctx, 100, 100);\n    \n    // 合并路径，连接起点和终点\n    CGContextClosePath(ctx);\n    \n    // 绘制路径\n    CGContextFillPath(ctx);\n}\n\n```\n### 效果\n\n![](/img/正方形.png)\n\n\n## 总结\n\n### 1.注意\n\n\n* 无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。\n \n###  2.UIView的详细显示过程\n * 当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法\n * 平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕\n  \n","slug":"CAlayer","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3iv00054hfbp7k025h7","content":"<p>主要从以下几个方面了解CAlayer：</p>\n<ol>\n<li>CALayer和UIView的关系</li>\n<li>CALayer的基本属性</li>\n<li>position和anchorPoint的作用</li>\n<li>CALayer和UIView的选择</li>\n<li>CALayer所属框架</li>\n<li>CALayer的隐式动画</li>\n<li>自定义图层</li>\n</ol>\n<p>在平时开发中，我们经常使用到<code>UILable</code>、<code>UIButton</code>、<code>UIImageView</code>、<code>UITextField</code>等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。</p>\n<p>这里有<a href=\"https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2\" target=\"_blank\" rel=\"noopener\">UIKit框架结构图</a>，此图来自简书@不懂技术的爱迪生。</p>\n<p>这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。</p>\n<p>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。</p>\n<h1 id=\"CALayer和UIView的关系\"><a href=\"#CALayer和UIView的关系\" class=\"headerlink\" title=\"CALayer和UIView的关系\"></a>CALayer和UIView的关系</h1><ul>\n<li>在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) CALayer *layer;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的基本属性</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">宽度和高度</span><br><span class=\"line\">@property CGRect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">位置(默认指中点，具体由anchorPoint决定)</span><br><span class=\"line\">@property CGPoint position;</span><br><span class=\"line\"></span><br><span class=\"line\">锚点(x,y的范围都是0-1)，决定了position的含义</span><br><span class=\"line\">@property CGPoint anchorPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">背景颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">形变属性</span><br><span class=\"line\">@property CATransform3D transform;</span><br><span class=\"line\"></span><br><span class=\"line\">让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)</span><br><span class=\"line\">@property CGRect contentsRect;</span><br><span class=\"line\"></span><br><span class=\"line\">边框颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef borderColor;</span><br><span class=\"line\"></span><br><span class=\"line\">边框宽度</span><br><span class=\"line\">@property CGFloat borderWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">圆角半径</span><br><span class=\"line\">@property CGFloat cornerRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">内容(比如设置为图片CGImageRef)</span><br><span class=\"line\">@property(retain) id contents;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的阴影属性</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阴影颜色</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGColorRef shadowColor;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影不透明(<span class=\"number\">0.0</span> ~ <span class=\"number\">1.0</span>)</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>float shadowOpacity;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影偏移位置</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGSize shadowOffset;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的使用时的问题（存在的疑惑）</li>\n</ul>\n<p>首先，CALayer是定义在QuartzCore框架中的(Core Animation)<br>CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的</p>\n<p>其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。</p>\n<p>为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。</p>\n<h2 id=\"CALayer的position和anchorPoint\"><a href=\"#CALayer的position和anchorPoint\" class=\"headerlink\" title=\"CALayer的position和anchorPoint\"></a>CALayer的position和anchorPoint</h2><p> position和anchorPoint是CALayer非常重要的2个属性</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGPoint position;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>position:它是用来设置当前的layer在父控件当中的位置的,<br>所以它的坐标原点.以父控件的左上角为(0.0)点.</li>\n</ul>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property CGPoint <span class=\"built_in\">anchor</span>Point;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>anchorPoint称为“定位点”、“锚点”<br>决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.</li>\n</ul>\n<h1 id=\"UIView和CALayer的选择\"><a href=\"#UIView和CALayer的选择\" class=\"headerlink\" title=\"UIView和CALayer的选择\"></a>UIView和CALayer的选择</h1><p>通过CALayer，就能做出跟UIView一样的界面效果</p>\n<p>但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，<br>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。<br>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。</p>\n<p>那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。</p>\n<h1 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h1><p>先了解是什么根层和非根层.</p>\n<ul>\n<li>根层:UIView内部自动关联着的那个layer我们称它是根层</li>\n<li>非根层:自己手动创建的层,称为非根层</li>\n</ul>\n<p>什么是隐式动画？</p>\n<ul>\n<li>隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.<br>我们称这个默认产生的动画为隐式动画.</li>\n</ul>\n<p>关闭隐式动画效果</p>\n<ul>\n<li>首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.</li>\n<li>什么是事务?<br>很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开启事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\"></span><br><span class=\"line\">设置事务没有动画</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">设置隐式动画执行的时长</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setAnimationDuration:<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">提交事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义图层\"><a href=\"#自定义图层\" class=\"headerlink\" title=\"自定义图层\"></a>自定义图层</h1><h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><h3 id=\"方法描述：\"><a href=\"#方法描述：\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><p>设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建图层</span></span><br><span class=\"line\"><span class=\"built_in\">CALayer</span> *layer = [<span class=\"built_in\">CALayer</span> layer];</span><br><span class=\"line\"><span class=\"comment\">// 设置delegate  设置了CALayer的delegate，这里的self是指控制器</span></span><br><span class=\"line\"></span><br><span class=\"line\">layer.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#pragma</span> <span class=\"selector-tag\">mark</span> 画一个矩形框</span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawLayer</span><span class=\"selector-pseudo\">:(CALayer</span> *)<span class=\"selector-tag\">layer</span> <span class=\"selector-tag\">inContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBStrokeColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置边框宽度</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加一个跟层一样大的矩形到路径中</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddRect</span>(ctx, layer.bounds);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextStrokePath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/五角星.png\" alt=\"\"></p>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><h3 id=\"方法描述：-1\"><a href=\"#方法描述：-1\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><ul>\n<li>创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建自定义图层类</span></span><br><span class=\"line\">XPCALayer *layer = [XPCALayer layer];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 设置图层颜色</span></span><br><span class=\"line\">layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// 将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类内的实现，重写父类方法，绘制一个实心三角</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawInContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置为蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置起点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">50</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(50, 0)连线到(0, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(0, 100)连线到(100, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 合并路径，连接起点和终点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextClosePath</span>(ctx);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextFillPath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果-1\"><a href=\"#效果-1\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/正方形.png\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"1-注意\"><a href=\"#1-注意\" class=\"headerlink\" title=\"1.注意\"></a>1.注意</h3><ul>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n</ul>\n<h3 id=\"2-UIView的详细显示过程\"><a href=\"#2-UIView的详细显示过程\" class=\"headerlink\" title=\"2.UIView的详细显示过程\"></a>2.UIView的详细显示过程</h3><ul>\n<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法</li>\n<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>主要从以下几个方面了解CAlayer：</p>\n<ol>\n<li>CALayer和UIView的关系</li>\n<li>CALayer的基本属性</li>\n<li>position和anchorPoint的作用</li>\n<li>CALayer和UIView的选择</li>\n<li>CALayer所属框架</li>\n<li>CALayer的隐式动画</li>\n<li>自定义图层</li>\n</ol>\n<p>在平时开发中，我们经常使用到<code>UILable</code>、<code>UIButton</code>、<code>UIImageView</code>、<code>UITextField</code>等都是UIView的子类（可以去了解一下UIKit框架），UIView之所以能显示在屏幕上，完全是因为它内部的一个图层。</p>\n<p>这里有<a href=\"https://upload-images.jianshu.io/upload_images/1829339-9089f59e204212d2\" target=\"_blank\" rel=\"noopener\">UIKit框架结构图</a>，此图来自简书@不懂技术的爱迪生。</p>\n<p>这个图层就是CALayer，它并不属于UIKit框架，后面会讲到。其实UIView本身不具备显示的功能，是它内部的层才有显示功能。</p>\n<p>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。</p>\n<h1 id=\"CALayer和UIView的关系\"><a href=\"#CALayer和UIView的关系\" class=\"headerlink\" title=\"CALayer和UIView的关系\"></a>CALayer和UIView的关系</h1><ul>\n<li>在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">readonly</span>,<span class=\"keyword\">retain</span>) CALayer *layer;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的基本属性</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">宽度和高度</span><br><span class=\"line\">@property CGRect bounds;</span><br><span class=\"line\"></span><br><span class=\"line\">位置(默认指中点，具体由anchorPoint决定)</span><br><span class=\"line\">@property CGPoint position;</span><br><span class=\"line\"></span><br><span class=\"line\">锚点(x,y的范围都是0-1)，决定了position的含义</span><br><span class=\"line\">@property CGPoint anchorPoint;</span><br><span class=\"line\"></span><br><span class=\"line\">背景颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef backgroundColor;</span><br><span class=\"line\"></span><br><span class=\"line\">形变属性</span><br><span class=\"line\">@property CATransform3D transform;</span><br><span class=\"line\"></span><br><span class=\"line\">让图片显示固定区域(比如可以让一个图片只显示上半部分或者下半部分甚至更小)</span><br><span class=\"line\">@property CGRect contentsRect;</span><br><span class=\"line\"></span><br><span class=\"line\">边框颜色(CGColorRef类型)</span><br><span class=\"line\">@property CGColorRef borderColor;</span><br><span class=\"line\"></span><br><span class=\"line\">边框宽度</span><br><span class=\"line\">@property CGFloat borderWidth;</span><br><span class=\"line\"></span><br><span class=\"line\">圆角半径</span><br><span class=\"line\">@property CGFloat cornerRadius;</span><br><span class=\"line\"></span><br><span class=\"line\">内容(比如设置为图片CGImageRef)</span><br><span class=\"line\">@property(retain) id contents;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的阴影属性</li>\n</ul>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">阴影颜色</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGColorRef shadowColor;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影不透明(<span class=\"number\">0.0</span> ~ <span class=\"number\">1.0</span>)</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>float shadowOpacity;</span><br><span class=\"line\"> </span><br><span class=\"line\">阴影偏移位置</span><br><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGSize shadowOffset;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CALayer的使用时的问题（存在的疑惑）</li>\n</ul>\n<p>首先，CALayer是定义在QuartzCore框架中的(Core Animation)<br>CGImageRef、CGColorRef两种数据类型是定义在CoreGraphics框架中的，UIColor、UIImage是定义在UIKit框架中的</p>\n<p>其次，QuartzCore框架和CoreGraphics框架是可以跨平台使用的，在iOS和Mac OS X上都能使用，但是UIKit只能在iOS中使用。</p>\n<p>为了保证可移植性，QuartzCore不能使用UIImage、UIColor，只能使用CGImageRef、CGColorRef。</p>\n<h2 id=\"CALayer的position和anchorPoint\"><a href=\"#CALayer的position和anchorPoint\" class=\"headerlink\" title=\"CALayer的position和anchorPoint\"></a>CALayer的position和anchorPoint</h2><p> position和anchorPoint是CALayer非常重要的2个属性</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>CGPoint position;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>position:它是用来设置当前的layer在父控件当中的位置的,<br>所以它的坐标原点.以父控件的左上角为(0.0)点.</li>\n</ul>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property CGPoint <span class=\"built_in\">anchor</span>Point;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>anchorPoint称为“定位点”、“锚点”<br>决定着CALayer身上的哪个点会在position属性所指的位置，以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为（0.5, 0.5），意味着锚点在layer的中间.</li>\n</ul>\n<h1 id=\"UIView和CALayer的选择\"><a href=\"#UIView和CALayer的选择\" class=\"headerlink\" title=\"UIView和CALayer的选择\"></a>UIView和CALayer的选择</h1><p>通过CALayer，就能做出跟UIView一样的界面效果</p>\n<p>但是，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以，<br>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。<br>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。</p>\n<p>那么，从实质来讲，UIView仅仅是对CALayer的一层封装，实现了CALayer的delegate，提供了处理事件交互的具体功能，还有动画底层方法的高级API。可以说CALayer是UIView的内部实现细节。</p>\n<h1 id=\"隐式动画\"><a href=\"#隐式动画\" class=\"headerlink\" title=\"隐式动画\"></a>隐式动画</h1><p>先了解是什么根层和非根层.</p>\n<ul>\n<li>根层:UIView内部自动关联着的那个layer我们称它是根层</li>\n<li>非根层:自己手动创建的层,称为非根层</li>\n</ul>\n<p>什么是隐式动画？</p>\n<ul>\n<li>隐式动画就是当对非根层的部分属性(bounds、backgroundColor、position等)进行修改时, 它会自动的产生一些动画的效果.<br>我们称这个默认产生的动画为隐式动画.</li>\n</ul>\n<p>关闭隐式动画效果</p>\n<ul>\n<li>首先要了解动画底层是怎么做的.动画的底层是包装成一个事务来进行的.</li>\n<li>什么是事务?<br>很多操作绑定在一起,当这些操作执行完毕后,才去执行下一个操作.</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">开启事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> begin];</span><br><span class=\"line\"></span><br><span class=\"line\">设置事务没有动画</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setDisableActions:<span class=\"literal\">NO</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">设置隐式动画执行的时长</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> setAnimationDuration:<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">提交事务</span><br><span class=\"line\">[<span class=\"built_in\">CATransaction</span> commit];</span><br></pre></td></tr></table></figure>\n<h1 id=\"自定义图层\"><a href=\"#自定义图层\" class=\"headerlink\" title=\"自定义图层\"></a>自定义图层</h1><h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><h3 id=\"方法描述：\"><a href=\"#方法描述：\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><p>设置CALayer的delegate，然后让delegate实现drawLayer:inContext:方法，当CALayer需要绘图时，会调用delegate的drawLayer:inContext:方法进行绘图。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建图层</span></span><br><span class=\"line\"><span class=\"built_in\">CALayer</span> *layer = [<span class=\"built_in\">CALayer</span> layer];</span><br><span class=\"line\"><span class=\"comment\">// 设置delegate  设置了CALayer的delegate，这里的self是指控制器</span></span><br><span class=\"line\"></span><br><span class=\"line\">layer.delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层 需要调用setNeedsDisplay这个方法，才会通知delegate进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#pragma</span> <span class=\"selector-tag\">mark</span> 画一个矩形框</span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawLayer</span><span class=\"selector-pseudo\">:(CALayer</span> *)<span class=\"selector-tag\">layer</span> <span class=\"selector-tag\">inContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBStrokeColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置边框宽度</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetLineWidth</span>(ctx, <span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加一个跟层一样大的矩形到路径中</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddRect</span>(ctx, layer.bounds);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextStrokePath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/五角星.png\" alt=\"\"></p>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><h3 id=\"方法描述：-1\"><a href=\"#方法描述：-1\" class=\"headerlink\" title=\"方法描述：\"></a>方法描述：</h3><ul>\n<li>创建一个CALayer的子类，然后覆盖drawInContext:方法，使用Quartz2D API进行绘图</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建自定义图层类</span></span><br><span class=\"line\">XPCALayer *layer = [XPCALayer layer];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置层的宽高</span></span><br><span class=\"line\">layer.bounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 设置层的位置</span></span><br><span class=\"line\">layer.position = <span class=\"built_in\">CGPointMake</span>(<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 设置图层颜色</span></span><br><span class=\"line\">layer.backgroundColor = [<span class=\"built_in\">UIColor</span> redColor].CGColor;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 开始绘制图层  需要调用setNeedsDisplay这个方法，才会触发drawInContext:方法的调用，然后进行绘图</span></span><br><span class=\"line\">[layer setNeedsDisplay];</span><br><span class=\"line\">    </span><br><span class=\"line\"> <span class=\"comment\">// 将图层添加到view的根层上</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view.layer addSublayer:layer];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类内的实现，重写父类方法，绘制一个实心三角</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">drawInContext</span><span class=\"selector-pseudo\">:(CGContextRef)ctx</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置为蓝色</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextSetRGBFillColor</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置起点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextMoveToPoint</span>(ctx, <span class=\"number\">50</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(50, 0)连线到(0, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从(0, 100)连线到(100, 100)</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">0</span>, <span class=\"number\">100</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextAddLineToPoint</span>(ctx, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 合并路径，连接起点和终点</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextClosePath</span>(ctx);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 绘制路径</span></span><br><span class=\"line\">    <span class=\"selector-tag\">CGContextFillPath</span>(ctx);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"效果-1\"><a href=\"#效果-1\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/img/正方形.png\" alt=\"\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"1-注意\"><a href=\"#1-注意\" class=\"headerlink\" title=\"1.注意\"></a>1.注意</h3><ul>\n<li>无论采取哪种方法来自定义层，都必须调用CALayer的setNeedsDisplay方法才能正常绘图。</li>\n</ul>\n<h3 id=\"2-UIView的详细显示过程\"><a href=\"#2-UIView的详细显示过程\" class=\"headerlink\" title=\"2.UIView的详细显示过程\"></a>2.UIView的详细显示过程</h3><ul>\n<li>当UIView需要显示时，它内部的层会准备好一个CGContextRef(图形上下文)，然后调用delegate(这里就是UIView)的drawLayer:inContext:方法，并且传入已经准备好的CGContextRef对象。而UIView在drawLayer:inContext:方法中又会调用自己的drawRect:方法</li>\n<li>平时在drawRect:中通过UIGraphicsGetCurrentContext()获取的就是由层传入的CGContextRef对象，在drawRect:中完成的所有绘图都会填入层的CGContextRef中，然后被拷贝至屏幕</li>\n</ul>\n"},{"title":"LLDB","date":"2017-01-05T05:10:18.000Z","description":null,"_content":"\n\n待续","source":"_posts/LLDB.md","raw":"---\ntitle: LLDB\ndate: 2017-01-05 13:10:18\n\ndescription: \n\ncategories: iOS\ntags: [Objective-C]\n---\n\n\n待续","slug":"LLDB","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3iy00064hfbyewjh5tn","content":"<p>待续</p>\n","site":{"data":{}},"excerpt":"","more":"<p>待续</p>\n"},{"title":"NStimer准确吗","date":"2017-12-14T05:15:48.000Z","description":"NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件。","toc":false,"_content":"\n### 基本使用\n\n```\n /*   \n  * TimeInterval:设定执行时间    \n  * target:目标    \n  * @selector:方法(也就是目标(target)的行为(selector))  \n  * userInfo:用于向selector方法中传参数,  一般是self\n  * repeats:是否重复\n  */\n  \nNSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:.3 target:self selector:@selector(changeColor:) userInfo:view repeats:YES];    \n[timer fire];//开始执行\n\n//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)\n- (void)changeColor:(NSTimer *)sender\n{    \n//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),\n对于此题上面穿的是一个view对象,所以直接用UIview类型接收   \n UIView * vie = sender.userInfo;   \n //修改传入视图的背景色   \n vie.backgroundColor = [UIColor colorWithRed:arc4random() % 256 / 255.0 green:arc4random() % 256 / 255.0 blue:arc4random() % 256 / 255.0 alpha:1.0];\n}\n\n```\n\nNSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：\n\n1. NSTimer被添加到特定mode的runloop中\n2. 该mode型的runloop正在运行\n3. 到达激发时间。\n\n所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。\n\n### 不准的原因\n\n1. NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。\n2. 模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。\n\n* 这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n### 解决NStimer不准的问题\n\n1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果\n\n```\n- (void)timerMethod2 {\n    \n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n    \n    [thread start];\n}\n\n- (void)newThread{\n    \n    @autoreleasepool\n    \n    {\n        \n        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n        \n        [[NSRunLoop currentRunLoop] run];\n    }\n}\n\n```\n\n2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。\n\n\n**注意：**\n\n* 一开始的时候系统就为我们将主线程的main runloop隐式的启动了。\n\n* 在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop\n","source":"_posts/NStimer准确吗.md","raw":"---\ntitle: NStimer准确吗\ndate: 2017-12-14 13:15:48\n\ndescription: NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件。\n\ncategories: [原理]\ntags: [Objective-C]\ntoc: false \n---\n\n### 基本使用\n\n```\n /*   \n  * TimeInterval:设定执行时间    \n  * target:目标    \n  * @selector:方法(也就是目标(target)的行为(selector))  \n  * userInfo:用于向selector方法中传参数,  一般是self\n  * repeats:是否重复\n  */\n  \nNSTimer * timer = [NSTimer scheduledTimerWithTimeInterval:.3 target:self selector:@selector(changeColor:) userInfo:view repeats:YES];    \n[timer fire];//开始执行\n\n//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)\n- (void)changeColor:(NSTimer *)sender\n{    \n//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),\n对于此题上面穿的是一个view对象,所以直接用UIview类型接收   \n UIView * vie = sender.userInfo;   \n //修改传入视图的背景色   \n vie.backgroundColor = [UIColor colorWithRed:arc4random() % 256 / 255.0 green:arc4random() % 256 / 255.0 blue:arc4random() % 256 / 255.0 alpha:1.0];\n}\n\n```\n\nNSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：\n\n1. NSTimer被添加到特定mode的runloop中\n2. 该mode型的runloop正在运行\n3. 到达激发时间。\n\n所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。\n\n### 不准的原因\n\n1. NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。\n2. 模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。\n\n* 这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n### 解决NStimer不准的问题\n\n1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果\n\n```\n- (void)timerMethod2 {\n    \n    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];\n    \n    [thread start];\n}\n\n- (void)newThread{\n    \n    @autoreleasepool\n    \n    {\n        \n        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];\n        \n        [[NSRunLoop currentRunLoop] run];\n    }\n}\n\n```\n\n2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰\n\n```\n[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];\n```\n\n[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。\n\n\n**注意：**\n\n* 一开始的时候系统就为我们将主线程的main runloop隐式的启动了。\n\n* 在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop\n","slug":"NStimer准确吗","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3j000074hfbujr7aben","content":"<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">  * TimeInterval:设定执行时间    </span></span><br><span class=\"line\"><span class=\"comment\">  * target:目标    </span></span><br><span class=\"line\"><span class=\"comment\">  * @selector:方法(也就是目标(target)的行为(selector))  </span></span><br><span class=\"line\"><span class=\"comment\">  * userInfo:用于向selector方法中传参数,  一般是self</span></span><br><span class=\"line\"><span class=\"comment\">  * repeats:是否重复</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  </span><br><span class=\"line\">NSTimer * timer = [NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">.3</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">changeColor:</span>) <span class=\"string\">userInfo:</span>view <span class=\"string\">repeats:</span>YES];    </span><br><span class=\"line\">[timer fire];<span class=\"comment\">//开始执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">changeColor:</span>(NSTimer *)sender</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\"><span class=\"comment\">//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),</span></span><br><span class=\"line\">对于此题上面穿的是一个view对象,所以直接用UIview类型接收   </span><br><span class=\"line\"> UIView * vie = sender.userInfo;   </span><br><span class=\"line\"> <span class=\"comment\">//修改传入视图的背景色   </span></span><br><span class=\"line\"> vie.backgroundColor = [UIColor <span class=\"string\">colorWithRed:</span>arc4random() % <span class=\"number\">256</span> <span class=\"regexp\">/ 255.0 green:arc4random() % 256 /</span> <span class=\"number\">255.0</span> <span class=\"string\">blue:</span>arc4random() % <span class=\"number\">256</span> / <span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：</p>\n<ol>\n<li>NSTimer被添加到特定mode的runloop中</li>\n<li>该mode型的runloop正在运行</li>\n<li>到达激发时间。</li>\n</ol>\n<p>所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。</p>\n<h3 id=\"不准的原因\"><a href=\"#不准的原因\" class=\"headerlink\" title=\"不准的原因\"></a>不准的原因</h3><ol>\n<li>NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</li>\n<li>模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</li>\n</ol>\n<ul>\n<li>这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</li>\n</ul>\n<h3 id=\"解决NStimer不准的问题\"><a href=\"#解决NStimer不准的问题\" class=\"headerlink\" title=\"解决NStimer不准的问题\"></a>解决NStimer不准的问题</h3><p>1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)timerMethod2 &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(newThread) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)newThread&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(showTime) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[[NSRunLoop currentRunLoop]</span> <span class=\"selector-tag\">addTimer</span><span class=\"selector-pseudo\">:self.timer</span> <span class=\"selector-tag\">forMode</span><span class=\"selector-pseudo\">:NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n<p>[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</p>\n</li>\n<li><p>在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*   </span></span><br><span class=\"line\"><span class=\"comment\">  * TimeInterval:设定执行时间    </span></span><br><span class=\"line\"><span class=\"comment\">  * target:目标    </span></span><br><span class=\"line\"><span class=\"comment\">  * @selector:方法(也就是目标(target)的行为(selector))  </span></span><br><span class=\"line\"><span class=\"comment\">  * userInfo:用于向selector方法中传参数,  一般是self</span></span><br><span class=\"line\"><span class=\"comment\">  * repeats:是否重复</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  </span><br><span class=\"line\">NSTimer * timer = [NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">.3</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">changeColor:</span>) <span class=\"string\">userInfo:</span>view <span class=\"string\">repeats:</span>YES];    </span><br><span class=\"line\">[timer fire];<span class=\"comment\">//开始执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计时器执行的方法,sender 就是对应的计时器(那个计时器调的我)</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">changeColor:</span>(NSTimer *)sender</span><br><span class=\"line\">&#123;    </span><br><span class=\"line\"><span class=\"comment\">//sender计时器对象,通过.userinfo属性就能拿到当初传来的参数(id类型),</span></span><br><span class=\"line\">对于此题上面穿的是一个view对象,所以直接用UIview类型接收   </span><br><span class=\"line\"> UIView * vie = sender.userInfo;   </span><br><span class=\"line\"> <span class=\"comment\">//修改传入视图的背景色   </span></span><br><span class=\"line\"> vie.backgroundColor = [UIColor <span class=\"string\">colorWithRed:</span>arc4random() % <span class=\"number\">256</span> <span class=\"regexp\">/ 255.0 green:arc4random() % 256 /</span> <span class=\"number\">255.0</span> <span class=\"string\">blue:</span>arc4random() % <span class=\"number\">256</span> / <span class=\"number\">255.0</span> <span class=\"string\">alpha:</span><span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSTimer 不是一个基于真实时间的机制。NSTimer被激发需要满足三个条件：</p>\n<ol>\n<li>NSTimer被添加到特定mode的runloop中</li>\n<li>该mode型的runloop正在运行</li>\n<li>到达激发时间。</li>\n</ol>\n<p>所以当上面1、2条出现问题时NSTimer就会受到影响，所以NSTimer是不准确的。</p>\n<h3 id=\"不准的原因\"><a href=\"#不准的原因\" class=\"headerlink\" title=\"不准的原因\"></a>不准的原因</h3><ol>\n<li>NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</li>\n<li>模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</li>\n</ol>\n<ul>\n<li>这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</li>\n</ul>\n<h3 id=\"解决NStimer不准的问题\"><a href=\"#解决NStimer不准的问题\" class=\"headerlink\" title=\"解决NStimer不准的问题\"></a>解决NStimer不准的问题</h3><p>1、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)timerMethod2 &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSThread</span> *thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(newThread) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)newThread&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(showTime) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、仍然在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中，避免被复杂运算操作或者UI界面刷新所干扰</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[[NSRunLoop currentRunLoop]</span> <span class=\"selector-tag\">addTimer</span><span class=\"selector-pseudo\">:self.timer</span> <span class=\"selector-tag\">forMode</span><span class=\"selector-pseudo\">:NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n<p>[NSRunLoop currentRunLoop] 获取的就是 main runloop，使用NSRunLoopCommonModes模式，将NSTimer加入其中。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</p>\n</li>\n<li><p>在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</p>\n</li>\n</ul>\n"},{"title":"RunLoop[转]","date":"2017-04-20T07:21:18.000Z","description":"RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。","toc":"ture","_content":"\nRunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。\n\n## RunLoop 的概念\n\n一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：\n\n```\nfunction loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n```\n所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 \"接受消息->等待->处理\" 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。\n\n## RunLoop 与线程的关系\n\n苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:\n\n```\n/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef loopsDic;\n/// 访问 loopsDic 时的锁\nstatic CFSpinLock_t loopsLock;\n  \n/// 获取一个 pthread 对应的 RunLoop。\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    OSSpinLockLock(&loopsLock);\n     \n    if (!loopsDic) {\n        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。\n        loopsDic = CFDictionaryCreateMutable();\n        CFRunLoopRef mainLoop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);\n    }\n     \n    /// 直接从 Dictionary 里获取。\n    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));\n     \n    if (!loop) {\n        /// 取不到时，创建一个\n        loop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, thread, loop);\n        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。\n        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);\n    }\n     \n    OSSpinLockUnLock(&loopsLock);\n    return loop;\n}\n  \nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n  \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n```\n\n线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。\n\n## RunLoop 对外的接口\n\n在 CoreFoundation 里面关于 RunLoop 有5个类:\n\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n* CFRunLoopObserverRef\n\n其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png)\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。\n\n**CFRunLoopSourceRef** 是事件产生的地方。Source有两个版本：Source0 和 Source1。\n\n* Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n* Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。\n\n**CFRunLoopTimerRef** 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。\n\n**CFRunLoopObserverRef** 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒\n    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop\n};\n```\n\n上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。\n\n## RunLoop 的 Mode\n\nCFRunLoopMode 和 CFRunLoop 的结构大致如下：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n  \nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n这里有个概念叫 \"CommonModes\"：一个 Mode 可以将自己标记为\"Common\"属性（通过将其 ModeName 添加到 RunLoop 的 \"commonModes\" 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 \"Common\" 标记的所有Mode里。\n\n应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为\"Common\"属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 \"commonModeItems\" 中。\"commonModeItems\" 被 RunLoop 自动更新到所有具有\"Common\"属性的 Mode 里去。\n\n## RunLoop 的内部逻辑\nRunLoop 内部的逻辑大致如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png)\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n## 苹果用 RunLoop 实现的功能\n\n首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:\n\n1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。\n2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。\n3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。\n4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。\n5. kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。\n\n当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：\n\n```\n{\n    /// 1. 通知Observers，即将进入RunLoop\n    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);\n    do {\n  \n        /// 2. 通知 Observers: 即将触发 Timer 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);\n        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 4. 触发 Source0 (非基于port的) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 6. 通知Observers，即将进入休眠\n        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);\n  \n        /// 7. sleep to wait msg.\n        mach_msg() -> mach_msg_trap();\n         \n  \n        /// 8. 通知Observers，线程被唤醒\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);\n  \n        /// 9. 如果是被Timer唤醒的，回调Timer\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);\n  \n        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block\n        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);\n  \n        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);\n  \n  \n    } while (...);\n  \n    /// 10. 通知Observers，即将退出RunLoop\n    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);\n}\n\n```\n\n### 自动释放池 AutoreleasePool\n\nApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。\n\n* 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n* 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n### 事件响应\n\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n### 手势识别\n\n当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n### 界面更新\n\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n### 定时器\n\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。\n\n如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。\n\nCADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。\n\n### PerformSelecter\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n### 关于GCD\n\n实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。\n\n当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 **__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()** 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n## 整理文章\n\n[深入理解RunLoop](http://www.cocoachina.com/ios/20150601/11970.html)","source":"_posts/RunLoop.md","raw":"---\ntitle: RunLoop[转]\ndate: 2017-4-20 15:21:18\n\ndescription: RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。\n\ncategories: [原理]\ntags: [Objective-C]\ntoc: ture \n---\n\nRunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。\n\n## RunLoop 的概念\n\n一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：\n\n```\nfunction loop() {\n    initialize();\n    do {\n        var message = get_next_message();\n        process_message(message);\n    } while (message != quit);\n}\n```\n所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 \"接受消息->等待->处理\" 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。\n\n## RunLoop 与线程的关系\n\n苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:\n\n```\n/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef\nstatic CFMutableDictionaryRef loopsDic;\n/// 访问 loopsDic 时的锁\nstatic CFSpinLock_t loopsLock;\n  \n/// 获取一个 pthread 对应的 RunLoop。\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    OSSpinLockLock(&loopsLock);\n     \n    if (!loopsDic) {\n        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。\n        loopsDic = CFDictionaryCreateMutable();\n        CFRunLoopRef mainLoop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);\n    }\n     \n    /// 直接从 Dictionary 里获取。\n    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));\n     \n    if (!loop) {\n        /// 取不到时，创建一个\n        loop = _CFRunLoopCreate();\n        CFDictionarySetValue(loopsDic, thread, loop);\n        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。\n        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);\n    }\n     \n    OSSpinLockUnLock(&loopsLock);\n    return loop;\n}\n  \nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n  \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n```\n\n线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。\n\n## RunLoop 对外的接口\n\n在 CoreFoundation 里面关于 RunLoop 有5个类:\n\n* CFRunLoopRef\n* CFRunLoopModeRef\n* CFRunLoopSourceRef\n* CFRunLoopTimerRef\n* CFRunLoopObserverRef\n\n其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png)\n\n一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。\n\n**CFRunLoopSourceRef** 是事件产生的地方。Source有两个版本：Source0 和 Source1。\n\n* Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。\n* Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。\n\n**CFRunLoopTimerRef** 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。\n\n**CFRunLoopObserverRef** 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：\n\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒\n    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop\n};\n```\n\n上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。\n\n## RunLoop 的 Mode\n\nCFRunLoopMode 和 CFRunLoop 的结构大致如下：\n\n```\nstruct __CFRunLoopMode {\n    CFStringRef _name;            // Mode Name, 例如 @\"kCFRunLoopDefaultMode\"\n    CFMutableSetRef _sources0;    // Set\n    CFMutableSetRef _sources1;    // Set\n    CFMutableArrayRef _observers; // Array\n    CFMutableArrayRef _timers;    // Array\n    ...\n};\n  \nstruct __CFRunLoop {\n    CFMutableSetRef _commonModes;     // Set\n    CFMutableSetRef _commonModeItems; // Set\n    CFRunLoopModeRef _currentMode;    // Current Runloop Mode\n    CFMutableSetRef _modes;           // Set\n    ...\n};\n```\n\n这里有个概念叫 \"CommonModes\"：一个 Mode 可以将自己标记为\"Common\"属性（通过将其 ModeName 添加到 RunLoop 的 \"commonModes\" 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 \"Common\" 标记的所有Mode里。\n\n应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为\"Common\"属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。\n\n有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 \"commonModeItems\" 中。\"commonModeItems\" 被 RunLoop 自动更新到所有具有\"Common\"属性的 Mode 里去。\n\n## RunLoop 的内部逻辑\nRunLoop 内部的逻辑大致如下:\n\n![](http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png)\n\n可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。\n\n## 苹果用 RunLoop 实现的功能\n\n首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:\n\n1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。\n2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。\n3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。\n4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。\n5. kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。\n\n当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：\n\n```\n{\n    /// 1. 通知Observers，即将进入RunLoop\n    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);\n    do {\n  \n        /// 2. 通知 Observers: 即将触发 Timer 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);\n        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 4. 触发 Source0 (非基于port的) 回调。\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);\n  \n        /// 6. 通知Observers，即将进入休眠\n        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);\n  \n        /// 7. sleep to wait msg.\n        mach_msg() -> mach_msg_trap();\n         \n  \n        /// 8. 通知Observers，线程被唤醒\n        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);\n  \n        /// 9. 如果是被Timer唤醒的，回调Timer\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);\n  \n        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block\n        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);\n  \n        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件\n        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);\n  \n  \n    } while (...);\n  \n    /// 10. 通知Observers，即将退出RunLoop\n    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();\n    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);\n}\n\n```\n\n### 自动释放池 AutoreleasePool\n\nApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。\n\n* 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。\n* 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。\n\n在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。\n\n### 事件响应\n\n苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。\n\n当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。\n\n_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。\n\n### 手势识别\n\n当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。\n\n苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。\n\n当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n### 界面更新\n\n当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。\n\n苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：\n\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n这个函数内部的调用栈大概是这样的：\n\n```\n_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()\n    QuartzCore:CA::Transaction::observer_callback:\n        CA::Transaction::commit();\n            CA::Context::commit_transaction();\n                CA::Layer::layout_and_display_if_needed();\n                    CA::Layer::layout_if_needed();\n                        [CALayer layoutSublayers];\n                            [UIView layoutSubviews];\n                    CA::Layer::display_if_needed();\n                        [CALayer display];\n                            [UIView drawRect];\n```\n\n### 定时器\n\nNSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。\n\n如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。\n\nCADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。\n\n### PerformSelecter\n\n当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。\n\n当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。\n\n### 关于GCD\n\n实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。\n\n当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 **__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()** 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。\n\n## 整理文章\n\n[深入理解RunLoop](http://www.cocoachina.com/ios/20150601/11970.html)","slug":"RunLoop","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3j6000b4hfbzipgfbvc","content":"<p>RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。</p>\n<h2 id=\"RunLoop-的概念\"><a href=\"#RunLoop-的概念\" class=\"headerlink\" title=\"RunLoop 的概念\"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = get_next_message();</span><br><span class=\"line\">        process_message(message);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>\n<h2 id=\"RunLoop-与线程的关系\"><a href=\"#RunLoop-与线程的关系\" class=\"headerlink\" title=\"RunLoop 与线程的关系\"></a>RunLoop 与线程的关系</h2><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> loopsDic;</span><br><span class=\"line\"><span class=\"comment\">/// 访问 loopsDic 时的锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFSpinLock_t</span> loopsLock;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    OSSpinLockLock(&amp;loopsLock);</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loopsDic) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class=\"line\">        loopsDic = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">/// 直接从 Dictionary 里获取。</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 取不到时，创建一个</span></span><br><span class=\"line\">        loop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class=\"line\">        <span class=\"comment\">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h2 id=\"RunLoop-对外的接口\"><a href=\"#RunLoop-对外的接口\" class=\"headerlink\" title=\"RunLoop 对外的接口\"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png\" alt=\"\"></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>\n<ul>\n<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>\n</ul>\n<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>\n<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>), <span class=\"comment\">// 即将进入Loop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>), <span class=\"comment\">// 即将处理 Timer</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 即将处理 Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>), <span class=\"comment\">// 刚从休眠中唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit          = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>), <span class=\"comment\">// 即将退出Loop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>\n<h2 id=\"RunLoop-的-Mode\"><a href=\"#RunLoop-的-Mode\" class=\"headerlink\" title=\"RunLoop 的 Mode\"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>\n<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>\n<h2 id=\"RunLoop-的内部逻辑\"><a href=\"#RunLoop-的内部逻辑\" class=\"headerlink\" title=\"RunLoop 的内部逻辑\"></a>RunLoop 的内部逻辑</h2><p>RunLoop 内部的逻辑大致如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png\" alt=\"\"></p>\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<h2 id=\"苹果用-RunLoop-实现的功能\"><a href=\"#苹果用-RunLoop-实现的功能\" class=\"headerlink\" title=\"苹果用 RunLoop 实现的功能\"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:</p>\n<ol>\n<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>\n<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>\n<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>\n</ol>\n<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    /// <span class=\"number\">1</span>. 通知Observers，即将进入RunLoop</span><br><span class=\"line\">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopEntry</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">2</span>. 通知 Observers: 即将触发 Timer 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeTimers</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        /// <span class=\"number\">3</span>. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeSources</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">4</span>. 触发 Source0 (非基于port的) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(<span class=\"name\">source0</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">6</span>. 通知Observers，即将进入休眠</span><br><span class=\"line\">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">; _objc_autoreleasePoolPush();</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">7</span>. sleep to wait msg.</span><br><span class=\"line\">        mach_msg() -&gt; mach_msg_trap()<span class=\"comment\">;</span></span><br><span class=\"line\">         </span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">8</span>. 通知Observers，线程被唤醒</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopAfterWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被Timer唤醒的，回调Timer</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(<span class=\"name\">timer</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class=\"line\">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class=\"name\">dispatched_block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(<span class=\"name\">source1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125; while (<span class=\"name\">...</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    /// <span class=\"number\">10</span>. 通知Observers，即将退出RunLoop</span><br><span class=\"line\">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopExit</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动释放池-AutoreleasePool\"><a href=\"#自动释放池-AutoreleasePool\" class=\"headerlink\" title=\"自动释放池 AutoreleasePool\"></a>自动释放池 AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<ul>\n<li>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li>\n<li>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>\n</ul>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>\n<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class=\"line\">    <span class=\"selector-tag\">QuartzCore</span><span class=\"selector-pseudo\">:CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::observer_callback</span>:</span><br><span class=\"line\">        <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::commit()</span>;</span><br><span class=\"line\">            <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Context</span><span class=\"selector-pseudo\">::commit_transaction()</span>;</span><br><span class=\"line\">                <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_and_display_if_needed()</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer layoutSublayers]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView layoutSubviews]</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::display_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer display]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView drawRect]</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>\n<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>\n<h3 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<h3 id=\"关于GCD\"><a href=\"#关于GCD\" class=\"headerlink\" title=\"关于GCD\"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>\n<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()</strong> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<h2 id=\"整理文章\"><a href=\"#整理文章\" class=\"headerlink\" title=\"整理文章\"></a>整理文章</h2><p><a href=\"http://www.cocoachina.com/ios/20150601/11970.html\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>RunLoop 是 iOS 开发中非常基础的一个概念，在开发中你自己可能很少用到，但它在你的项目中却无处不在，了解RunLoop对iOS编程有百利而无一害。</p>\n<h2 id=\"RunLoop-的概念\"><a href=\"#RunLoop-的概念\" class=\"headerlink\" title=\"RunLoop 的概念\"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    initialize();</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> message = get_next_message();</span><br><span class=\"line\">        process_message(message);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (message != quit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>\n<h2 id=\"RunLoop-与线程的关系\"><a href=\"#RunLoop-与线程的关系\" class=\"headerlink\" title=\"RunLoop 与线程的关系\"></a>RunLoop 与线程的关系</h2><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。这两个函数内部的逻辑大概是下面这样:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> loopsDic;</span><br><span class=\"line\"><span class=\"comment\">/// 访问 loopsDic 时的锁</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFSpinLock_t</span> loopsLock;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    OSSpinLockLock(&amp;loopsLock);</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loopsDic) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class=\"line\">        loopsDic = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"comment\">/// 直接从 Dictionary 里获取。</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// 取不到时，创建一个</span></span><br><span class=\"line\">        loop = _CFRunLoopCreate();</span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class=\"line\">        <span class=\"comment\">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class=\"line\">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>\n<h2 id=\"RunLoop-对外的接口\"><a href=\"#RunLoop-对外的接口\" class=\"headerlink\" title=\"RunLoop 对外的接口\"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>\n<ul>\n<li>CFRunLoopRef</li>\n<li>CFRunLoopModeRef</li>\n<li>CFRunLoopSourceRef</li>\n<li>CFRunLoopTimerRef</li>\n<li>CFRunLoopObserverRef</li>\n</ul>\n<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png\" alt=\"\"></p>\n<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>\n<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>\n<ul>\n<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>\n<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>\n</ul>\n<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>\n<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>), <span class=\"comment\">// 即将进入Loop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>), <span class=\"comment\">// 即将处理 Timer</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 即将处理 Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>), <span class=\"comment\">// 刚从休眠中唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit          = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>), <span class=\"comment\">// 即将退出Loop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>\n<h2 id=\"RunLoop-的-Mode\"><a href=\"#RunLoop-的-Mode\" class=\"headerlink\" title=\"RunLoop 的 Mode\"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;            <span class=\"comment\">// Mode Name, 例如 @\"kCFRunLoopDefaultMode\"</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1;    <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers;    <span class=\"comment\">// Array</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;     <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// Set</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode;    <span class=\"comment\">// Current Runloop Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;           <span class=\"comment\">// Set</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>\n<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>\n<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>\n<h2 id=\"RunLoop-的内部逻辑\"><a href=\"#RunLoop-的内部逻辑\" class=\"headerlink\" title=\"RunLoop 的内部逻辑\"></a>RunLoop 的内部逻辑</h2><p>RunLoop 内部的逻辑大致如下:</p>\n<p><img src=\"http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png\" alt=\"\"></p>\n<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>\n<h2 id=\"苹果用-RunLoop-实现的功能\"><a href=\"#苹果用-RunLoop-实现的功能\" class=\"headerlink\" title=\"苹果用 RunLoop 实现的功能\"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态，可以看到，系统默认注册了5个Mode:</p>\n<ol>\n<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>\n<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>\n<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>\n</ol>\n<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    /// <span class=\"number\">1</span>. 通知Observers，即将进入RunLoop</span><br><span class=\"line\">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopEntry</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">2</span>. 通知 Observers: 即将触发 Timer 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeTimers</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        /// <span class=\"number\">3</span>. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeSources</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">4</span>. 触发 Source0 (非基于port的) 回调。</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(<span class=\"name\">source0</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(<span class=\"name\">block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">6</span>. 通知Observers，即将进入休眠</span><br><span class=\"line\">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">; _objc_autoreleasePoolPush();</span></span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopBeforeWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">7</span>. sleep to wait msg.</span><br><span class=\"line\">        mach_msg() -&gt; mach_msg_trap()<span class=\"comment\">;</span></span><br><span class=\"line\">         </span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">8</span>. 通知Observers，线程被唤醒</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopAfterWaiting</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被Timer唤醒的，回调Timer</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(<span class=\"name\">timer</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class=\"line\">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(<span class=\"name\">dispatched_block</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">        /// <span class=\"number\">9</span>. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class=\"line\">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(<span class=\"name\">source1</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125; while (<span class=\"name\">...</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    /// <span class=\"number\">10</span>. 通知Observers，即将退出RunLoop</span><br><span class=\"line\">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop()<span class=\"comment\">;</span></span><br><span class=\"line\">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(<span class=\"name\">kCFRunLoopExit</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动释放池-AutoreleasePool\"><a href=\"#自动释放池-AutoreleasePool\" class=\"headerlink\" title=\"自动释放池 AutoreleasePool\"></a>自动释放池 AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>\n<ul>\n<li>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li>\n<li>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>\n</ul>\n<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>\n<h3 id=\"事件响应\"><a href=\"#事件响应\" class=\"headerlink\" title=\"事件响应\"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>\n<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>\n<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>\n<h3 id=\"手势识别\"><a href=\"#手势识别\" class=\"headerlink\" title=\"手势识别\"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>\n<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>\n<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n<h3 id=\"界面更新\"><a href=\"#界面更新\" class=\"headerlink\" title=\"界面更新\"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>\n<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>\n<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n<p>这个函数内部的调用栈大概是这样的：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class=\"line\">    <span class=\"selector-tag\">QuartzCore</span><span class=\"selector-pseudo\">:CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::observer_callback</span>:</span><br><span class=\"line\">        <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Transaction</span><span class=\"selector-pseudo\">::commit()</span>;</span><br><span class=\"line\">            <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Context</span><span class=\"selector-pseudo\">::commit_transaction()</span>;</span><br><span class=\"line\">                <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_and_display_if_needed()</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::layout_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer layoutSublayers]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView layoutSubviews]</span>;</span><br><span class=\"line\">                    <span class=\"selector-tag\">CA</span><span class=\"selector-pseudo\">::Layer</span><span class=\"selector-pseudo\">::display_if_needed()</span>;</span><br><span class=\"line\">                        <span class=\"selector-attr\">[CALayer display]</span>;</span><br><span class=\"line\">                            <span class=\"selector-attr\">[UIView drawRect]</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>\n<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>\n<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>\n<h3 id=\"PerformSelecter\"><a href=\"#PerformSelecter\" class=\"headerlink\" title=\"PerformSelecter\"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>\n<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>\n<h3 id=\"关于GCD\"><a href=\"#关于GCD\" class=\"headerlink\" title=\"关于GCD\"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>\n<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>()</strong> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>\n<h2 id=\"整理文章\"><a href=\"#整理文章\" class=\"headerlink\" title=\"整理文章\"></a>整理文章</h2><p><a href=\"http://www.cocoachina.com/ios/20150601/11970.html\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a></p>\n"},{"title":"Runtime和消息转发","date":"2017-02-14T03:20:28.000Z","description":"之前有学习过Runtime相关知识，但是都是比较零散的积累，有了自己的博客，那就是时候系统的整理学习Runtime的相关知识了。","_content":"\n# 什么是Runtime\n\n* Runtime简称运行时。OC就是运行时机制，其中最主要的是`消息机制`。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数。\n* 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。\n* Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。\n\n## 消息机制（方法调用的本质）\n* 方法调用的本质，就是让对象发送消息。\n* OC中所有方法的调用都会转化为objc_msgSend来实现。\n\n### SEL\n其定义如下\n\n```\ntypedef struct objc_selector *SEL；     \n```\n\nSEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。\n\n### IMP\n\nIMP实际上是一个函数指针，指向方法实现的地址。\n其定义如下:\n\n```\nid (*IMP)(id, SEL,...)\n```\n\n第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)\n\n第二个参数：是方法选择器(selector)\n\n接下来的参数：方法的参数列表。\n\n### Method\n\nMethod方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：\n\n```\ntypedef struct objc_method *Method\n    struct objc_method{\n        SEL method_name      OBJC2_UNAVAILABLE; // 方法名\n        char *method_types   OBJC2_UNAVAILABLE;\n        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现\n    }\n```\n可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。\n\n**原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法**\n\n![](/img/消息机制.png)\n\n\n下面演示了这样一个消息的基本框架：\n当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。\n如果找到，执行该方法,如未找到继续执行下面的步骤\n\nobjc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。\n如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。\n依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 \n\n## 消息转发\n\n\n### 1、动态方法解析\n\n\n如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用`class_addMethod`函数动态提供相对于的方法实现\n\n```\n/** 如果调用的是实例方法，则会调用该方法 */\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n\n/** 如果调用的是类方法，则会调用该方法 */\n+ (BOOL)resolveClassMethod:(SEL)sel;\n\n```\n\n下面举一个例子：\n\n1. 创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的\n2. 进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（[这里](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)会详细讲解Runtime动态添加方法）\n\n当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）\n\n```\nvoid eat(id self, SEL _cmd, NSString *string){\n    NSLog(@\"add C IMP %@\", string);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    if (sel == @selector(eat)) {\n\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n### 2、消息转发\n\n* 如果不对上面的`resolveInstanceMethod`方法做任何处理，直接调用父类方法，那么，系统会来到了`forwardingTargetForSelector`方法\n\n\n```\n/** 这个方法返回你需要转发消息的对象 */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n\n```\n\n\n接着上面的例子：\n\n1. 不对`resolveInstanceMethod`进行处理，直接调用父类方法。\n2. 新建了一个熊猫类Panda，并且实现了Panda的eat方法。\n\n``` \n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector;{\n    return [[Panda alloc]init];\n}\n```\n\n\n当程序来到`forwardingTargetForSelector`方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。\n\n\n* 如果`forwardingTargetForSelector`方法也不实现的话，那么程序会进入下面两个函数\n\n\n\n```\n/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;\n\n/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n\nunrecognized selector sent to instance这个错误的原因，就是因为`methodSignatureForSelector`这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。\n\n所以我们需要做的是自己新建方法签名，再在`forwardInvocation`中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。\n\n\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    NSString *sel = NSStringFromSelector(aSelector);\n    \n    if ([sel isEqualToString:@\"eat\"]) {\n        \n        /** 为你的转发发放手动生成签名 */\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n    }\n\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    SEL selector = [anInvocation selector];\n    \n    /** 新建需要转发消息的对象 */\n    Panda *panda = [[Panda alloc]init];\n   \n    if ([panda respondsToSelector:selector]) {\n        \n        /** 唤醒这个方法 */\n        [anInvocation invokeWithTarget:panda];\n    }\n}\n\n```\n\n\n### Runtime文章链接\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n","source":"_posts/Runtime.md","raw":"---\ntitle: Runtime和消息转发\ndate: 2017-02-14 11:20:28\n\ndescription: 之前有学习过Runtime相关知识，但是都是比较零散的积累，有了自己的博客，那就是时候系统的整理学习Runtime的相关知识了。\n\ncategories: 原理\ntags: [Objective-C,Runtime]\n---\n\n# 什么是Runtime\n\n* Runtime简称运行时。OC就是运行时机制，其中最主要的是`消息机制`。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数。\n* 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。\n* Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。\n\n## 消息机制（方法调用的本质）\n* 方法调用的本质，就是让对象发送消息。\n* OC中所有方法的调用都会转化为objc_msgSend来实现。\n\n### SEL\n其定义如下\n\n```\ntypedef struct objc_selector *SEL；     \n```\n\nSEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。\n\n### IMP\n\nIMP实际上是一个函数指针，指向方法实现的地址。\n其定义如下:\n\n```\nid (*IMP)(id, SEL,...)\n```\n\n第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)\n\n第二个参数：是方法选择器(selector)\n\n接下来的参数：方法的参数列表。\n\n### Method\n\nMethod方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：\n\n```\ntypedef struct objc_method *Method\n    struct objc_method{\n        SEL method_name      OBJC2_UNAVAILABLE; // 方法名\n        char *method_types   OBJC2_UNAVAILABLE;\n        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现\n    }\n```\n可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。\n\n**原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法**\n\n![](/img/消息机制.png)\n\n\n下面演示了这样一个消息的基本框架：\n当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。\n如果找到，执行该方法,如未找到继续执行下面的步骤\n\nobjc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。\n如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。\n依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 \n\n## 消息转发\n\n\n### 1、动态方法解析\n\n\n如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用`class_addMethod`函数动态提供相对于的方法实现\n\n```\n/** 如果调用的是实例方法，则会调用该方法 */\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n\n/** 如果调用的是类方法，则会调用该方法 */\n+ (BOOL)resolveClassMethod:(SEL)sel;\n\n```\n\n下面举一个例子：\n\n1. 创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的\n2. 进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（[这里](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)会详细讲解Runtime动态添加方法）\n\n当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）\n\n```\nvoid eat(id self, SEL _cmd, NSString *string){\n    NSLog(@\"add C IMP %@\", string);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    if (sel == @selector(eat)) {\n\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n### 2、消息转发\n\n* 如果不对上面的`resolveInstanceMethod`方法做任何处理，直接调用父类方法，那么，系统会来到了`forwardingTargetForSelector`方法\n\n\n```\n/** 这个方法返回你需要转发消息的对象 */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n\n```\n\n\n接着上面的例子：\n\n1. 不对`resolveInstanceMethod`进行处理，直接调用父类方法。\n2. 新建了一个熊猫类Panda，并且实现了Panda的eat方法。\n\n``` \n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector;{\n    return [[Panda alloc]init];\n}\n```\n\n\n当程序来到`forwardingTargetForSelector`方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。\n\n\n* 如果`forwardingTargetForSelector`方法也不实现的话，那么程序会进入下面两个函数\n\n\n\n```\n/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;\n\n/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n\n\nunrecognized selector sent to instance这个错误的原因，就是因为`methodSignatureForSelector`这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。\n\n所以我们需要做的是自己新建方法签名，再在`forwardInvocation`中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。\n\n\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{\n    \n    NSString *sel = NSStringFromSelector(aSelector);\n    \n    if ([sel isEqualToString:@\"eat\"]) {\n        \n        /** 为你的转发发放手动生成签名 */\n        return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];\n    }\n\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation{\n    \n    SEL selector = [anInvocation selector];\n    \n    /** 新建需要转发消息的对象 */\n    Panda *panda = [[Panda alloc]init];\n   \n    if ([panda respondsToSelector:selector]) {\n        \n        /** 唤醒这个方法 */\n        [anInvocation invokeWithTarget:panda];\n    }\n}\n\n```\n\n\n### Runtime文章链接\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n","slug":"Runtime","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3ja000d4hfb04yz0x5y","content":"<h1 id=\"什么是Runtime\"><a href=\"#什么是Runtime\" class=\"headerlink\" title=\"什么是Runtime\"></a>什么是Runtime</h1><ul>\n<li>Runtime简称运行时。OC就是运行时机制，其中最主要的是<code>消息机制</code>。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数。</li>\n<li>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>\n<li>Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。</li>\n</ul>\n<h2 id=\"消息机制（方法调用的本质）\"><a href=\"#消息机制（方法调用的本质）\" class=\"headerlink\" title=\"消息机制（方法调用的本质）\"></a>消息机制（方法调用的本质）</h2><ul>\n<li>方法调用的本质，就是让对象发送消息。</li>\n<li>OC中所有方法的调用都会转化为objc_msgSend来实现。</li>\n</ul>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p>其定义如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>；</span></span><br></pre></td></tr></table></figure>\n<p>SEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。</p>\n<h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id (<span class=\"name\">*IMP</span>)(<span class=\"name\">id</span>, SEL,...)</span><br></pre></td></tr></table></figure>\n<p>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)</p>\n<p>第二个参数：是方法选择器(selector)</p>\n<p>接下来的参数：方法的参数列表。</p>\n<h3 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h3><p>Method方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *<span class=\"function\"><span class=\"keyword\">Method</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">struct</span> <span class=\"title\">objc_method</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        char *method_types   OBJC2_UNAVAILABLE;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    &#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>\n<p><strong>原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法</strong></p>\n<p><img src=\"/img/消息机制.png\" alt=\"\"></p>\n<p>下面演示了这样一个消息的基本框架：<br>当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。<br>如果找到，执行该方法,如未找到继续执行下面的步骤</p>\n<p>objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。<br>如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。<br>依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 </p>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><h3 id=\"1、动态方法解析\"><a href=\"#1、动态方法解析\" class=\"headerlink\" title=\"1、动态方法解析\"></a>1、动态方法解析</h3><p>如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用<code>class_addMethod</code>函数动态提供相对于的方法实现</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 如果调用的是实例方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 如果调用的是类方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveClassMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure>\n<p>下面举一个例子：</p>\n<ol>\n<li>创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的</li>\n<li>进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（<a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">这里</a>会详细讲解Runtime动态添加方法）</li>\n</ol>\n<p>当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">eat</span>(id self, SEL _cmd, NSString *string)&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">NSLog</span>(@<span class=\"string\">\"add C IMP %@\"</span>, string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (sel == <span class=\"variable\">@selector</span>(eat)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">class_addMethod</span>(self, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super resolveInstanceMethod:sel]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、消息转发\"><a href=\"#2、消息转发\" class=\"headerlink\" title=\"2、消息转发\"></a>2、消息转发</h3><ul>\n<li>如果不对上面的<code>resolveInstanceMethod</code>方法做任何处理，直接调用父类方法，那么，系统会来到了<code>forwardingTargetForSelector</code>方法</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法返回你需要转发消息的对象 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (id)<span class=\"selector-tag\">forwardingTargetForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br></pre></td></tr></table></figure>\n<p>接着上面的例子：</p>\n<ol>\n<li>不对<code>resolveInstanceMethod</code>进行处理，直接调用父类方法。</li>\n<li>新建了一个熊猫类Panda，并且实现了Panda的eat方法。</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)<span class=\"string\">resolveInstanceMethod:</span>(SEL)sel&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> <span class=\"string\">resolveInstanceMethod:</span>sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)<span class=\"string\">forwardingTargetForSelector:</span>(SEL)aSelector;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[Panda alloc]init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序来到<code>forwardingTargetForSelector</code>方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。</p>\n<ul>\n<li>如果<code>forwardingTargetForSelector</code>方法也不实现的话，那么程序会进入下面两个函数</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSMethodSignature *)<span class=\"selector-tag\">methodSignatureForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">forwardInvocation</span><span class=\"selector-pseudo\">:(NSInvocation</span> *)<span class=\"selector-tag\">anInvocation</span>;</span><br></pre></td></tr></table></figure>\n<p>unrecognized selector sent to instance这个错误的原因，就是因为<code>methodSignatureForSelector</code>这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。</p>\n<p>所以我们需要做的是自己新建方法签名，再在<code>forwardInvocation</code>中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *sel = <span class=\"built_in\">NSStringFromSelector</span>(aSelector);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sel isEqualToString:<span class=\"string\">@\"eat\"</span>]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 为你的转发发放手动生成签名 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SEL selector = [anInvocation selector];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 新建需要转发消息的对象 */</span></span><br><span class=\"line\">    Panda *panda = [[Panda alloc]init];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([panda respondsToSelector:selector]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 唤醒这个方法 */</span></span><br><span class=\"line\">        [anInvocation invokeWithTarget:panda];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Runtime文章链接\"><a href=\"#Runtime文章链接\" class=\"headerlink\" title=\"Runtime文章链接\"></a>Runtime文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是Runtime\"><a href=\"#什么是Runtime\" class=\"headerlink\" title=\"什么是Runtime\"></a>什么是Runtime</h1><ul>\n<li>Runtime简称运行时。OC就是运行时机制，其中最主要的是<code>消息机制</code>。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数。</li>\n<li>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>\n<li>Runtime基本上是用C汇编写的，这个库使得C语言有了面向对象的能力。</li>\n</ul>\n<h2 id=\"消息机制（方法调用的本质）\"><a href=\"#消息机制（方法调用的本质）\" class=\"headerlink\" title=\"消息机制（方法调用的本质）\"></a>消息机制（方法调用的本质）</h2><ul>\n<li>方法调用的本质，就是让对象发送消息。</li>\n<li>OC中所有方法的调用都会转化为objc_msgSend来实现。</li>\n</ul>\n<h3 id=\"SEL\"><a href=\"#SEL\" class=\"headerlink\" title=\"SEL\"></a>SEL</h3><p>其定义如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_selector</span> *<span class=\"title\">SEL</span>；</span></span><br></pre></td></tr></table></figure>\n<p>SEL又叫选择器，类成员方法的指针，但不同于C语言中的函数指针，函数指针直接保存了方法的地址，但SEL只是方法编号。</p>\n<h3 id=\"IMP\"><a href=\"#IMP\" class=\"headerlink\" title=\"IMP\"></a>IMP</h3><p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id (<span class=\"name\">*IMP</span>)(<span class=\"name\">id</span>, SEL,...)</span><br></pre></td></tr></table></figure>\n<p>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)</p>\n<p>第二个参数：是方法选择器(selector)</p>\n<p>接下来的参数：方法的参数列表。</p>\n<h3 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h3><p>Method方法的结构体，其中保存了方法的名字，实现和类型描述字符串，则定义如下：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *<span class=\"function\"><span class=\"keyword\">Method</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">struct</span> <span class=\"title\">objc_method</span><span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        char *method_types   OBJC2_UNAVAILABLE;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">        IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">    &#125;</span></span></span><br></pre></td></tr></table></figure>\n<p>可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>\n<p><strong>原理：对象根据方法编号SEL去Dispath table表（映射表）寻找到对应的IMP，IMP就是一个函数指针，然后执行这个方法</strong></p>\n<p><img src=\"/img/消息机制.png\" alt=\"\"></p>\n<p>下面演示了这样一个消息的基本框架：<br>当消息发送给一个对象时首先从运行时系统缓存使用过的方法中寻找。<br>如果找到，执行该方法,如未找到继续执行下面的步骤</p>\n<p>objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。<br>如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。<br>依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。 </p>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><h3 id=\"1、动态方法解析\"><a href=\"#1、动态方法解析\" class=\"headerlink\" title=\"1、动态方法解析\"></a>1、动态方法解析</h3><p>如果在上述索引未能成功，则首先会转入动态方法解析，该过程允许我们使用<code>class_addMethod</code>函数动态提供相对于的方法实现</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 如果调用的是实例方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 如果调用的是类方法，则会调用该方法 */</span></span><br><span class=\"line\">+ (<span class=\"selector-tag\">BOOL</span>)<span class=\"selector-tag\">resolveClassMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>;</span><br></pre></td></tr></table></figure>\n<p>下面举一个例子：</p>\n<ol>\n<li>创建了一个Animal类的对象an，然后调用an的eat方法，注意，这个eat方法是没有实现的</li>\n<li>进入Animal类的.m文件，我们实现了resolveInstanceMethod这个方法为我的Animal类动态增加了一个eat方法的实现。（<a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">这里</a>会详细讲解Runtime动态添加方法）</li>\n</ol>\n<p>当外部调用[an eat]时，由于我们没有实现eat对应的方法，那么系统会调用resolveInstanceMethod让你去做一些其他操作。（也可以不做操作，如果不操作会进入下一步消息转发，在这个例子中，我为Animal方法动态增加了实现。）</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">eat</span>(id self, SEL _cmd, NSString *string)&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">NSLog</span>(@<span class=\"string\">\"add C IMP %@\"</span>, string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span>&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (sel == <span class=\"variable\">@selector</span>(eat)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">class_addMethod</span>(self, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super resolveInstanceMethod:sel]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2、消息转发\"><a href=\"#2、消息转发\" class=\"headerlink\" title=\"2、消息转发\"></a>2、消息转发</h3><ul>\n<li>如果不对上面的<code>resolveInstanceMethod</code>方法做任何处理，直接调用父类方法，那么，系统会来到了<code>forwardingTargetForSelector</code>方法</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法返回你需要转发消息的对象 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (id)<span class=\"selector-tag\">forwardingTargetForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br></pre></td></tr></table></figure>\n<p>接着上面的例子：</p>\n<ol>\n<li>不对<code>resolveInstanceMethod</code>进行处理，直接调用父类方法。</li>\n<li>新建了一个熊猫类Panda，并且实现了Panda的eat方法。</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (BOOL)<span class=\"string\">resolveInstanceMethod:</span>(SEL)sel&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> <span class=\"string\">resolveInstanceMethod:</span>sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)<span class=\"string\">forwardingTargetForSelector:</span>(SEL)aSelector;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[Panda alloc]init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序来到<code>forwardingTargetForSelector</code>方法时，我们现在返回一个Panda类的实例对象，继续运行，程序就来到了Panda类的eat方法，这样，就实现了消息转发。</p>\n<ul>\n<li>如果<code>forwardingTargetForSelector</code>方法也不实现的话，那么程序会进入下面两个函数</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个方法是用来生成方法签名的，这个签名就是给forwardInvocation中的参数NSInvocation调用的 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSMethodSignature *)<span class=\"selector-tag\">methodSignatureForSelector</span><span class=\"selector-pseudo\">:(SEL)aSelector</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 在这个方法中用你要转发的那个对象调用这个对应的签名 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">forwardInvocation</span><span class=\"selector-pseudo\">:(NSInvocation</span> *)<span class=\"selector-tag\">anInvocation</span>;</span><br></pre></td></tr></table></figure>\n<p>unrecognized selector sent to instance这个错误的原因，就是因为<code>methodSignatureForSelector</code>这个方法中，由于没有找到eat对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。</p>\n<p>所以我们需要做的是自己新建方法签名，再在<code>forwardInvocation</code>中用你要转发的那个对象调用这个对应的签名，这样也实现了消息转发。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *sel = <span class=\"built_in\">NSStringFromSelector</span>(aSelector);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([sel isEqualToString:<span class=\"string\">@\"eat\"</span>]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 为你的转发发放手动生成签名 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">\"v@:\"</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SEL selector = [anInvocation selector];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 新建需要转发消息的对象 */</span></span><br><span class=\"line\">    Panda *panda = [[Panda alloc]init];</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([panda respondsToSelector:selector]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/** 唤醒这个方法 */</span></span><br><span class=\"line\">        [anInvocation invokeWithTarget:panda];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Runtime文章链接\"><a href=\"#Runtime文章链接\" class=\"headerlink\" title=\"Runtime文章链接\"></a>Runtime文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n"},{"title":"Runtime之动态添加属性","date":"2017-02-20T11:17:18.000Z","description":"为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。","toc":false,"_content":"\n为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。\n\n动态添加方法在后面也会单独写一篇博文。\n\n## 给分类添加属性\n\n* 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。\n\n\n对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：\n\n\n```\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n\n参数1：object 是源对象\n\n参数2：value 是被关联的对象\n\n参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象\n\n参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.\n\n```\n/** 这个也可以取消关联 */\nvoid objc_removeAssociatedObjects(id object)\n```\n\n### 应用情景\n\n* 给NSObject类添加一个name属性\n* 给UIButton或UIView添加一个单击事件回调属性\n* 给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性\n\n下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：\n\n创建一个UIButton的分类\n\n在.h文件：\n\n```\n#import <UIKit/UIKit.h>\n\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (block)\n\n/*\n * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的\n * 实现以及带下划线的成员变量.\n * 所以, 在分类中有两种方式声明一个属性\n */\n\n/** 第一种写法 */\n@property (nonatomic,copy) clickBlock click;\n\n/** 第二种写法 */\n//@property clickBlock click;\n\n@end\n```\n在.m文件：\n\n```\n#import \"UIButton+block.h\"\n#import <objc/runtime.h>\n\n/** 定义关联的key */\nstatic const void *clickKey = \"click\";\n\n@implementation UIButton (block)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    \n    /* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联\n     参数1: id object :表示给哪个对象添加关联\n     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名\n     参数3: id value : 属性值\n     参数4: 策略, 是个枚举(点进去,解释很详细)\n     \n     单词Associated 关联\n     */\n    objc_setAssociatedObject(self, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return objc_getAssociatedObject(self, clickKey);\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n\n```\n\n这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性\n\n使用：\n\n```\nUIButton *button = [[UIButton alloc] init];\n    \nbutton.frame = self.view.bounds;\n    \n[self.view addSubview:button];\n    \nbutton.click = ^{\n    \n    NSLog(@\"点击了button\");\n    \n};\n```\n\n## 疑难杂症\n为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的`clickBlockXP _clickXp;`也可以达到相同的效果，为什么不能那样做呢\n\n就像这样：\n\n```\n#import \"UIButton+block.h\"\n\ntypedef void(^clickBlockXP)(void);\n\n/** 定义的全局block */\nclickBlockXP _clickXp;\n\n@implementation UIButton (block)\n\n-(void)setClick:(clickBlock)click{\n    \n    _clickXp = click;\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return _clickXp;\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n```\n\n**不能这样做的原因**：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。\n\n\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n\n[Runtime全方位装逼指南](http://www.cocoachina.com/ios/20160523/16386.html)\n\n[runtime简单使用之动态添加属性](https://www.jianshu.com/p/e52c17db0aa9)","source":"_posts/Runtime之动态添加属性.md","raw":"---\ntitle: Runtime之动态添加属性\ndate: 2017-02-20 19:17:18\n\ndescription: 为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。\n\ncategories: 原理\ntags: [Objective-C,Runtime]\ntoc: false \n---\n\n为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。\n\n动态添加方法在后面也会单独写一篇博文。\n\n## 给分类添加属性\n\n* 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。\n\n\n对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：\n\n\n```\nOBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);\n```\n\n参数1：object 是源对象\n\n参数2：value 是被关联的对象\n\n参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象\n\n参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义\n\n要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.\n\n```\n/** 这个也可以取消关联 */\nvoid objc_removeAssociatedObjects(id object)\n```\n\n### 应用情景\n\n* 给NSObject类添加一个name属性\n* 给UIButton或UIView添加一个单击事件回调属性\n* 给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性\n\n下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：\n\n创建一个UIButton的分类\n\n在.h文件：\n\n```\n#import <UIKit/UIKit.h>\n\ntypedef void(^clickBlock)(void);\n\n@interface UIButton (block)\n\n/*\n * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的\n * 实现以及带下划线的成员变量.\n * 所以, 在分类中有两种方式声明一个属性\n */\n\n/** 第一种写法 */\n@property (nonatomic,copy) clickBlock click;\n\n/** 第二种写法 */\n//@property clickBlock click;\n\n@end\n```\n在.m文件：\n\n```\n#import \"UIButton+block.h\"\n#import <objc/runtime.h>\n\n/** 定义关联的key */\nstatic const void *clickKey = \"click\";\n\n@implementation UIButton (block)\n\n//Category中的属性，只会生成setter和getter方法，不会生成成员变量\n\n-(void)setClick:(clickBlock)click{\n    \n    /* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联\n     参数1: id object :表示给哪个对象添加关联\n     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名\n     参数3: id value : 属性值\n     参数4: 策略, 是个枚举(点进去,解释很详细)\n     \n     单词Associated 关联\n     */\n    objc_setAssociatedObject(self, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return objc_getAssociatedObject(self, clickKey);\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n\n@end\n\n```\n\n这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性\n\n使用：\n\n```\nUIButton *button = [[UIButton alloc] init];\n    \nbutton.frame = self.view.bounds;\n    \n[self.view addSubview:button];\n    \nbutton.click = ^{\n    \n    NSLog(@\"点击了button\");\n    \n};\n```\n\n## 疑难杂症\n为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的`clickBlockXP _clickXp;`也可以达到相同的效果，为什么不能那样做呢\n\n就像这样：\n\n```\n#import \"UIButton+block.h\"\n\ntypedef void(^clickBlockXP)(void);\n\n/** 定义的全局block */\nclickBlockXP _clickXp;\n\n@implementation UIButton (block)\n\n-(void)setClick:(clickBlock)click{\n    \n    _clickXp = click;\n    \n    [self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    \n    if (click) {\n        [self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (clickBlock)click{\n    return _clickXp;\n}\n\n- (void)buttonClick{\n    if (self.click) {\n        self.click();\n    }\n}\n```\n\n**不能这样做的原因**：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。\n\n\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加方法](https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/)\n\n[Runtime全方位装逼指南](http://www.cocoachina.com/ios/20160523/16386.html)\n\n[runtime简单使用之动态添加属性](https://www.jianshu.com/p/e52c17db0aa9)","slug":"Runtime之动态添加属性","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3je000i4hfbpx7heewa","content":"<p>为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。</p>\n<p>动态添加方法在后面也会单独写一篇博文。</p>\n<h2 id=\"给分类添加属性\"><a href=\"#给分类添加属性\" class=\"headerlink\" title=\"给分类添加属性\"></a>给分类添加属性</h2><ul>\n<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>\n</ul>\n<p>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">OBJC_EXPORT <span class=\"keyword\">void</span> <span class=\"title\">objc_setAssociatedObject</span>(<span class=\"params\">id <span class=\"keyword\">object</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, id <span class=\"keyword\">value</span>, objc_AssociationPolicy policy</span>) __<span class=\"title\">OSX_AVAILABLE_STARTING</span>(<span class=\"params\">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>参数1：object 是源对象</p>\n<p>参数2：value 是被关联的对象</p>\n<p>参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象</p>\n<p>参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义</p>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个也可以取消关联 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc<span class=\"number\">_</span>removeAssociatedObjects(id <span class=\"keyword\">object</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"应用情景\"><a href=\"#应用情景\" class=\"headerlink\" title=\"应用情景\"></a>应用情景</h3><ul>\n<li>给NSObject类添加一个name属性</li>\n<li>给UIButton或UIView添加一个单击事件回调属性</li>\n<li>给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性</li>\n</ul>\n<p>下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：</p>\n<p>创建一个UIButton的分类</p>\n<p>在.h文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现以及带下划线的成员变量.</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以, 在分类中有两种方式声明一个属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第一种写法 */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第二种写法 */</span></span><br><span class=\"line\"><span class=\"comment\">//@property clickBlock click;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在.m文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义关联的key */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *clickKey = <span class=\"string\">\"click\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数1: id object :表示给哪个对象添加关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     参数3: id value : 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     参数4: 策略, 是个枚举(点进去,解释很详细)</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     单词Associated 关联</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, clickKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性</p>\n<p>使用：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *<span class=\"keyword\">button </span>= [[UIButton alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">button.frame </span>= self.view.<span class=\"keyword\">bounds;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\">[self.view <span class=\"keyword\">addSubview:button];</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\"><span class=\"keyword\">button.click </span>= ^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"点击了button\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><p>为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的<code>clickBlockXP _clickXp;</code>也可以达到相同的效果，为什么不能那样做呢</p>\n<p>就像这样：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlockXP)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义的全局block */</span></span><br><span class=\"line\">clickBlockXP _clickXp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _clickXp = click;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _clickXp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不能这样做的原因</strong>：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20160523/16386.html\" target=\"_blank\" rel=\"noopener\">Runtime全方位装逼指南</a></p>\n<p><a href=\"https://www.jianshu.com/p/e52c17db0aa9\" target=\"_blank\" rel=\"noopener\">runtime简单使用之动态添加属性</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>为什么要将Runtime的关联属性单独拿出来写一篇文章呢？ 因为单独来讲一个小知识点更加简洁，容易掌握，也是一种知识详细的梳理过程。篇幅越短读者就不容易疲劳，阅读更有效果。</p>\n<p>动态添加方法在后面也会单独写一篇博文。</p>\n<h2 id=\"给分类添加属性\"><a href=\"#给分类添加属性\" class=\"headerlink\" title=\"给分类添加属性\"></a>给分类添加属性</h2><ul>\n<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>\n</ul>\n<p>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">OBJC_EXPORT <span class=\"keyword\">void</span> <span class=\"title\">objc_setAssociatedObject</span>(<span class=\"params\">id <span class=\"keyword\">object</span>, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *key, id <span class=\"keyword\">value</span>, objc_AssociationPolicy policy</span>) __<span class=\"title\">OSX_AVAILABLE_STARTING</span>(<span class=\"params\">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>参数1：object 是源对象</p>\n<p>参数2：value 是被关联的对象</p>\n<p>参数3：key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象</p>\n<p>参数4：policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义</p>\n<p>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可.</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 这个也可以取消关联 */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> objc<span class=\"number\">_</span>removeAssociatedObjects(id <span class=\"keyword\">object</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"应用情景\"><a href=\"#应用情景\" class=\"headerlink\" title=\"应用情景\"></a>应用情景</h3><ul>\n<li>给NSObject类添加一个name属性</li>\n<li>给UIButton或UIView添加一个单击事件回调属性</li>\n<li>给控件（UILable，UIButton，UIView等）添加一个角标显示的信息的属性，以及信息的颜色，字体大小等属性</li>\n</ul>\n<p>下面我们以给 UIButton 添加一个监听单击事件的 block 属性为例：</p>\n<p>创建一个UIButton的分类</p>\n<p>在.h文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlock)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 在分类中声明一个属性时,只会生成setter和getter方法的声明,并不能生成setter和getter方法的</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现以及带下划线的成员变量.</span></span><br><span class=\"line\"><span class=\"comment\"> * 所以, 在分类中有两种方式声明一个属性</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第一种写法 */</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">copy</span>) clickBlock click;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 第二种写法 */</span></span><br><span class=\"line\"><span class=\"comment\">//@property clickBlock click;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>在.m文件：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义关联的key */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *clickKey = <span class=\"string\">\"click\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 产生关联,让某个对象(name)与当前对象的属性(name)产生关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数1: id object :表示给哪个对象添加关联</span></span><br><span class=\"line\"><span class=\"comment\">     参数2: const void *key : 表示: id类型的key值(以后用这个key来获取属性) 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     参数3: id value : 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     参数4: 策略, 是个枚举(点进去,解释很详细)</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     单词Associated 关联</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, clickKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, clickKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>这样，我们就成功的给UIButton类添加了一个监听单击事件的block属性</p>\n<p>使用：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *<span class=\"keyword\">button </span>= [[UIButton alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">button.frame </span>= self.view.<span class=\"keyword\">bounds;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\">[self.view <span class=\"keyword\">addSubview:button];</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   </span><br><span class=\"line\"><span class=\"keyword\">button.click </span>= ^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"点击了button\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"疑难杂症\"><a href=\"#疑难杂症\" class=\"headerlink\" title=\"疑难杂症\"></a>疑难杂症</h2><p>为什么我们会用runtime方法来给系统的类动态添加属性? 直接在分类的.m文件中定义一个全局的<code>clickBlockXP _clickXp;</code>也可以达到相同的效果，为什么不能那样做呢</p>\n<p>就像这样：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"UIButton+block.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">void</span>(^clickBlockXP)(<span class=\"keyword\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 定义的全局block */</span></span><br><span class=\"line\">clickBlockXP _clickXp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">block</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setClick:(clickBlock)click&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _clickXp = click;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> removeTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (click) &#123;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> addTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(buttonClick) forControlEvents:<span class=\"built_in\">UIControlEventTouchUpInside</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (clickBlock)click&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _clickXp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)buttonClick&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.click) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.click();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>不能这样做的原因</strong>：属性保存的地址不同，如果使用疑难杂症中所述的那样，虽然可以达到效果，但是当button销毁了，button.click并不会随着它的销毁而销毁，这样就不是关联关系了，所以这时候就需要使用到runtime，那么就需要将某个属性保存到它的对象里，给哪个对象添加属性，就将之保存到谁里面。属性和对象共存亡。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/21/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加方法</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20160523/16386.html\" target=\"_blank\" rel=\"noopener\">Runtime全方位装逼指南</a></p>\n<p><a href=\"https://www.jianshu.com/p/e52c17db0aa9\" target=\"_blank\" rel=\"noopener\">runtime简单使用之动态添加属性</a></p>\n"},{"title":"Runtime之动态添加方法","date":"2017-02-21T10:13:03.000Z","description":"动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻:只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。","toc":false,"_content":"\n* 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。\n\n* 如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。\n\n* 有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。\n\n## 动态添加方法\n\n以一个示例讲解：\n\n1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。\n\n```\nPanda *pan = [[Panda alloc] init];\n    \n// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。\n// 动态添加方法就不会报错\n    \n/** 无参 */\n//[pan performSelector:@selector(eat)];\n    \n/** 有参 */\n[pan performSelector:@selector(eat:) withObject:@521];\n    \n```\n\n2、在Panda类中添加方法（以有参为例）\n\n```\n#import \"Panda.h\"\n#import <objc/runtime.h>\n\n@implementation Panda\n\n// 默认方法都有两个隐式参数，\n// 定义添加的方法\nvoid eat(id self, SEL sel, NSNumber *meter)\n{\n    NSLog(@\"\\n%@\\n%@\\n%@\",self,NSStringFromSelector(sel),meter);\n}\n\n// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\n// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    \n    if (sel == NSSelectorFromString(@\"eat:\")) {\n        // 动态添加eat方法\n        \n        // 第一个参数：给哪个类添加方法\n        // 第二个参数：添加方法的方法编号\n        // 第三个参数：添加方法的函数实现（函数地址）\n        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n        \n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n@end\n\n```\n\n### 使用场景\n\n一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。\n\n比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n","source":"_posts/Runtime之动态添加方法.md","raw":"---\ntitle: Runtime之动态添加方法\ndate: 2017-2-21 18:13:03\ndescription: 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻:只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。\ncategories: 原理\ntags: [Objective-C,Runtime]\ntoc: false \n---\n\n* 动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。\n\n* 如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。\n\n* 有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。\n\n## 动态添加方法\n\n以一个示例讲解：\n\n1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。\n\n```\nPanda *pan = [[Panda alloc] init];\n    \n// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。\n// 动态添加方法就不会报错\n    \n/** 无参 */\n//[pan performSelector:@selector(eat)];\n    \n/** 有参 */\n[pan performSelector:@selector(eat:) withObject:@521];\n    \n```\n\n2、在Panda类中添加方法（以有参为例）\n\n```\n#import \"Panda.h\"\n#import <objc/runtime.h>\n\n@implementation Panda\n\n// 默认方法都有两个隐式参数，\n// 定义添加的方法\nvoid eat(id self, SEL sel, NSNumber *meter)\n{\n    NSLog(@\"\\n%@\\n%@\\n%@\",self,NSStringFromSelector(sel),meter);\n}\n\n// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.\n// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法\n+ (BOOL)resolveInstanceMethod:(SEL)sel\n{\n    \n    if (sel == NSSelectorFromString(@\"eat:\")) {\n        // 动态添加eat方法\n        \n        // 第一个参数：给哪个类添加方法\n        // 第二个参数：添加方法的方法编号\n        // 第三个参数：添加方法的函数实现（函数地址）\n        // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象->self :表示SEL->_cmd\n        class_addMethod(self, sel, (IMP) eat, \"v@:\");\n        \n        return YES;\n    }\n    \n    return [super resolveInstanceMethod:sel];\n}\n\n@end\n\n```\n\n### 使用场景\n\n一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。\n\n比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。\n\n### 文章链接\n\n[Runtime和消息转发](https://xiaopengmonsters.github.io/2017/02/14/Runtime/)\n\n[Runtime之动态添加属性](https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/)\n\n","slug":"Runtime之动态添加方法","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3jh000l4hfbgoz1vssn","content":"<ul>\n<li><p>动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。</p>\n</li>\n<li><p>如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。</p>\n</li>\n<li><p>有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。</p>\n</li>\n</ul>\n<h2 id=\"动态添加方法\"><a href=\"#动态添加方法\" class=\"headerlink\" title=\"动态添加方法\"></a>动态添加方法</h2><p>以一个示例讲解：</p>\n<p>1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panda *pan = [[Panda alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。</span></span><br><span class=\"line\"><span class=\"comment\">// 动态添加方法就不会报错</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 无参 *</span>/</span></span></span><br><span class=\"line\"><span class=\"comment\">//[pan performSelector:@selector(eat)];</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 有参 *</span>/</span></span></span><br><span class=\"line\">[pan performSelector:<span class=\"meta\">@selector</span>(eat:) withObject:@<span class=\"number\">521</span>];</span><br></pre></td></tr></table></figure>\n<p>2、在Panda类中添加方法（以有参为例）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Panda.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Panda</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认方法都有两个隐式参数，</span></span><br><span class=\"line\"><span class=\"comment\">// 定义添加的方法</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> eat(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL sel, <span class=\"built_in\">NSNumber</span> *meter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"\\n%@\\n%@\\n%@\"</span>,<span class=\"keyword\">self</span>,<span class=\"built_in\">NSStringFromSelector</span>(sel),meter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></span><br><span class=\"line\"><span class=\"comment\">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"eat:\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 动态添加eat方法</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数：给哪个类添加方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数：添加方法的方法编号</span></span><br><span class=\"line\">        <span class=\"comment\">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class=\"line\">        <span class=\"comment\">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。</p>\n<p>比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>动态添加的方法的作用就是去处理未实现的实例方法或者是类方法，它的调用时刻: 只要我们调用了一个不存在的方法时，它就会动态方法解析，接下来就会进入消息转发流程，这此过程中我们可以拦截然后动态的添加方法，防止程序崩溃。</p>\n</li>\n<li><p>如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。</p>\n</li>\n<li><p>有没有使用performSelector，其实主要想问你有没有动态添加过方法。使用performSelector可以调用一个没有实现的方法，但是会报错。</p>\n</li>\n</ul>\n<h2 id=\"动态添加方法\"><a href=\"#动态添加方法\" class=\"headerlink\" title=\"动态添加方法\"></a>动态添加方法</h2><p>以一个示例讲解：</p>\n<p>1、 创建一个熊猫Panda类，Panda类并没有实现eat方法，可以使用performSelector调用一个没有实现的方法，但是会报错。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Panda *pan = [[Panda alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">// 默认Panda，没有实现eat方法，不能直接调用，可以通过performSelector调用，但是会报错。</span></span><br><span class=\"line\"><span class=\"comment\">// 动态添加方法就不会报错</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 无参 *</span>/</span></span></span><br><span class=\"line\"><span class=\"comment\">//[pan performSelector:@selector(eat)];</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"><span class=\"markdown\">/<span class=\"emphasis\">** 有参 *</span>/</span></span></span><br><span class=\"line\">[pan performSelector:<span class=\"meta\">@selector</span>(eat:) withObject:@<span class=\"number\">521</span>];</span><br></pre></td></tr></table></figure>\n<p>2、在Panda类中添加方法（以有参为例）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">\"Panda.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Panda</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认方法都有两个隐式参数，</span></span><br><span class=\"line\"><span class=\"comment\">// 定义添加的方法</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> eat(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL sel, <span class=\"built_in\">NSNumber</span> *meter)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"\\n%@\\n%@\\n%@\"</span>,<span class=\"keyword\">self</span>,<span class=\"built_in\">NSStringFromSelector</span>(sel),meter);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></span><br><span class=\"line\"><span class=\"comment\">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"built_in\">NSSelectorFromString</span>(<span class=\"string\">@\"eat:\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 动态添加eat方法</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数：给哪个类添加方法</span></span><br><span class=\"line\">        <span class=\"comment\">// 第二个参数：添加方法的方法编号</span></span><br><span class=\"line\">        <span class=\"comment\">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class=\"line\">        <span class=\"comment\">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, sel, (IMP) eat, <span class=\"string\">\"v@:\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>一个类方法非常多，一次性加载到内存，比较耗费资源，为什么动态添加方法? OC都是懒加载，有些方法可能很久不会调用。</p>\n<p>比如电商，视频，社交等一些软件会有有收费项目或者会员机制，那么只有在开通会员的时候才会拥有特定功能，然而存在相当一部门用户是没有使用收费功能，或者是没有开通开通会员的，我们就在这些用户使用时不加载这些方法（这个方法的类是要加载的），后面利用Runtime动态的添加这些方法，以达到性能最大化。</p>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"https://xiaopengmonsters.github.io/2017/02/14/Runtime/\" target=\"_blank\" rel=\"noopener\">Runtime和消息转发</a></p>\n<p><a href=\"https://xiaopengmonsters.github.io/2017/02/20/Runtime%E4%B9%8B%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7/\" target=\"_blank\" rel=\"noopener\">Runtime之动态添加属性</a></p>\n"},{"title":"UITableView的优化","date":"2017-12-26T09:23:33.000Z","description":"UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。","toc":false,"_content":"\nUITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\n那么优化就势在必得。。。\n\n## 在优化之前 \n\n### UITableView的cell重用机制\n\nUITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。\n\n简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。\n\n这种机制下系统默认有一个可变数组`NSMutableArray *visiableCells`，用来保存当前显示的cell。一个可变字典`NSMutableDictnery *reusableTableCells`，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。\n\n\n### UITableView的代理方法\n\n 必须实现的两个数据源回调方法:\n\n```\n/** 返回每个分区的行数 */\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\n\n调用最频繁的两个回调方法：\n\n```\n/** 返回cell的高度 */\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\nUITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。\n\n因此，优化UITableView的首要任务就是优化上面这两个回调方法。\n\n## 优化\n\n### 1. Cell重用\n\n**数据源优化方案：**首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：\n\n```\n//调用次数太多，static 保证只创建一次reuseID，提高性能\nstatic NSString *reuseID = “reuseCellID”;\n```\n```\n//缓存池中取已经创建的cell\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];\n```\n\n\n**缓存池的实现：**当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。\n\n### 2. 提前计算并缓存Cell的高度\n\n调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。\n\n* UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。\n\n* 滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell\n\n**方案：**创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。\n\n**示例：**如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）\n\n```\n/**\n *  根据纳信模型数组 转成 纳信frame模型数据\n *\n *  @param statuses 纳信模型数组\n *\n */\n- (NSArray *)statusFramesWithStatuses:(NSArray *)statuses\n{\n    NSMutableArray *frames = [NSMutableArray array];\n    for (NXStatusModel *status in statuses) {\n        NXStatusFrame *frame = [[NXStatusFrame alloc] init];\n        // 传递纳信模型数据，计算所有子控件的frame\n        frame.isMask = NO;\n        frame.status = status;\n        [frames addObject:frame];\n    }\n    return frames;\n}\n```\n\n### 3. 避免cell的重新布局\n\ncell的布局填充等操作 比较耗时，一般创建时就布局好，\n如可以将cell单独放到一个自定义类，初始化时就布局好。\n\n* 尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。\n\n* 只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。\n\n### 4. 滑动时，按需加载\n\n开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。\n\n```\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n```\n\n思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。\n\n```\n//获取可见部分的Cell\nNSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];\n        for (NSIndexPath *indexPath in visiblePaths)\n        {\n        //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载\n             <code>\n        }\n```\n\n记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：\n\n```\n// tableView 停止滑动的时候异步加载图片\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n         if (self.tableView.dragging == NO && self.tableView.decelerating == NO)\n            {\n               //开始异步加载图片\n                <code>\n            }\n```\n    \n### 5. 渲染\n\n不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长\n\n**1、**减少subviews的个数和层级\n \n 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示\n\n**2、**少用subviews的透明图层\n\n 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）\n\n**3、**避免CALayer特效（shadowPath）\n\n给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：\n\n```\nview.layer.shadowColor = color.CGColor;\nview.layer.shadowOffset = offset;\nview.layer.shadowOpacity = 1;\nview.layer.shadowRadius = radius;\n```\n\n### 6. 使用局部更新\n如果只是更新某组的话，使用reloadSection进行局部更新\n\n\n## 总结\n\n[这里](http://www.cocoachina.com/ios/20150602/11968.html)有位大佬，可以去看看哦\n\n UITableView的优化主要从三个方面入手:\n\n* 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；\n* 滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage\n* 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）\n\n除了上面最主要的三个方面外，还有很多熟知的优化点：\n\n* 正确使用reuseIdentifier来重用Cells\n* 尽量使所有的view opaque，包括Cell自身\n* 尽量少用或不用透明图层\n* 如果Cell内现实的内容来自web，使用异步加载，缓存请求结果\n* 减少subviews的数量\n* 在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果\n* 尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示\n\n### 文章链接\n\n[优化UITableViewCell高度计算的那些事](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)\n\n[UITableView优化技巧](http://www.cocoachina.com/ios/20150602/11968.html)\n\n[UITableView性能优化](http://blog.csdn.net/u011452278/article/details/60961350)\n\n\n","source":"_posts/UITableView的优化.md","raw":"---\ntitle: UITableView的优化\ndate: 2017-12-26 17:23:33\n\ndescription: UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\ncategories: [性能]\ntags: [Objective-C]\ntoc: false \n---\n\nUITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。\n\n那么优化就势在必得。。。\n\n## 在优化之前 \n\n### UITableView的cell重用机制\n\nUITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。\n\n简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。\n\n这种机制下系统默认有一个可变数组`NSMutableArray *visiableCells`，用来保存当前显示的cell。一个可变字典`NSMutableDictnery *reusableTableCells`，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。\n\n\n### UITableView的代理方法\n\n 必须实现的两个数据源回调方法:\n\n```\n/** 返回每个分区的行数 */\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\n\n调用最频繁的两个回调方法：\n\n```\n/** 返回cell的高度 */\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n/** 返回每一行的cell */\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;\n\n```\nUITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。\n\n因此，优化UITableView的首要任务就是优化上面这两个回调方法。\n\n## 优化\n\n### 1. Cell重用\n\n**数据源优化方案：**首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：\n\n```\n//调用次数太多，static 保证只创建一次reuseID，提高性能\nstatic NSString *reuseID = “reuseCellID”;\n```\n```\n//缓存池中取已经创建的cell\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:reuseID];\n```\n\n\n**缓存池的实现：**当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。\n\n### 2. 提前计算并缓存Cell的高度\n\n调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。\n\n* UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。\n\n* 滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell\n\n**方案：**创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。\n\n**示例：**如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）\n\n```\n/**\n *  根据纳信模型数组 转成 纳信frame模型数据\n *\n *  @param statuses 纳信模型数组\n *\n */\n- (NSArray *)statusFramesWithStatuses:(NSArray *)statuses\n{\n    NSMutableArray *frames = [NSMutableArray array];\n    for (NXStatusModel *status in statuses) {\n        NXStatusFrame *frame = [[NXStatusFrame alloc] init];\n        // 传递纳信模型数据，计算所有子控件的frame\n        frame.isMask = NO;\n        frame.status = status;\n        [frames addObject:frame];\n    }\n    return frames;\n}\n```\n\n### 3. 避免cell的重新布局\n\ncell的布局填充等操作 比较耗时，一般创建时就布局好，\n如可以将cell单独放到一个自定义类，初始化时就布局好。\n\n* 尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。\n\n* 只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。\n\n### 4. 滑动时，按需加载\n\n开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。\n\n```\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate\n- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView\n```\n\n思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。\n\n```\n//获取可见部分的Cell\nNSArray *visiblePaths = [self.tableView indexPathsForVisibleRows];\n        for (NSIndexPath *indexPath in visiblePaths)\n        {\n        //获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载\n             <code>\n        }\n```\n\n记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：\n\n```\n// tableView 停止滑动的时候异步加载图片\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath\n\n         if (self.tableView.dragging == NO && self.tableView.decelerating == NO)\n            {\n               //开始异步加载图片\n                <code>\n            }\n```\n    \n### 5. 渲染\n\n不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长\n\n**1、**减少subviews的个数和层级\n \n 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示\n\n**2、**少用subviews的透明图层\n\n 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）\n\n**3、**避免CALayer特效（shadowPath）\n\n给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：\n\n```\nview.layer.shadowColor = color.CGColor;\nview.layer.shadowOffset = offset;\nview.layer.shadowOpacity = 1;\nview.layer.shadowRadius = radius;\n```\n\n### 6. 使用局部更新\n如果只是更新某组的话，使用reloadSection进行局部更新\n\n\n## 总结\n\n[这里](http://www.cocoachina.com/ios/20150602/11968.html)有位大佬，可以去看看哦\n\n UITableView的优化主要从三个方面入手:\n\n* 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；\n* 滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage\n* 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）\n\n除了上面最主要的三个方面外，还有很多熟知的优化点：\n\n* 正确使用reuseIdentifier来重用Cells\n* 尽量使所有的view opaque，包括Cell自身\n* 尽量少用或不用透明图层\n* 如果Cell内现实的内容来自web，使用异步加载，缓存请求结果\n* 减少subviews的数量\n* 在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果\n* 尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示\n\n### 文章链接\n\n[优化UITableViewCell高度计算的那些事](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)\n\n[UITableView优化技巧](http://www.cocoachina.com/ios/20150602/11968.html)\n\n[UITableView性能优化](http://blog.csdn.net/u011452278/article/details/60961350)\n\n\n","slug":"UITableView的优化","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3jl000q4hfbv43zo8wn","content":"<p>UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。</p>\n<p>那么优化就势在必得。。。</p>\n<h2 id=\"在优化之前\"><a href=\"#在优化之前\" class=\"headerlink\" title=\"在优化之前\"></a>在优化之前</h2><h3 id=\"UITableView的cell重用机制\"><a href=\"#UITableView的cell重用机制\" class=\"headerlink\" title=\"UITableView的cell重用机制\"></a>UITableView的cell重用机制</h3><p>UITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。</p>\n<p>简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。</p>\n<p>这种机制下系统默认有一个可变数组<code>NSMutableArray *visiableCells</code>，用来保存当前显示的cell。一个可变字典<code>NSMutableDictnery *reusableTableCells</code>，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。</p>\n<h3 id=\"UITableView的代理方法\"><a href=\"#UITableView的代理方法\" class=\"headerlink\" title=\"UITableView的代理方法\"></a>UITableView的代理方法</h3><p> 必须实现的两个数据源回调方法:</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回每个分区的行数 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSInteger)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">numberOfRowsInSection</span><span class=\"selector-pseudo\">:(NSInteger)section</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>调用最频繁的两个回调方法：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回cell的高度 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (CGFloat)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">heightForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>UITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。</p>\n<p>因此，优化UITableView的首要任务就是优化上面这两个回调方法。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"1-Cell重用\"><a href=\"#1-Cell重用\" class=\"headerlink\" title=\"1. Cell重用\"></a>1. Cell重用</h3><p><strong>数据源优化方案：</strong>首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用次数太多，static 保证只创建一次reuseID，提高性能</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *reuseID = “reuseCellID”;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//缓存池中取已经创建的<span class=\"built_in\">cell</span></span><br><span class=\"line\">UITableViewCell *<span class=\"built_in\">cell</span> = [tableView dequeueReusableCellWithIdentifi<span class=\"symbol\">er:re</span>useID];</span><br></pre></td></tr></table></figure>\n<p><strong>缓存池的实现：</strong>当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。</p>\n<h3 id=\"2-提前计算并缓存Cell的高度\"><a href=\"#2-提前计算并缓存Cell的高度\" class=\"headerlink\" title=\"2. 提前计算并缓存Cell的高度\"></a>2. 提前计算并缓存Cell的高度</h3><p>调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。</p>\n<ul>\n<li><p>UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。</p>\n</li>\n<li><p>滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>\n</li>\n</ul>\n<p><strong>方案：</strong>创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。</p>\n<p><strong>示例：</strong>如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据纳信模型数组 转成 纳信frame模型数据</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param statuses 纳信模型数组</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)statusFramesWithStatuses:(<span class=\"built_in\">NSArray</span> *)statuses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *frames = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (NXStatusModel *status <span class=\"keyword\">in</span> statuses) &#123;</span><br><span class=\"line\">        NXStatusFrame *frame = [[NXStatusFrame alloc] init];</span><br><span class=\"line\">        <span class=\"comment\">// 传递纳信模型数据，计算所有子控件的frame</span></span><br><span class=\"line\">        frame.isMask = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        frame.status = status;</span><br><span class=\"line\">        [frames addObject:frame];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frames;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-避免cell的重新布局\"><a href=\"#3-避免cell的重新布局\" class=\"headerlink\" title=\"3. 避免cell的重新布局\"></a>3. 避免cell的重新布局</h3><p>cell的布局填充等操作 比较耗时，一般创建时就布局好，<br>如可以将cell单独放到一个自定义类，初始化时就布局好。</p>\n<ul>\n<li><p>尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。</p>\n</li>\n<li><p>只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>\n</li>\n</ul>\n<h3 id=\"4-滑动时，按需加载\"><a href=\"#4-滑动时，按需加载\" class=\"headerlink\" title=\"4. 滑动时，按需加载\"></a>4. 滑动时，按需加载</h3><p>开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDragging:<span class=\"params\">(UIScrollView *)</span>scrollView willDecelerate:<span class=\"params\">(BOOL)</span>decelerate</span><br><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDecelerating:<span class=\"params\">(UIScrollView *)</span>scrollView</span><br></pre></td></tr></table></figure>\n<p>思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取可见部分的Cell</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *visiblePaths = [<span class=\"keyword\">self</span>.tableView indexPathsForVisibleRows];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSIndexPath</span> *indexPath <span class=\"keyword\">in</span> visiblePaths)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载</span></span><br><span class=\"line\">             &lt;code&gt;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tableView 停止滑动的时候异步加载图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.tableView.dragging == <span class=\"literal\">NO</span> &amp;&amp; <span class=\"keyword\">self</span>.tableView.decelerating == <span class=\"literal\">NO</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"comment\">//开始异步加载图片</span></span><br><span class=\"line\">                &lt;code&gt;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-渲染\"><a href=\"#5-渲染\" class=\"headerlink\" title=\"5. 渲染\"></a>5. 渲染</h3><p>不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长</p>\n<p><strong>1、</strong>减少subviews的个数和层级</p>\n<p> 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示</p>\n<p><strong>2、</strong>少用subviews的透明图层</p>\n<p> 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）</p>\n<p><strong>3、</strong>避免CALayer特效（shadowPath）</p>\n<p>给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.<span class=\"keyword\">shadowColor </span>= color.CGColor<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOffset </span>= offset<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOpacity </span>= <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowRadius </span>= radius<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-使用局部更新\"><a href=\"#6-使用局部更新\" class=\"headerlink\" title=\"6. 使用局部更新\"></a>6. 使用局部更新</h3><p>如果只是更新某组的话，使用reloadSection进行局部更新</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">这里</a>有位大佬，可以去看看哦</p>\n<p> UITableView的优化主要从三个方面入手:</p>\n<ul>\n<li>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</li>\n<li>滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage</li>\n<li>异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）</li>\n</ul>\n<p>除了上面最主要的三个方面外，还有很多熟知的优化点：</p>\n<ul>\n<li>正确使用reuseIdentifier来重用Cells</li>\n<li>尽量使所有的view opaque，包括Cell自身</li>\n<li>尽量少用或不用透明图层</li>\n<li>如果Cell内现实的内容来自web，使用异步加载，缓存请求结果</li>\n<li>减少subviews的数量</li>\n<li>在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li>\n<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</li>\n</ul>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">UITableView优化技巧</a></p>\n<p><a href=\"http://blog.csdn.net/u011452278/article/details/60961350\" target=\"_blank\" rel=\"noopener\">UITableView性能优化</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>UITableView是iOS中最常用的控件之一，毫不夸张的说基本每个app的都会用到UITableView，简单的使用可能不会有什么问题，但是利用UITableView进行复杂的布局（比如朋友圈的实现），就可能会出现一些性能问题，例如：滑动时卡顿，cell加载太慢等。</p>\n<p>那么优化就势在必得。。。</p>\n<h2 id=\"在优化之前\"><a href=\"#在优化之前\" class=\"headerlink\" title=\"在优化之前\"></a>在优化之前</h2><h3 id=\"UITableView的cell重用机制\"><a href=\"#UITableView的cell重用机制\" class=\"headerlink\" title=\"UITableView的cell重用机制\"></a>UITableView的cell重用机制</h3><p>UITableView最核心的思想就是UITableViewCell的重用机制。重用机制实现了数据和显示的分离,并不为每个数据创建一个UITableViewCell。</p>\n<p>简单的理解就是：UITableView只会创建一屏幕（或一屏幕多一点）的UITableViewCell，其他都是从中取出来重用的。每当Cell滑出屏幕时，就会放入到一个集合（或数组）中（这里就相当于一个重用池），当要显示某一位置的Cell时，会先去集合（或数组）中取，如果有，就直接拿来显示；如果没有，才会创建。这样做的好处可想而知，极大的减少了内存的开销。</p>\n<p>这种机制下系统默认有一个可变数组<code>NSMutableArray *visiableCells</code>，用来保存当前显示的cell。一个可变字典<code>NSMutableDictnery *reusableTableCells</code>，用来保存可重复利用的cell。（之所以用字典是因为可重用的cell有不止一种样式,我们需要根据它的reuseIdentifier,也就是所谓的重用标示符来查找是否有可重用的该样式的cell）。</p>\n<h3 id=\"UITableView的代理方法\"><a href=\"#UITableView的代理方法\" class=\"headerlink\" title=\"UITableView的代理方法\"></a>UITableView的代理方法</h3><p> 必须实现的两个数据源回调方法:</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回每个分区的行数 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (NSInteger)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">numberOfRowsInSection</span><span class=\"selector-pseudo\">:(NSInteger)section</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>调用最频繁的两个回调方法：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 返回cell的高度 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (CGFloat)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">heightForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 返回每一行的cell */</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (UITableViewCell *)<span class=\"selector-tag\">tableView</span><span class=\"selector-pseudo\">:(UITableView</span> *)<span class=\"selector-tag\">tableView</span> <span class=\"selector-tag\">cellForRowAtIndexPath</span><span class=\"selector-pseudo\">:(NSIndexPath</span> *)<span class=\"selector-tag\">indexPath</span>;</span><br></pre></td></tr></table></figure>\n<p>UITableView是继承自UIScrollView的，需要先确定它的contentSize及每个Cell的位置，然后才会把重用的Cell放置到对应的位置。所以事实上，UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定contentSize及Cell的位置，然后才会调用tableView:cellForRowAtIndexPath:，从而来显示在当前屏幕的Cell。</p>\n<p>因此，优化UITableView的首要任务就是优化上面这两个回调方法。</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"1-Cell重用\"><a href=\"#1-Cell重用\" class=\"headerlink\" title=\"1. Cell重用\"></a>1. Cell重用</h3><p><strong>数据源优化方案：</strong>首先创建一个静态变量reuseID（代理方法返回Cell会调用很多次，防止重复创建，static保证只会被创建一次，提高性能），然后，从缓存池中取相应identifier的Cell并更新数据，如果没有，才开始alloc新的Cell，并用identifier标识Cell。每个Cell都会注册一个identifier（重用标识符）放入缓存池，当需要调用的时候就直接从缓存池里找对应的id，当不需要时就放入缓存池等待调用。（移出屏幕的Cell才会放入缓存池中，并不会被release）所以在数据源方法中做出如下优化：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用次数太多，static 保证只创建一次reuseID，提高性能</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">NSString</span> *reuseID = “reuseCellID”;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//缓存池中取已经创建的<span class=\"built_in\">cell</span></span><br><span class=\"line\">UITableViewCell *<span class=\"built_in\">cell</span> = [tableView dequeueReusableCellWithIdentifi<span class=\"symbol\">er:re</span>useID];</span><br></pre></td></tr></table></figure>\n<p><strong>缓存池的实现：</strong>当Cell要alloc时，UITableView会在堆中开辟一段内存以供Cell缓存之用。Cell的重用通过identifier标识不同类型的Cell，由此可以推断出，缓存池外层可能是一个可变字典，通过key来取出内部的Cell，而缓存池为存储不同高度、不同类型（包含图片、Label等）的Cell，可以推断出缓存池的字典内部可能是一个可变数组，用来存放不同类型的Cell，缓存池中只会保存已经被移出屏幕的不同类型的Cell。</p>\n<h3 id=\"2-提前计算并缓存Cell的高度\"><a href=\"#2-提前计算并缓存Cell的高度\" class=\"headerlink\" title=\"2. 提前计算并缓存Cell的高度\"></a>2. 提前计算并缓存Cell的高度</h3><p>调用最频繁的两个方法，上面已经优化了数据源方法，这里就是优化tableView:heightForRowAtIndexPath:方法了。</p>\n<ul>\n<li><p>UITableView在不设UITableViewCell的预估行高的情况下，会优先调用tableView:heightForRowAtIndexPath:方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用tableView:cellForRowAtIndexPath,获取每个Cell，进行赋值。</p>\n</li>\n<li><p>滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</p>\n</li>\n</ul>\n<p><strong>方案：</strong>创建一个frame模型，在刚获取到数据的时候，提前计算每个Cell的高度，之后每次返回缓存高度，可以避免在滑动时实时计算高度。</p>\n<p><strong>示例：</strong>如下面这个是我以前开发的朋友圈，先将获取到的数据转化为模型，然后将模型数组转换为frame模型数据，提前计算好所有的frame（包括cell高度和cell所有子控件frame）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  根据纳信模型数组 转成 纳信frame模型数据</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @param statuses 纳信模型数组</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)statusFramesWithStatuses:(<span class=\"built_in\">NSArray</span> *)statuses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *frames = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (NXStatusModel *status <span class=\"keyword\">in</span> statuses) &#123;</span><br><span class=\"line\">        NXStatusFrame *frame = [[NXStatusFrame alloc] init];</span><br><span class=\"line\">        <span class=\"comment\">// 传递纳信模型数据，计算所有子控件的frame</span></span><br><span class=\"line\">        frame.isMask = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        frame.status = status;</span><br><span class=\"line\">        [frames addObject:frame];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> frames;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-避免cell的重新布局\"><a href=\"#3-避免cell的重新布局\" class=\"headerlink\" title=\"3. 避免cell的重新布局\"></a>3. 避免cell的重新布局</h3><p>cell的布局填充等操作 比较耗时，一般创建时就布局好，<br>如可以将cell单独放到一个自定义类，初始化时就布局好。</p>\n<ul>\n<li><p>尽可能的将 相同内容的抽取到一种样式Cell中，前面已经提到了Cell的重用机制，这样就能保证UITbaleView要显示多少内容，真正创建出的Cell可能只比屏幕显示的Cell多一点。虽然Cell的’体积’可能会大点，但是因为Cell的数量不会很多，完全可以接受的。</p>\n</li>\n<li><p>只定义一种Cell，那该如何显示不同类型的内容呢？答案就是，把所有不同类型的view都定义好，放在cell里面，通过hidden显示、隐藏，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示、隐藏subview比实时创建要快得多。</p>\n</li>\n</ul>\n<h3 id=\"4-滑动时，按需加载\"><a href=\"#4-滑动时，按需加载\" class=\"headerlink\" title=\"4. 滑动时，按需加载\"></a>4. 滑动时，按需加载</h3><p>开发的过程中，自定义Cell的种类千奇百怪，但Cell本来就是用来显示数据的，不说100%带有图片，也差不多，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿，我记得好像线程条数一般3-5条，最多也就6条吧。这个时候利用UIScrollViewDelegate两个代理方法就能很好地解决这个问题。</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDragging:<span class=\"params\">(UIScrollView *)</span>scrollView willDecelerate:<span class=\"params\">(BOOL)</span>decelerate</span><br><span class=\"line\">- <span class=\"params\">(void)</span>scrollViewDidEndDecelerating:<span class=\"params\">(UIScrollView *)</span>scrollView</span><br></pre></td></tr></table></figure>\n<p>思想就是识别UITableView禁止或者减速滑动结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的Cell，这样按需加载，极大的提高流畅度。而SDWebImage可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取可见部分的Cell</span></span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *visiblePaths = [<span class=\"keyword\">self</span>.tableView indexPathsForVisibleRows];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">NSIndexPath</span> *indexPath <span class=\"keyword\">in</span> visiblePaths)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取的dataSource里面的对象，并且判断加载完成的不需要再次异步加载</span></span><br><span class=\"line\">             &lt;code&gt;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>记得在记得在“tableView:cellForRowAtIndexPath:”方法中加入判断：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tableView 停止滑动的时候异步加载图片</span></span><br><span class=\"line\">- (<span class=\"built_in\">UITableViewCell</span> *)tableView:(<span class=\"built_in\">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class=\"built_in\">NSIndexPath</span> *)indexPath</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.tableView.dragging == <span class=\"literal\">NO</span> &amp;&amp; <span class=\"keyword\">self</span>.tableView.decelerating == <span class=\"literal\">NO</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">               <span class=\"comment\">//开始异步加载图片</span></span><br><span class=\"line\">                &lt;code&gt;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-渲染\"><a href=\"#5-渲染\" class=\"headerlink\" title=\"5. 渲染\"></a>5. 渲染</h3><p>不要使用ClearColor，无背景色，透明度也不要设置为0，渲染耗时比较长</p>\n<p><strong>1、</strong>减少subviews的个数和层级</p>\n<p> 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用drawRect绘制元素，替代用view显示</p>\n<p><strong>2、</strong>少用subviews的透明图层</p>\n<p> 对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容（尽量设置Cell的view为opaque，避免GPU对Cell下面的内容也进行绘制）</p>\n<p><strong>3、</strong>避免CALayer特效（shadowPath）</p>\n<p>给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view.layer.<span class=\"keyword\">shadowColor </span>= color.CGColor<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOffset </span>= offset<span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowOpacity </span>= <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">view.layer.<span class=\"keyword\">shadowRadius </span>= radius<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-使用局部更新\"><a href=\"#6-使用局部更新\" class=\"headerlink\" title=\"6. 使用局部更新\"></a>6. 使用局部更新</h3><p>如果只是更新某组的话，使用reloadSection进行局部更新</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">这里</a>有位大佬，可以去看看哦</p>\n<p> UITableView的优化主要从三个方面入手:</p>\n<ul>\n<li>提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</li>\n<li>滑动时按需加载，防止卡顿，这个我也认为是很有必要做的性能优化，配合SDWebImage</li>\n<li>异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口（如题，遇到复杂的界面，可以从这入手）</li>\n</ul>\n<p>除了上面最主要的三个方面外，还有很多熟知的优化点：</p>\n<ul>\n<li>正确使用reuseIdentifier来重用Cells</li>\n<li>尽量使所有的view opaque，包括Cell自身</li>\n<li>尽量少用或不用透明图层</li>\n<li>如果Cell内现实的内容来自web，使用异步加载，缓存请求结果</li>\n<li>减少subviews的数量</li>\n<li>在heightForRowAtIndexPath:中尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li>\n<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示</li>\n</ul>\n<h3 id=\"文章链接\"><a href=\"#文章链接\" class=\"headerlink\" title=\"文章链接\"></a>文章链接</h3><p><a href=\"http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/\" target=\"_blank\" rel=\"noopener\">优化UITableViewCell高度计算的那些事</a></p>\n<p><a href=\"http://www.cocoachina.com/ios/20150602/11968.html\" target=\"_blank\" rel=\"noopener\">UITableView优化技巧</a></p>\n<p><a href=\"http://blog.csdn.net/u011452278/article/details/60961350\" target=\"_blank\" rel=\"noopener\">UITableView性能优化</a></p>\n"},{"title":"Hello World","date":"2016-12-01T08:23:08.000Z","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","toc":true,"_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-12-01 16:23:08\n\ndescription: Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\ncategories: [iOS]\ntags: [Objective-C,Swift]\ntoc: true \n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3jq000t4hfbzraj3f5v","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"iOS中的多线程","date":"2017-11-18T03:11:18.000Z","description":"在 iOS 中其实目前有 4 套多线程方案","toc":true,"_content":"\n在 iOS 中其实目前有 4 套多线程方案，他们分别是：\n\n1. Pthreads\n2. NSThread\n3. GCD\n4. NSOperation & NSOperationQueue\n\n## Pthreads     \n\n**特点：**\n\n* 一套通用的多线程API\n* 适用于Unix\\Linux\\Windows等系统\n* 跨平台\\可移植\n* 使用难度大\n\n**使用语言：**基于 c语言 的框架\n\n**使用频率：**几乎不用\n\n**线程生命周期：**由程序员手动进行管理\n\n## NSThread\n\n**特点：**\n\n* 使用更加面向对象\n* 简单易用，可直接操作线程对象\n\n**使用语言：**OC语言\n\n**使用频率：**偶尔使用\n\n**线程生命周期：**由程序员手动进行管理\n\n\n这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便\n\n### 使用\n\n* 先创建线程类，再启动\n\n```\n// 创建\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];\n\n// 启动\n[thread start];\n\n```\n\n* 创建并自动启动\n\n```\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];\n\n```\n\n* 使用 NSObject 的方法创建并自动启动\n\n```\n[self performSelectorInBackground:@selector(run:) withObject:nil];\n```\n\n\n## GCD\n\n**特点:**\n\n* 旨在替代NSThread等线程技术\n* 充分利用设备的多核（自动）\n\n**使用语言：**C语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\n\n它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。\n\n## NSOperation\n\n**特点:**\n\n* 基于GCD（底层是GCD）\n* 比GCD多了一些更简单实用的功能\n* 使用更加面向对象\n\n**使用语言：**OC语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\nNSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：\n\n1. 将要执行的任务封装到一个 NSOperation 对象中。\n2. 将此任务添加到一个 NSOperationQueue 对象中。\n\n然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：\n\n### 添加任务\n\n值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。\n\n* NSInvocationOperation: 需要传入一个方法名\n\n```\n//1.创建NSInvocationOperation对象\nNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n\n//2.开始执行\n[operation start];\n\n```\n\n* NSBlockOperation\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n      NSLog(@\"%@\", [NSThread currentThread]);\n  }];\n\n//2.开始任务\n[operation start];\n  \n```\n\n之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 **会并发执行**，它会 **在主线程和其它的多个线程** 执行这些任务，注意下面的打印结果：\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//添加多个Block\n//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//2.开始任务\n[operation start];\n\n```\n\n**打印：**\n\n```\n2017-11-18 16:30:29.787013+0800 model[75340:4510678] <NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787049+0800 model[75340:4510790] 第1次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510788] 第0次：<NSThread: 0x60400046f6c0>{number = 3, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510791] 第2次：<NSThread: 0x600000463100>{number = 5, name = (null)}\n\n2017-11-18 16:30:29.787179+0800 model[75340:4510678] 第3次：<NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787181+0800 model[75340:4510790] 第4次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n```\n\n* 自定义Operation\n\n除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。\n\n### 创建队列\n\n看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 **同步执行** 的。就算是 addExecutionBlock 方法，也会在 **当前线程和其他线程 **中执行，也就是说还是会占用当前线程。这是就要用到队列 **NSOperationQueue** 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。**只要添加到队列，会自动调用任务的 start() 方法**\n\n* 主队列\n\n每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。\n\n```\nNSOperationQueue *queue = [NSOperationQueue mainQueue];\n```\n\n\n* 其他队列\n\n因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。\n\n注意：其他队列的任务会在其他线程并行执行。\n\n```\n//1.创建一个其他队列    \nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n//2.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//3.添加多个Block\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//4.队列添加任务\n[queue addOperation:operation];\n\n```\n\n打印\n\n```\n2017-11-18 17:49:25.806408+0800 model[75459:4552310] 第1次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n2017-11-18 17:49:25.806410+0800 model[75459:4552309] 第0次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806417+0800 model[75459:4552317] 第2次：<NSThread: 0x60400027bf00>{number = 4, name = (null)}\n\n2017-11-18 17:49:25.806424+0800 model[75459:4552307] <NSThread: 0x600000271280>{number = 3, name = (null)}\n\n2017-11-18 17:49:25.806668+0800 Runtime[75459:4552309] 第3次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806673+0800 model[75459:4552310] 第4次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n```\n\n**问题：**将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？\n\n**答：**这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛\n\nNSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。\n\nNSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:\n\n```\n//1.任务一：下载图片\nNSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"下载图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//2.任务二：打水印\nNSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"打水印   - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//3.任务三：上传图片\nNSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"上传图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//4.设置依赖\n[operation2 addDependency:operation1];      //任务二依赖任务一\n[operation3 addDependency:operation2];      //任务三依赖任务二\n\n//5.创建队列并加入任务\nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];\n\n```\n\n**打印**\n\n\n```\n2017-11-18 18:01:25.806424+0800 model[19392:4637517] 下载图片 - <NSThread: 0x7fc10ad4d970>{number = 2, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 打水印 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 上传图片 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n```\n\n* 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。\n* 可以使用 removeDependency 来解除依赖关系。\n* 可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。\n\n### 其他方法\n\n以上就是一些主要方法, 下面还有一些常用方法需要大家注意：\n\n* NSOperation\n\n```\nBOOL executing; //判断任务是否正在执行\n\nBOOL finished; //判断任务是否完成\n\nvoid (^completionBlock)(void); //用来设置完成后需要执行的操作\n\n- (void)cancel; //取消任务\n\n- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕\n\n```\n\n* NSOperationQueue\n\n```\nNSUInteger operationCount; //获取队列的任务数\n\n- (void)cancelAllOperations; //取消队列中所有的任务\n\n- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕\n\n[queue setSuspended:YES]; // 暂停queue\n\n[queue setSuspended:NO]; // 继续queue\n\n```\n\n## 多线程的原理\n\n同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。\n\n* **问题：**如果线程非常非常多，会发生什么情况？\n\n* **答：**CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）\n\n\n多线程的优点\n \n* 能适当提高程序的执行效率；\n* 能适当提高资源利用率（CPU、内存利用率）\n\n多线程的缺点\n\n* 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能\n* 线程越多，CPU在调度线程上的开销就越大\n* 程序设计更加复杂：比如线程之间的通信、多线程的数据共享\n\n## 多线程的应用（个别案例）\n\n### 线程同步\n\n线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：\n\n* **互斥锁 ：**给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。\n\n```\n@synchronized(self) {\n  //需要执行的代码块\n}\n\n```\n\n* **同步执行 ：**我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:\n\n```\n//GCD\n//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中\ndispatch_sync(queue, ^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:0.1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n});\n\n\n//NSOperation & NSOperationQueue\n//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中\n//       2. 设置 queue 的 maxConcurrentOperationCount 为 1\n//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！\n\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n}];\n\n[queue addOperation:operation];\n\n[operation waitUntilFinished];\n\n//后续要做的事\n\n```\n\n### 延迟执行\n\n延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。\n\n* perform\n\n```\n// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"\n[self performSelector:@selector(run:) withObject:@\"abc\" afterDelay:3];\n\n```\n\n* GCD\n\n可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用\n\n```\n// 创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n// 设置延时，单位秒\ndouble delay = 3; \n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{\n  // 3秒后需要执行的任务\n});\n\n```\n\n* NSTimer\n\nNSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法\n\n```\n[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@\"abc\" repeats:NO];\n\n```\n\n### 单例模式\n\n```\n@interface HbhNetWorkManager : NSObject <NSCopying>\n\n@property (nonatomic, strong) AFHTTPSessionManager *manager;\n\n/**\n *  单例\n *\n *  @return HbhNetWorkManager\n */\n+(instancetype) shareInstance;\n\n@end\n\nstatic HbhNetWorkManager *shareInstance = nil;\n+(instancetype) shareInstance{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        shareInstance=[[HbhNetWorkManager alloc] init];\n    });\n    return shareInstance;\n}\n```\n\n### 从其他线程回到主线程的方法\n\n* NSThread\n\n```\n//Objective-C\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];\n\n//Swift\n//swift 取消了 performSelector 方法。\n\n```\n\n* GCD\n\n```\n//Objective-C\ndispatch_async(dispatch_get_main_queue(), ^{\n\n});\n\n//Swift\ndispatch_async(dispatch_get_main_queue(), { () -> Void in\n\n})\n\n```\n\n* NSOperationQueue\n\n```\n/Objective-C\n[[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\n}];\n\n//Swift\nNSOperationQueue.mainQueue().addOperationWithBlock { () -> Void in\n\n}\n\n```\n\n## 多线程的选择（更倾向于哪一种？）\n\n倾向于GCD\n\n因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。\n\n## 参考文献\n\n[这里有一篇文章写的非常好，推荐。](https://www.jianshu.com/p/0b0d9b1f1f19)\n","source":"_posts/iOS中的多线程.md","raw":"---\ntitle: iOS中的多线程\ndate: 2017-11-18 11:11:18\n\ndescription: 在 iOS 中其实目前有 4 套多线程方案\n\ncategories: [原理]\ntags: [Objective-C]\ntoc: true \n---\n\n在 iOS 中其实目前有 4 套多线程方案，他们分别是：\n\n1. Pthreads\n2. NSThread\n3. GCD\n4. NSOperation & NSOperationQueue\n\n## Pthreads     \n\n**特点：**\n\n* 一套通用的多线程API\n* 适用于Unix\\Linux\\Windows等系统\n* 跨平台\\可移植\n* 使用难度大\n\n**使用语言：**基于 c语言 的框架\n\n**使用频率：**几乎不用\n\n**线程生命周期：**由程序员手动进行管理\n\n## NSThread\n\n**特点：**\n\n* 使用更加面向对象\n* 简单易用，可直接操作线程对象\n\n**使用语言：**OC语言\n\n**使用频率：**偶尔使用\n\n**线程生命周期：**由程序员手动进行管理\n\n\n这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便\n\n### 使用\n\n* 先创建线程类，再启动\n\n```\n// 创建\nNSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:nil];\n\n// 启动\n[thread start];\n\n```\n\n* 创建并自动启动\n\n```\n[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:nil];\n\n```\n\n* 使用 NSObject 的方法创建并自动启动\n\n```\n[self performSelectorInBackground:@selector(run:) withObject:nil];\n```\n\n\n## GCD\n\n**特点:**\n\n* 旨在替代NSThread等线程技术\n* 充分利用设备的多核（自动）\n\n**使用语言：**C语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\n\n它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。\n\n## NSOperation\n\n**特点:**\n\n* 基于GCD（底层是GCD）\n* 比GCD多了一些更简单实用的功能\n* 使用更加面向对象\n\n**使用语言：**OC语言\n\n**使用频率：**经常使用\n\n**线程生命周期：**自动管理\n\nNSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：\n\n1. 将要执行的任务封装到一个 NSOperation 对象中。\n2. 将此任务添加到一个 NSOperationQueue 对象中。\n\n然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：\n\n### 添加任务\n\n值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。\n\n* NSInvocationOperation: 需要传入一个方法名\n\n```\n//1.创建NSInvocationOperation对象\nNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n\n//2.开始执行\n[operation start];\n\n```\n\n* NSBlockOperation\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n      NSLog(@\"%@\", [NSThread currentThread]);\n  }];\n\n//2.开始任务\n[operation start];\n  \n```\n\n之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 **会并发执行**，它会 **在主线程和其它的多个线程** 执行这些任务，注意下面的打印结果：\n\n```\n//1.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//添加多个Block\n//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//2.开始任务\n[operation start];\n\n```\n\n**打印：**\n\n```\n2017-11-18 16:30:29.787013+0800 model[75340:4510678] <NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787049+0800 model[75340:4510790] 第1次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510788] 第0次：<NSThread: 0x60400046f6c0>{number = 3, name = (null)}\n\n2017-11-18 16:30:29.787050+0800 model[75340:4510791] 第2次：<NSThread: 0x600000463100>{number = 5, name = (null)}\n\n2017-11-18 16:30:29.787179+0800 model[75340:4510678] 第3次：<NSThread: 0x600000262e00>{number = 1, name = main}\n\n2017-11-18 16:30:29.787181+0800 model[75340:4510790] 第4次：<NSThread: 0x60400046f700>{number = 4, name = (null)}\n\n```\n\n* 自定义Operation\n\n除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。\n\n### 创建队列\n\n看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 **同步执行** 的。就算是 addExecutionBlock 方法，也会在 **当前线程和其他线程 **中执行，也就是说还是会占用当前线程。这是就要用到队列 **NSOperationQueue** 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。**只要添加到队列，会自动调用任务的 start() 方法**\n\n* 主队列\n\n每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。\n\n```\nNSOperationQueue *queue = [NSOperationQueue mainQueue];\n```\n\n\n* 其他队列\n\n因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。\n\n注意：其他队列的任务会在其他线程并行执行。\n\n```\n//1.创建一个其他队列    \nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n//2.创建NSBlockOperation对象\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"%@\", [NSThread currentThread]);\n}];\n\n//3.添加多个Block\nfor (NSInteger i = 0; i < 5; i++) {\n    [operation addExecutionBlock:^{\n        NSLog(@\"第%ld次：%@\", i, [NSThread currentThread]);\n    }];\n}\n\n//4.队列添加任务\n[queue addOperation:operation];\n\n```\n\n打印\n\n```\n2017-11-18 17:49:25.806408+0800 model[75459:4552310] 第1次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n2017-11-18 17:49:25.806410+0800 model[75459:4552309] 第0次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806417+0800 model[75459:4552317] 第2次：<NSThread: 0x60400027bf00>{number = 4, name = (null)}\n\n2017-11-18 17:49:25.806424+0800 model[75459:4552307] <NSThread: 0x600000271280>{number = 3, name = (null)}\n\n2017-11-18 17:49:25.806668+0800 Runtime[75459:4552309] 第3次：<NSThread: 0x6000002712c0>{number = 5, name = (null)}\n\n2017-11-18 17:49:25.806673+0800 model[75459:4552310] 第4次：<NSThread: 0x600000271300>{number = 6, name = (null)}\n\n```\n\n**问题：**将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？\n\n**答：**这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛\n\nNSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。\n\nNSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:\n\n```\n//1.任务一：下载图片\nNSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"下载图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//2.任务二：打水印\nNSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"打水印   - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//3.任务三：上传图片\nNSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^{\n    NSLog(@\"上传图片 - %@\", [NSThread currentThread]);\n    [NSThread sleepForTimeInterval:1.0];\n}];\n\n//4.设置依赖\n[operation2 addDependency:operation1];      //任务二依赖任务一\n[operation3 addDependency:operation2];      //任务三依赖任务二\n\n//5.创建队列并加入任务\nNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];\n\n```\n\n**打印**\n\n\n```\n2017-11-18 18:01:25.806424+0800 model[19392:4637517] 下载图片 - <NSThread: 0x7fc10ad4d970>{number = 2, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 打水印 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n2017-11-18 18:01:25.806424+0800 model[19392:4637515] 上传图片 - <NSThread: 0x7fc10af20ef0>{number = 3, name = (null)}\n\n```\n\n* 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。\n* 可以使用 removeDependency 来解除依赖关系。\n* 可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。\n\n### 其他方法\n\n以上就是一些主要方法, 下面还有一些常用方法需要大家注意：\n\n* NSOperation\n\n```\nBOOL executing; //判断任务是否正在执行\n\nBOOL finished; //判断任务是否完成\n\nvoid (^completionBlock)(void); //用来设置完成后需要执行的操作\n\n- (void)cancel; //取消任务\n\n- (void)waitUntilFinished; //阻塞当前线程直到此任务执行完毕\n\n```\n\n* NSOperationQueue\n\n```\nNSUInteger operationCount; //获取队列的任务数\n\n- (void)cancelAllOperations; //取消队列中所有的任务\n\n- (void)waitUntilAllOperationsAreFinished; //阻塞当前线程直到此队列中的所有任务执行完毕\n\n[queue setSuspended:YES]; // 暂停queue\n\n[queue setSuspended:NO]; // 继续queue\n\n```\n\n## 多线程的原理\n\n同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。\n\n* **问题：**如果线程非常非常多，会发生什么情况？\n\n* **答：**CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）\n\n\n多线程的优点\n \n* 能适当提高程序的执行效率；\n* 能适当提高资源利用率（CPU、内存利用率）\n\n多线程的缺点\n\n* 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能\n* 线程越多，CPU在调度线程上的开销就越大\n* 程序设计更加复杂：比如线程之间的通信、多线程的数据共享\n\n## 多线程的应用（个别案例）\n\n### 线程同步\n\n线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：\n\n* **互斥锁 ：**给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。\n\n```\n@synchronized(self) {\n  //需要执行的代码块\n}\n\n```\n\n* **同步执行 ：**我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:\n\n```\n//GCD\n//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中\ndispatch_sync(queue, ^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:0.1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n});\n\n\n//NSOperation & NSOperationQueue\n//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中\n//       2. 设置 queue 的 maxConcurrentOperationCount 为 1\n//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！\n\nNSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{\n    NSInteger ticket = lastTicket;\n    [NSThread sleepForTimeInterval:1];\n    NSLog(@\"%ld - %@\",ticket, [NSThread currentThread]);\n    ticket -= 1;\n    lastTicket = ticket;\n}];\n\n[queue addOperation:operation];\n\n[operation waitUntilFinished];\n\n//后续要做的事\n\n```\n\n### 延迟执行\n\n延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。\n\n* perform\n\n```\n// 3秒后自动调用self的run:方法，并且传递参数：@\"abc\"\n[self performSelector:@selector(run:) withObject:@\"abc\" afterDelay:3];\n\n```\n\n* GCD\n\n可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用\n\n```\n// 创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n// 设置延时，单位秒\ndouble delay = 3; \n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), queue, ^{\n  // 3秒后需要执行的任务\n});\n\n```\n\n* NSTimer\n\nNSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法\n\n```\n[NSTimer scheduledTimerWithTimeInterval:3.0 target:self selector:@selector(run:) userInfo:@\"abc\" repeats:NO];\n\n```\n\n### 单例模式\n\n```\n@interface HbhNetWorkManager : NSObject <NSCopying>\n\n@property (nonatomic, strong) AFHTTPSessionManager *manager;\n\n/**\n *  单例\n *\n *  @return HbhNetWorkManager\n */\n+(instancetype) shareInstance;\n\n@end\n\nstatic HbhNetWorkManager *shareInstance = nil;\n+(instancetype) shareInstance{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        shareInstance=[[HbhNetWorkManager alloc] init];\n    });\n    return shareInstance;\n}\n```\n\n### 从其他线程回到主线程的方法\n\n* NSThread\n\n```\n//Objective-C\n[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];\n\n//Swift\n//swift 取消了 performSelector 方法。\n\n```\n\n* GCD\n\n```\n//Objective-C\ndispatch_async(dispatch_get_main_queue(), ^{\n\n});\n\n//Swift\ndispatch_async(dispatch_get_main_queue(), { () -> Void in\n\n})\n\n```\n\n* NSOperationQueue\n\n```\n/Objective-C\n[[NSOperationQueue mainQueue] addOperationWithBlock:^{\n\n}];\n\n//Swift\nNSOperationQueue.mainQueue().addOperationWithBlock { () -> Void in\n\n}\n\n```\n\n## 多线程的选择（更倾向于哪一种？）\n\n倾向于GCD\n\n因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。\n\n## 参考文献\n\n[这里有一篇文章写的非常好，推荐。](https://www.jianshu.com/p/0b0d9b1f1f19)\n","slug":"iOS中的多线程","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3ju000x4hfb7rv68v8r","content":"<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>\n<ol>\n<li>Pthreads</li>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation &amp; NSOperationQueue</li>\n</ol>\n<h2 id=\"Pthreads\"><a href=\"#Pthreads\" class=\"headerlink\" title=\"Pthreads\"></a>Pthreads</h2><p><strong>特点：</strong></p>\n<ul>\n<li>一套通用的多线程API</li>\n<li>适用于Unix\\Linux\\Windows等系统</li>\n<li>跨平台\\可移植</li>\n<li>使用难度大</li>\n</ul>\n<p><strong>使用语言：</strong>基于 c语言 的框架</p>\n<p><strong>使用频率：</strong>几乎不用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<h2 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h2><p><strong>特点：</strong></p>\n<ul>\n<li>使用更加面向对象</li>\n<li>简单易用，可直接操作线程对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>偶尔使用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>先创建线程类，再启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\">NSThread *thread = [[NSThread alloc] <span class=\"string\">initWithTarget:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">object:</span>nil];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动</span></span><br><span class=\"line\">[thread start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSThread <span class=\"string\">detachNewThreadSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">toTarget:</span>self <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 NSObject 的方法创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self <span class=\"string\">performSelectorInBackground:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p><strong>特点:</strong></p>\n<ul>\n<li>旨在替代NSThread等线程技术</li>\n<li>充分利用设备的多核（自动）</li>\n</ul>\n<p><strong>使用语言：</strong>C语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。</p>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p><strong>特点:</strong></p>\n<ul>\n<li>基于GCD（底层是GCD）</li>\n<li>比GCD多了一些更简单实用的功能</li>\n<li>使用更加面向对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>\n<ol>\n<li>将要执行的任务封装到一个 NSOperation 对象中。</li>\n<li>将此任务添加到一个 NSOperationQueue 对象中。</li>\n</ol>\n<p>然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>\n<h3 id=\"添加任务\"><a href=\"#添加任务\" class=\"headerlink\" title=\"添加任务\"></a>添加任务</h3><p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>\n<ul>\n<li>NSInvocationOperation: 需要传入一个方法名</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSInvocationOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSInvocationOperation</span> *operation = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始执行</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSBlockOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">  &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 <strong>会并发执行</strong>，它会 <strong>在主线程和其它的多个线程</strong> 执行这些任务，注意下面的打印结果：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加多个Block</span></span><br><span class=\"line\"><span class=\"comment\">//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p><strong>打印：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787013</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787049</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510788</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f6c0</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510791</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x<span class=\"number\">600000463100</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787179</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787181</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义Operation</li>\n</ul>\n<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。</p>\n<h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 <strong>同步执行</strong> 的。就算是 addExecutionBlock 方法，也会在 <strong>当前线程和其他线程 </strong>中执行，也就是说还是会占用当前线程。这是就要用到队列 <strong>NSOperationQueue</strong> 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。<strong>只要添加到队列，会自动调用任务的 start() 方法</strong></p>\n<ul>\n<li>主队列</li>\n</ul>\n<p>每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [<span class=\"built_in\">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他队列</li>\n</ul>\n<p>因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>\n<p>注意：其他队列的任务会在其他线程并行执行。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建一个其他队列    </span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.添加多个Block</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.队列添加任务</span></span><br><span class=\"line\">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n<p>打印</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806408</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806410</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806417</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552317</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x60400027bf00&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552307</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271280</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806668</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806673</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题：</strong>将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>\n<p><strong>答：</strong>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛</p>\n<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>\n<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.任务一：下载图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.任务二：打水印</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打水印   - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.任务三：上传图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"上传图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.设置依赖</span></span><br><span class=\"line\">[operation2 addDependency:operation1];      <span class=\"comment\">//任务二依赖任务一</span></span><br><span class=\"line\">[operation3 addDependency:operation2];      <span class=\"comment\">//任务三依赖任务二</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5.创建队列并加入任务</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>打印</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637517</span>] 下载图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10ad4d970&gt;&#123;number = <span class=\"number\">2</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 打水印 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 上传图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。</li>\n<li>可以使用 removeDependency 来解除依赖关系。</li>\n<li>可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</li>\n</ul>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>\n<ul>\n<li>NSOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> executing; <span class=\"comment\">//判断任务是否正在执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> finished; <span class=\"comment\">//判断任务是否完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> (^completionBlock)(<span class=\"keyword\">void</span>); <span class=\"comment\">//用来设置完成后需要执行的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel; <span class=\"comment\">//取消任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilFinished; <span class=\"comment\">//阻塞当前线程直到此任务执行完毕</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUInteger</span> operationCount; <span class=\"comment\">//获取队列的任务数</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancelAllOperations; <span class=\"comment\">//取消队列中所有的任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilAllOperationsAreFinished; <span class=\"comment\">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">YES</span>]; <span class=\"comment\">// 暂停queue</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">NO</span>]; <span class=\"comment\">// 继续queue</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的原理\"><a href=\"#多线程的原理\" class=\"headerlink\" title=\"多线程的原理\"></a>多线程的原理</h2><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>\n<ul>\n<li><p><strong>问题：</strong>如果线程非常非常多，会发生什么情况？</p>\n</li>\n<li><p><strong>答：</strong>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）</p>\n</li>\n</ul>\n<p>多线程的优点</p>\n<ul>\n<li>能适当提高程序的执行效率；</li>\n<li>能适当提高资源利用率（CPU、内存利用率）</li>\n</ul>\n<p>多线程的缺点</p>\n<ul>\n<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>\n<li>线程越多，CPU在调度线程上的开销就越大</li>\n<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>\n</ul>\n<h2 id=\"多线程的应用（个别案例）\"><a href=\"#多线程的应用（个别案例）\" class=\"headerlink\" title=\"多线程的应用（个别案例）\"></a>多线程的应用（个别案例）</h2><h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><p>线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>\n<ul>\n<li><strong>互斥锁 ：</strong>给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">  /<span class=\"regexp\">/需要执行的代码块</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>同步执行 ：</strong>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GCD</span></span><br><span class=\"line\"><span class=\"comment\">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">0.1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NSOperation &amp; NSOperationQueue</span></span><br><span class=\"line\"><span class=\"comment\">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中</span></span><br><span class=\"line\"><span class=\"comment\">//       2. 设置 queue 的 maxConcurrentOperationCount 为 1</span></span><br><span class=\"line\"><span class=\"comment\">//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[queue addOperation:operation];</span><br><span class=\"line\"></span><br><span class=\"line\">[operation waitUntilFinished];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后续要做的事</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><p>延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>\n<ul>\n<li>perform</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// <span class=\"number\">3</span>秒后自动调用self的<span class=\"keyword\">run</span><span class=\"bash\">:方法，并且传递参数：@<span class=\"string\">\"abc\"</span></span></span><br><span class=\"line\"><span class=\"bash\">[self performSelector:@selector(run:) withObject:@<span class=\"string\">\"abc\"</span> afterDelay:3];</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列</span></span><br><span class=\"line\"><span class=\"keyword\">dispatch_queue_t</span> <span class=\"built_in\">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置延时，单位秒</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> delay = <span class=\"number\">3</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class=\"keyword\">int64_t</span>)(delay * NSEC_PER_SEC)), <span class=\"built_in\">queue</span>, ^&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 3秒后需要执行的任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSTimer</li>\n</ul>\n<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">3.0</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">userInfo:</span>@<span class=\"string\">\"abc\"</span> <span class=\"string\">repeats:</span>NO];</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface HbhNetWorkManager : NSObject &lt;NSCopying&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) AFHTTPSessionManager *manager<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  单例</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return HbhNetWorkManager</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static </span>HbhNetWorkManager *<span class=\"keyword\">shareInstance </span>= nil<span class=\"comment\">;</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance&#123;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   static <span class=\"keyword\">dispatch_once_t </span>onceToken<span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"keyword\">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">shareInstance=[[HbhNetWorkManager </span>alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;)<span class=\"comment\">;</span></span><br><span class=\"line\">    return <span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从其他线程回到主线程的方法\"><a href=\"#从其他线程回到主线程的方法\" class=\"headerlink\" title=\"从其他线程回到主线程的方法\"></a>从其他线程回到主线程的方法</h3><ul>\n<li>NSThread</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Objective-C</span></span><br><span class=\"line\">[self <span class=\"string\">performSelectorOnMainThread:</span><span class=\"meta\">@selector</span>(run) <span class=\"string\">withObject:</span>nil <span class=\"string\">waitUntilDone:</span>NO];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"comment\">//swift 取消了 performSelector 方法。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Objective-C</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//Swift</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), &#123; () -&gt; Void in</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Objective-C</span><br><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span>.mainQueue().addOperationWithBlock &#123; () -&gt; Void <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的选择（更倾向于哪一种？）\"><a href=\"#多线程的选择（更倾向于哪一种？）\" class=\"headerlink\" title=\"多线程的选择（更倾向于哪一种？）\"></a>多线程的选择（更倾向于哪一种？）</h2><p>倾向于GCD</p>\n<p>因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jianshu.com/p/0b0d9b1f1f19\" target=\"_blank\" rel=\"noopener\">这里有一篇文章写的非常好，推荐。</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 iOS 中其实目前有 4 套多线程方案，他们分别是：</p>\n<ol>\n<li>Pthreads</li>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation &amp; NSOperationQueue</li>\n</ol>\n<h2 id=\"Pthreads\"><a href=\"#Pthreads\" class=\"headerlink\" title=\"Pthreads\"></a>Pthreads</h2><p><strong>特点：</strong></p>\n<ul>\n<li>一套通用的多线程API</li>\n<li>适用于Unix\\Linux\\Windows等系统</li>\n<li>跨平台\\可移植</li>\n<li>使用难度大</li>\n</ul>\n<p><strong>使用语言：</strong>基于 c语言 的框架</p>\n<p><strong>使用频率：</strong>几乎不用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<h2 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h2><p><strong>特点：</strong></p>\n<ul>\n<li>使用更加面向对象</li>\n<li>简单易用，可直接操作线程对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>偶尔使用</p>\n<p><strong>线程生命周期：</strong>由程序员手动进行管理</p>\n<p>这套方案是经过苹果封装后的，并且完全面向对象的。所以你可以直接操控线程对象，非常直观和方便，是轻量级最低的（优点）。但是，它的生命周期还是需要我们手动管理（缺点），所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>先创建线程类，再启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建</span></span><br><span class=\"line\">NSThread *thread = [[NSThread alloc] <span class=\"string\">initWithTarget:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">object:</span>nil];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动</span></span><br><span class=\"line\">[thread start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSThread <span class=\"string\">detachNewThreadSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">toTarget:</span>self <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用 NSObject 的方法创建并自动启动</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self <span class=\"string\">performSelectorInBackground:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p><strong>特点:</strong></p>\n<ul>\n<li>旨在替代NSThread等线程技术</li>\n<li>充分利用设备的多核（自动）</li>\n</ul>\n<p><strong>使用语言：</strong>C语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>它是苹果为多核的并行运算提出的解决方案，所以会自动合理地利用更多的CPU内核（比如双核、四核），最重要的是它会自动管理线程的生命周期（创建线程、调度任务、销毁线程），完全不需要我们管理，我们只需要告诉干什么就行。同时它使用的也是 c语言，不过由于使用了 Block（Swift里叫做闭包），使得使用起来更加方便，而且灵活。所以基本上大家都使用 GCD 这套方案。</p>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p><strong>特点:</strong></p>\n<ul>\n<li>基于GCD（底层是GCD）</li>\n<li>比GCD多了一些更简单实用的功能</li>\n<li>使用更加面向对象</li>\n</ul>\n<p><strong>使用语言：</strong>OC语言</p>\n<p><strong>使用频率：</strong>经常使用</p>\n<p><strong>线程生命周期：</strong>自动管理</p>\n<p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，所以使用起来更好理解。 大家可以看到 NSOperation 和 NSOperationQueue 分别对应 GCD 的 任务 和 队列 。操作步骤也很好理解：</p>\n<ol>\n<li>将要执行的任务封装到一个 NSOperation 对象中。</li>\n<li>将此任务添加到一个 NSOperationQueue 对象中。</li>\n</ol>\n<p>然后系统就会自动在执行任务。至于同步还是异步、串行还是并行请继续往下看：</p>\n<h3 id=\"添加任务\"><a href=\"#添加任务\" class=\"headerlink\" title=\"添加任务\"></a>添加任务</h3><p>值得说明的是，NSOperation 只是一个抽象类，所以不能封装任务。但它有 2 个子类用于封装任务。分别是：NSInvocationOperation 和 NSBlockOperation 。创建一个 Operation 后，需要调用 start 方法来启动任务，它会 默认在当前队列同步执行。当然你也可以在中途取消一个任务，只需要调用其 cancel 方法即可。</p>\n<ul>\n<li>NSInvocationOperation: 需要传入一个方法名</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSInvocationOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSInvocationOperation</span> *operation = [[<span class=\"built_in\">NSInvocationOperation</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始执行</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSBlockOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">  &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p>之前说过这样的任务，默认会在当前线程执行。但是 NSBlockOperation 还有一个方法：addExecutionBlock: ，通过这个方法可以给 Operation 添加多个执行 Block。这样 Operation 中的任务 <strong>会并发执行</strong>，它会 <strong>在主线程和其它的多个线程</strong> 执行这些任务，注意下面的打印结果：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加多个Block</span></span><br><span class=\"line\"><span class=\"comment\">//addExecutionBlock 方法必须在 start() 方法之前执行，否则就会报错。</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.开始任务</span></span><br><span class=\"line\">[operation start];</span><br></pre></td></tr></table></figure>\n<p><strong>打印：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787013</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787049</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510788</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f6c0</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30</span>:<span class=\"number\">29.787050</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510791</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x<span class=\"number\">600000463100</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787179</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510678</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000262e00</span>&gt;&#123;number = <span class=\"number\">1</span>, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">16</span>:<span class=\"number\">30:29.787181</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75340</span>:<span class=\"number\">4510790</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x604<span class=\"number\">00046f700</span>&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自定义Operation</li>\n</ul>\n<p>除了上面的两种 Operation 以外，我们还可以自定义 Operation。自定义 Operation 需要继承 NSOperation 类，并实现其 main() 方法，因为在调用 start() 方法的时候，内部会调用 main() 方法完成相关逻辑。所以如果以上的两个类无法满足你的欲望的时候，你就需要自定义了。你想要实现什么功能都可以写在里面。除此之外，你还需要实现 cancel() 在内的各种方法。</p>\n<h3 id=\"创建队列\"><a href=\"#创建队列\" class=\"headerlink\" title=\"创建队列\"></a>创建队列</h3><p>看过上面的内容就知道，我们可以调用一个 NSOperation 对象的 start() 方法来启动这个任务，但是这样做他们默认是 <strong>同步执行</strong> 的。就算是 addExecutionBlock 方法，也会在 <strong>当前线程和其他线程 </strong>中执行，也就是说还是会占用当前线程。这是就要用到队列 <strong>NSOperationQueue</strong> 了。而且，按类型来说的话一共有两种类型：主队列、其他队列。<strong>只要添加到队列，会自动调用任务的 start() 方法</strong></p>\n<ul>\n<li>主队列</li>\n</ul>\n<p>每套多线程方案都会有一个主线程（当然啦，说的是iOS中，像 pthread 这种多系统的方案并没有，因为 UI线程 理论需要每种操作系统自己定制）。这是一个特殊的线程，必须串行。所以添加到主队列的任务都会一个接一个地排着队在主线程处理。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [<span class=\"built_in\">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他队列</li>\n</ul>\n<p>因为主队列比较特殊，所以会单独有一个类方法来获得主队列。那么通过初始化产生的队列就是其他队列了，因为只有这两种队列，除了主队列，其他队列就不需要名字了。</p>\n<p>注意：其他队列的任务会在其他线程并行执行。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.创建一个其他队列    </span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.创建NSBlockOperation对象</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.添加多个Block</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    [operation addExecutionBlock:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"第%ld次：%@\"</span>, i, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.队列添加任务</span></span><br><span class=\"line\">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n<p>打印</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806408</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">1</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806410</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">0</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806417</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552317</span>] 第<span class=\"number\">2</span>次：&lt;NSThread: <span class=\"number\">0</span>x60400027bf00&gt;&#123;number = <span class=\"number\">4</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552307</span>] &lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271280</span>&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806668</span>+<span class=\"number\">0800</span> Runtime[<span class=\"number\">75459</span>:<span class=\"number\">4552309</span>] 第<span class=\"number\">3</span>次：&lt;NSThread: <span class=\"number\">0</span>x60<span class=\"number\">00002712c0</span>&gt;&#123;number = <span class=\"number\">5</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">17</span>:<span class=\"number\">49</span>:<span class=\"number\">25.806673</span>+<span class=\"number\">0800</span> model[<span class=\"number\">75459</span>:<span class=\"number\">4552310</span>] 第<span class=\"number\">4</span>次：&lt;NSThread: <span class=\"number\">0</span>x6<span class=\"number\">00000271300</span>&gt;&#123;number = <span class=\"number\">6</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题：</strong>将 NSOperationQueue 与 GCD的队列 相比较就会发现，这里没有串行队列，那如果我想要10个任务在其他线程串行的执行怎么办？</p>\n<p><strong>答：</strong>这就是苹果封装的妙处，你不用管串行、并行、同步、异步这些名词。NSOperationQueue 有一个参数 maxConcurrentOperationCount 最大并发数，用来设置最多可以让多少个任务同时执行。当你把它设置为 1 的时候，他不就是串行了嘛</p>\n<p>NSOperationQueue 还有一个添加任务的方法，- (void)addOperationWithBlock:(void (^)(void))block; ，这是不是和 GCD 差不多？这样就可以添加一个任务到队列中了，十分方便。</p>\n<p>NSOperation 有一个非常实用的功能，那就是添加依赖。比如有 3 个任务：A: 从服务器上下载一张图片，B：给这张图片加个水印，C：把图片返回给服务器。这时就可以用到依赖了:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.任务一：下载图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation1 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"下载图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2.任务二：打水印</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation2 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"打水印   - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3.任务三：上传图片</span></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation3 = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"上传图片 - %@\"</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1.0</span>];</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4.设置依赖</span></span><br><span class=\"line\">[operation2 addDependency:operation1];      <span class=\"comment\">//任务二依赖任务一</span></span><br><span class=\"line\">[operation3 addDependency:operation2];      <span class=\"comment\">//任务三依赖任务二</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5.创建队列并加入任务</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span> *queue = [[<span class=\"built_in\">NSOperationQueue</span> alloc] init];</span><br><span class=\"line\">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n<p><strong>打印</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637517</span>] 下载图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10ad4d970&gt;&#123;number = <span class=\"number\">2</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 打水印 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2017-11-18</span> <span class=\"number\">18</span>:<span class=\"number\">01</span>:<span class=\"number\">25.806424</span>+<span class=\"number\">0800</span> model[<span class=\"number\">19392</span>:<span class=\"number\">4637515</span>] 上传图片 - &lt;NSThread: <span class=\"number\">0</span>x7fc10af20ef0&gt;&#123;number = <span class=\"number\">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。</li>\n<li>可以使用 removeDependency 来解除依赖关系。</li>\n<li>可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。</li>\n</ul>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>以上就是一些主要方法, 下面还有一些常用方法需要大家注意：</p>\n<ul>\n<li>NSOperation</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">BOOL</span> executing; <span class=\"comment\">//判断任务是否正在执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> finished; <span class=\"comment\">//判断任务是否完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> (^completionBlock)(<span class=\"keyword\">void</span>); <span class=\"comment\">//用来设置完成后需要执行的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancel; <span class=\"comment\">//取消任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilFinished; <span class=\"comment\">//阻塞当前线程直到此任务执行完毕</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSUInteger</span> operationCount; <span class=\"comment\">//获取队列的任务数</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)cancelAllOperations; <span class=\"comment\">//取消队列中所有的任务</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUntilAllOperationsAreFinished; <span class=\"comment\">//阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">YES</span>]; <span class=\"comment\">// 暂停queue</span></span><br><span class=\"line\"></span><br><span class=\"line\">[queue setSuspended:<span class=\"literal\">NO</span>]; <span class=\"comment\">// 继续queue</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的原理\"><a href=\"#多线程的原理\" class=\"headerlink\" title=\"多线程的原理\"></a>多线程的原理</h2><p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p>\n<ul>\n<li><p><strong>问题：</strong>如果线程非常非常多，会发生什么情况？</p>\n</li>\n<li><p><strong>答：</strong>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）</p>\n</li>\n</ul>\n<p>多线程的优点</p>\n<ul>\n<li>能适当提高程序的执行效率；</li>\n<li>能适当提高资源利用率（CPU、内存利用率）</li>\n</ul>\n<p>多线程的缺点</p>\n<ul>\n<li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li>\n<li>线程越多，CPU在调度线程上的开销就越大</li>\n<li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>\n</ul>\n<h2 id=\"多线程的应用（个别案例）\"><a href=\"#多线程的应用（个别案例）\" class=\"headerlink\" title=\"多线程的应用（个别案例）\"></a>多线程的应用（个别案例）</h2><h3 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h3><p>线程同步就是为了防止多个线程抢夺同一个资源造成的数据安全问题，所采取的一种措施。当然也有很多实现方法，请往下看：</p>\n<ul>\n<li><strong>互斥锁 ：</strong>给需要同步的代码块加一个互斥锁，就可以保证每次只有一个线程访问此代码块。</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@synchronized</span>(<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">  /<span class=\"regexp\">/需要执行的代码块</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>同步执行 ：</strong>我们可以使用多线程的知识，把多个线程都要执行此段代码添加到同一个串行队列，这样就实现了线程同步的概念。这里可以使用 GCD 和 NSOperation 两种方案:</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GCD</span></span><br><span class=\"line\"><span class=\"comment\">//需要一个全局变量queue，要让所有线程的这个操作都加到一个queue中</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">0.1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NSOperation &amp; NSOperationQueue</span></span><br><span class=\"line\"><span class=\"comment\">//重点：1. 全局的 NSOperationQueue, 所有的操作添加到同一个queue中</span></span><br><span class=\"line\"><span class=\"comment\">//       2. 设置 queue 的 maxConcurrentOperationCount 为 1</span></span><br><span class=\"line\"><span class=\"comment\">//       3. 如果后续操作需要Block中的结果，就需要调用每个操作的waitUntilFinished，阻塞当前线程，一直等到当前操作完成，才允许执行后面的。waitUntilFinished 要在添加到队列之后！</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSBlockOperation</span> *operation = [<span class=\"built_in\">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> ticket = lastTicket;</span><br><span class=\"line\">    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval:<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%ld - %@\"</span>,ticket, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    ticket -= <span class=\"number\">1</span>;</span><br><span class=\"line\">    lastTicket = ticket;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[queue addOperation:operation];</span><br><span class=\"line\"></span><br><span class=\"line\">[operation waitUntilFinished];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//后续要做的事</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><p>延迟执行就是延时一段时间再执行某段代码。下面说一些常用方法。</p>\n<ul>\n<li>perform</li>\n</ul>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// <span class=\"number\">3</span>秒后自动调用self的<span class=\"keyword\">run</span><span class=\"bash\">:方法，并且传递参数：@<span class=\"string\">\"abc\"</span></span></span><br><span class=\"line\"><span class=\"bash\">[self performSelector:@selector(run:) withObject:@<span class=\"string\">\"abc\"</span> afterDelay:3];</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<p>可以使用 GCD 中的 dispatch_after 方法，OC 和 Swift 都可以使用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列</span></span><br><span class=\"line\"><span class=\"keyword\">dispatch_queue_t</span> <span class=\"built_in\">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置延时，单位秒</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> delay = <span class=\"number\">3</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class=\"keyword\">int64_t</span>)(delay * NSEC_PER_SEC)), <span class=\"built_in\">queue</span>, ^&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 3秒后需要执行的任务</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSTimer</li>\n</ul>\n<p>NSTimer 是iOS中的一个计时器类，除了延迟执行还有很多用法</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSTimer <span class=\"string\">scheduledTimerWithTimeInterval:</span><span class=\"number\">3.0</span> <span class=\"string\">target:</span>self <span class=\"string\">selector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">run:</span>) <span class=\"string\">userInfo:</span>@<span class=\"string\">\"abc\"</span> <span class=\"string\">repeats:</span>NO];</span><br></pre></td></tr></table></figure>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface HbhNetWorkManager : NSObject &lt;NSCopying&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) AFHTTPSessionManager *manager<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  单例</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  @return HbhNetWorkManager</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"><span class=\"keyword\"></span></span><br><span class=\"line\"><span class=\"keyword\">static </span>HbhNetWorkManager *<span class=\"keyword\">shareInstance </span>= nil<span class=\"comment\">;</span></span><br><span class=\"line\">+(<span class=\"keyword\">instancetype) </span><span class=\"keyword\">shareInstance&#123;</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>   static <span class=\"keyword\">dispatch_once_t </span>onceToken<span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"keyword\">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">shareInstance=[[HbhNetWorkManager </span>alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\">    &#125;)<span class=\"comment\">;</span></span><br><span class=\"line\">    return <span class=\"keyword\">shareInstance;</span></span><br><span class=\"line\"><span class=\"keyword\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从其他线程回到主线程的方法\"><a href=\"#从其他线程回到主线程的方法\" class=\"headerlink\" title=\"从其他线程回到主线程的方法\"></a>从其他线程回到主线程的方法</h3><ul>\n<li>NSThread</li>\n</ul>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Objective-C</span></span><br><span class=\"line\">[self <span class=\"string\">performSelectorOnMainThread:</span><span class=\"meta\">@selector</span>(run) <span class=\"string\">withObject:</span>nil <span class=\"string\">waitUntilDone:</span>NO];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"comment\">//swift 取消了 performSelector 方法。</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>GCD</li>\n</ul>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Objective-C</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)<span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//Swift</span><br><span class=\"line\">dispatch_async(<span class=\"name\">dispatch_get_main_queue</span>(), &#123; () -&gt; Void in</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>NSOperationQueue</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Objective-C</span><br><span class=\"line\">[[<span class=\"built_in\">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Swift</span></span><br><span class=\"line\"><span class=\"built_in\">NSOperationQueue</span>.mainQueue().addOperationWithBlock &#123; () -&gt; Void <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程的选择（更倾向于哪一种？）\"><a href=\"#多线程的选择（更倾向于哪一种？）\" class=\"headerlink\" title=\"多线程的选择（更倾向于哪一种？）\"></a>多线程的选择（更倾向于哪一种？）</h2><p>倾向于GCD</p>\n<p>因为GCD是用来解决多核编程问题的，会自动合理的利用更多的CPU内核，可以通过GCD和block轻松实现多线程编程，更加有效。但有时候最优的不是GCD，还有一种多线程技术NSOperationQueue，它能够将后台线程以队列方式依序执行，并提供更多操作入口，类似GCD，在NSOperationQueue中，可以随时取消已设定要准备执行的任务，而GCD没法停止已加入queue的block。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.jianshu.com/p/0b0d9b1f1f19\" target=\"_blank\" rel=\"noopener\">这里有一篇文章写的非常好，推荐。</a></p>\n"},{"title":"如何清空view上的所有子视图","date":"2016-12-03T09:22:09.000Z","description":"本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法","_content":"本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法\n## removeFromSuperview方法\n\n首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：\n\n* Unlinks the receiver from its superview and its window,\nand removes it from the responder chain.\n\n\n* 译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 \n\n\n调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for...in...的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果\n\n```\nfor (UIView *view in [self.view subviews]) {\n\n        [view removeFromSuperview];\n    }\n```\n\n\n\n 注意：\n 1. 永远不要在你的view的drawRect方法中调用removeFromSuperview；\n 2. removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。\n\n## makeObjectsPerformSelector\n\n```\n- (void)makeObjectsPerformSelector:(SEL)aSelector;  \n- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument; \n```\n介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector\n\n一行搞定删除子视图\n\n```\n[self.view.sublayers makeObjectsPerformSelector:@selector(removeFromSuperview)];\n```\n\n带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@YES];  \n```\n这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。\n\n但是若想设置为NO的话，则无效（亲测）。\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@NO];  \n```\n这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看[这里](https://www.cnblogs.com/Apologize/p/5383652.html)。\n\n但是可以用nil达到参数为NO的效果\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:nil];  \n```\n## enumerator ##\n\n```\n- (void)enumerateObjectsUsingBlock:block;\n```\n这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），*stop可以控制遍历何时停止，在需要停止时令*stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。\n\n```\nNSArray *xpArray = @[@\"A\", @\"B\", @\"C\", @\"D\", @\"E\"];\n    \n    [xpArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        \n        NSLog(@\"%@\", obj);\n        \n        if ([obj isEqualToString:@\"C\"]) {\n            \n            *stop = YES;\n        }\n    }];\n```\n不过反向遍历呢？苹果提供了另外一个方法：\n\n```\n[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id obj, NSUInteger idx, BOOLBOOL *stop) {  \n    NSLog(@\"idx=%d, id=%@\", idx, obj);  \n}]; \n```\n这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。\n\n注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。\n","source":"_posts/如何清空view上的所有子视图.md","raw":"---\ntitle: 如何清空view上的所有子视图\ndate: 2016-12-03 17:22:09\ndescription: 本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法\ncategories: iOS\ntags: [Objective-C]\n---\n本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法\n## removeFromSuperview方法\n\n首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：\n\n* Unlinks the receiver from its superview and its window,\nand removes it from the responder chain.\n\n\n* 译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 \n\n\n调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for...in...的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果\n\n```\nfor (UIView *view in [self.view subviews]) {\n\n        [view removeFromSuperview];\n    }\n```\n\n\n\n 注意：\n 1. 永远不要在你的view的drawRect方法中调用removeFromSuperview；\n 2. removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。\n\n## makeObjectsPerformSelector\n\n```\n- (void)makeObjectsPerformSelector:(SEL)aSelector;  \n- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument; \n```\n介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector\n\n一行搞定删除子视图\n\n```\n[self.view.sublayers makeObjectsPerformSelector:@selector(removeFromSuperview)];\n```\n\n带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@YES];  \n```\n这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。\n\n但是若想设置为NO的话，则无效（亲测）。\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:@NO];  \n```\n这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看[这里](https://www.cnblogs.com/Apologize/p/5383652.html)。\n\n但是可以用nil达到参数为NO的效果\n\n```\n[arry makeObjectsPerformSelector:@selector(setHidden:) withObject:nil];  \n```\n## enumerator ##\n\n```\n- (void)enumerateObjectsUsingBlock:block;\n```\n这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），*stop可以控制遍历何时停止，在需要停止时令*stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。\n\n```\nNSArray *xpArray = @[@\"A\", @\"B\", @\"C\", @\"D\", @\"E\"];\n    \n    [xpArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        \n        NSLog(@\"%@\", obj);\n        \n        if ([obj isEqualToString:@\"C\"]) {\n            \n            *stop = YES;\n        }\n    }];\n```\n不过反向遍历呢？苹果提供了另外一个方法：\n\n```\n[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id obj, NSUInteger idx, BOOLBOOL *stop) {  \n    NSLog(@\"idx=%d, id=%@\", idx, obj);  \n}]; \n```\n这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。\n\n注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。\n","slug":"如何清空view上的所有子视图","published":1,"updated":"2018-04-18T12:19:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjg52i3jx00104hfb7f78seb4","content":"<p>本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法</p>\n<h2 id=\"removeFromSuperview方法\"><a href=\"#removeFromSuperview方法\" class=\"headerlink\" title=\"removeFromSuperview方法\"></a>removeFromSuperview方法</h2><p>首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：</p>\n<ul>\n<li>Unlinks the receiver from its superview and its window,<br>and removes it from the responder chain.</li>\n</ul>\n<ul>\n<li>译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 </li>\n</ul>\n<p>调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for…in…的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (UIView *<span class=\"built_in\">view</span> <span class=\"keyword\">in</span> [self.<span class=\"built_in\">view</span> subviews]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"built_in\">view</span> removeFromSuperview];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p> 注意：</p>\n<ol>\n<li>永远不要在你的view的drawRect方法中调用removeFromSuperview；</li>\n<li>removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。</li>\n</ol>\n<h2 id=\"makeObjectsPerformSelector\"><a href=\"#makeObjectsPerformSelector\" class=\"headerlink\" title=\"makeObjectsPerformSelector\"></a>makeObjectsPerformSelector</h2><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector;  </span><br><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector withObject:<span class=\"params\">(id)</span>argument;</span><br></pre></td></tr></table></figure>\n<p>介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector</p>\n<p>一行搞定删除子视图</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">self.view.sublayers</span> makeObjectsPerformSelector:@selector(<span class=\"name\">removeFromSuperview</span>)]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。</p>\n<p>但是若想设置为NO的话，则无效（亲测）。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@NO</span>];</span><br></pre></td></tr></table></figure>\n<p>这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看<a href=\"https://www.cnblogs.com/Apologize/p/5383652.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>但是可以用nil达到参数为NO的效果</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"enumerator\"><a href=\"#enumerator\" class=\"headerlink\" title=\"enumerator\"></a>enumerator</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">enumerateObjectsUsingBlock:</span>block;</span><br></pre></td></tr></table></figure>\n<p>这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），<em>stop可以控制遍历何时停止，在需要停止时令</em>stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *xpArray = @[<span class=\"string\">@\"A\"</span>, <span class=\"string\">@\"B\"</span>, <span class=\"string\">@\"C\"</span>, <span class=\"string\">@\"D\"</span>, <span class=\"string\">@\"E\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [xpArray enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, obj);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"C\"</span>]) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>不过反向遍历呢？苹果提供了另外一个方法：</p>\n<figure class=\"highlight hy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(<span class=\"name\"><span class=\"builtin-name\">id</span></span> obj, NSUInteger idx, BOOLBOOL *stop) &#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"idx=%d, id=%@\"</span>, idx, obj)<span class=\"comment\">;  </span></span><br><span class=\"line\">&#125;]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。</p>\n<p>注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文以删除view上的所有子视图为例，重点讲的是NSSet和NSArray的makeObjectsPerformSelector方法和enumerator方法</p>\n<h2 id=\"removeFromSuperview方法\"><a href=\"#removeFromSuperview方法\" class=\"headerlink\" title=\"removeFromSuperview方法\"></a>removeFromSuperview方法</h2><p>首先来看看常用的removeFromSuperview方法，下面是苹果官方定义：</p>\n<ul>\n<li>Unlinks the receiver from its superview and its window,<br>and removes it from the responder chain.</li>\n</ul>\n<ul>\n<li>译： 把接收者（当前view）从它的父视图移除，并删除它的响应链。 </li>\n</ul>\n<p>调用removeFromSuperview方法会将当前视图从其父视图移除。（注意：只是将自己从俯视图移除，以前总是误以为将自己所有自视图从俯视图移除）所以用for…in…的方法，取到每一个subview，让他们执行removeFromSuperView就可以达到效果</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (UIView *<span class=\"built_in\">view</span> <span class=\"keyword\">in</span> [self.<span class=\"built_in\">view</span> subviews]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        [<span class=\"built_in\">view</span> removeFromSuperview];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p> 注意：</p>\n<ol>\n<li>永远不要在你的view的drawRect方法中调用removeFromSuperview；</li>\n<li>removeFromSuperview的实质并不是将这个视图从内存中移除,而是将一个视图从他的父视图上删除。计算机删除的本质是，标记删除，当你删除一个东西的时候，系统只是将这块内存做了一个标记，表示目前无人使用，但是之前视图的内存地址存在。所以如果想让视图不存在，需要在移除之后置为nil。</li>\n</ol>\n<h2 id=\"makeObjectsPerformSelector\"><a href=\"#makeObjectsPerformSelector\" class=\"headerlink\" title=\"makeObjectsPerformSelector\"></a>makeObjectsPerformSelector</h2><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector;  </span><br><span class=\"line\">- <span class=\"params\">(void)</span>makeObjectsPerformSelector:<span class=\"params\">(SEL)</span>aSelector withObject:<span class=\"params\">(id)</span>argument;</span><br></pre></td></tr></table></figure>\n<p>介绍：让数组中的每个元素 都调用 aSelector  并把 withObject 后边的 argument 对象做为参数传给方法aSelector</p>\n<p>一行搞定删除子视图</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">self.view.sublayers</span> makeObjectsPerformSelector:@selector(<span class=\"name\">removeFromSuperview</span>)]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>带参数方法的使用：如果一个数组arry中存储了一组有hidden属性的对象（假设为view），需要将数组里所有对象的hide全部赋值为真，就可以这么写：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@YES</span>];</span><br></pre></td></tr></table></figure>\n<p>这么写就相当于arry数组里面的每一个对象都调用了setHidden方法，并且参数为YES，不用再遍历，一行代码搞定，是不是很方便。</p>\n<p>但是若想设置为NO的话，则无效（亲测）。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span><span class=\"meta\">@NO</span>];</span><br></pre></td></tr></table></figure>\n<p>这是因为YES和NO都为BOOL类型，设置为YES时，传递的为非0的指针，所以会设置 view.hidden = YES，但若设置为NO时，传递的仍为非0的指针，所以执行的结果仍是 view.hidden = YES。具体可看<a href=\"https://www.cnblogs.com/Apologize/p/5383652.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>但是可以用nil达到参数为NO的效果</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[arry <span class=\"string\">makeObjectsPerformSelector:</span><span class=\"meta\">@selector</span>(<span class=\"string\">setHidden:</span>) <span class=\"string\">withObject:</span>nil];</span><br></pre></td></tr></table></figure>\n<h2 id=\"enumerator\"><a href=\"#enumerator\" class=\"headerlink\" title=\"enumerator\"></a>enumerator</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"string\">enumerateObjectsUsingBlock:</span>block;</span><br></pre></td></tr></table></figure>\n<p>这个方法也是遍历数组，block里面的参数包括obj（运行的对象）、idx（下标）、stop（是否继续遍历的标志），<em>stop可以控制遍历何时停止，在需要停止时令</em>stop = YES即可（不要忘记前面的**），应该说，这个能满足基本所有的遍历需求了，有下标，有运行的对象，还有是否继续遍历的标志。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span> *xpArray = @[<span class=\"string\">@\"A\"</span>, <span class=\"string\">@\"B\"</span>, <span class=\"string\">@\"C\"</span>, <span class=\"string\">@\"D\"</span>, <span class=\"string\">@\"E\"</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [xpArray enumerateObjectsUsingBlock:^(<span class=\"keyword\">id</span>  _Nonnull obj, <span class=\"built_in\">NSUInteger</span> idx, <span class=\"built_in\">BOOL</span> * _Nonnull stop) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>, obj);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ([obj isEqualToString:<span class=\"string\">@\"C\"</span>]) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            *stop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>不过反向遍历呢？苹果提供了另外一个方法：</p>\n<figure class=\"highlight hy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[xpArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(<span class=\"name\"><span class=\"builtin-name\">id</span></span> obj, NSUInteger idx, BOOLBOOL *stop) &#123;  </span><br><span class=\"line\">    NSLog(@<span class=\"string\">\"idx=%d, id=%@\"</span>, idx, obj)<span class=\"comment\">;  </span></span><br><span class=\"line\">&#125;]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这个enumerateObjectsWithOptions:usingBlock:方法比前面那个方法多了一个枚举类型的参数NSEnumerationReverse，这个参数指定了遍历的顺序。</p>\n<p>注意：这里要补充一点，这个方法是可以修改块签名，当我们已经明确集合中的元素类型时，可以把默认的签名id类型修改成已知类型，比如常见的NSString，这样既可以节省系统资源开销，也可以防止误向对象发送不存在的方法是引起的崩溃。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjg52i3id00004hfbzknms9fk","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3jc000e4hfb9oave1q9"},{"post_id":"cjg52i3j000074hfbujr7aben","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3jg000j4hfbpd884l7w"},{"post_id":"cjg52i3j6000b4hfbzipgfbvc","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3jj000m4hfbthg5tbe8"},{"post_id":"cjg52i3im00024hfb5glkqce2","category_id":"cjg52i3j200084hfbyevhgscp","_id":"cjg52i3jp000r4hfbafdk0pyy"},{"post_id":"cjg52i3ja000d4hfb04yz0x5y","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3js000u4hfbm98qq902"},{"post_id":"cjg52i3je000i4hfbpx7heewa","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3jw000y4hfb3zb6osid"},{"post_id":"cjg52i3iv00054hfbp7k025h7","category_id":"cjg52i3jd000g4hfb78h1trn5","_id":"cjg52i3jz00114hfbs3rl65ps"},{"post_id":"cjg52i3jh000l4hfbgoz1vssn","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3k100144hfbbrp9wxoi"},{"post_id":"cjg52i3jl000q4hfbv43zo8wn","category_id":"cjg52i3j200084hfbyevhgscp","_id":"cjg52i3k200164hfbdyu9iy3c"},{"post_id":"cjg52i3iy00064hfbyewjh5tn","category_id":"cjg52i3jd000g4hfb78h1trn5","_id":"cjg52i3k300194hfbwo922t1w"},{"post_id":"cjg52i3jq000t4hfbzraj3f5v","category_id":"cjg52i3jd000g4hfb78h1trn5","_id":"cjg52i3k4001b4hfb4xei4h6n"},{"post_id":"cjg52i3ju000x4hfb7rv68v8r","category_id":"cjg52i3ir00034hfbpoqjia7v","_id":"cjg52i3k4001d4hfbjx045qfd"},{"post_id":"cjg52i3jx00104hfb7f78seb4","category_id":"cjg52i3jd000g4hfb78h1trn5","_id":"cjg52i3k5001f4hfbw08cdrk7"}],"PostTag":[{"post_id":"cjg52i3iy00064hfbyewjh5tn","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3j6000a4hfbe7bgbofb"},{"post_id":"cjg52i3id00004hfbzknms9fk","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3j9000c4hfbuuiirgb2"},{"post_id":"cjg52i3j000074hfbujr7aben","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3je000h4hfbiry3oqnj"},{"post_id":"cjg52i3j6000b4hfbzipgfbvc","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3jh000k4hfb2nmj5fj1"},{"post_id":"cjg52i3im00024hfb5glkqce2","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3jl000p4hfbai7r5m3p"},{"post_id":"cjg52i3iv00054hfbp7k025h7","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3jq000s4hfb6mr16wtj"},{"post_id":"cjg52i3jl000q4hfbv43zo8wn","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3ju000w4hfbpu3hyqxf"},{"post_id":"cjg52i3ja000d4hfb04yz0x5y","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3jx000z4hfb3v7aow5l"},{"post_id":"cjg52i3ja000d4hfb04yz0x5y","tag_id":"cjg52i3jj000n4hfbij2e2m3q","_id":"cjg52i3k100134hfb8vna93wi"},{"post_id":"cjg52i3ju000x4hfb7rv68v8r","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3k200154hfboko009o1"},{"post_id":"cjg52i3je000i4hfbpx7heewa","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3k300184hfbmhdseksk"},{"post_id":"cjg52i3je000i4hfbpx7heewa","tag_id":"cjg52i3jj000n4hfbij2e2m3q","_id":"cjg52i3k4001a4hfb4kz46tk9"},{"post_id":"cjg52i3jx00104hfb7f78seb4","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3k4001c4hfbivnoc28v"},{"post_id":"cjg52i3jh000l4hfbgoz1vssn","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3k5001e4hfbkytbo2s8"},{"post_id":"cjg52i3jh000l4hfbgoz1vssn","tag_id":"cjg52i3jj000n4hfbij2e2m3q","_id":"cjg52i3k5001g4hfb9hb1w1hw"},{"post_id":"cjg52i3jq000t4hfbzraj3f5v","tag_id":"cjg52i3iu00044hfbsx74lxgn","_id":"cjg52i3k6001h4hfbkvswfr2k"},{"post_id":"cjg52i3jq000t4hfbzraj3f5v","tag_id":"cjg52i3k200174hfb7ilngugf","_id":"cjg52i3k6001i4hfblnjs1zki"}],"Tag":[{"name":"Objective-C","_id":"cjg52i3iu00044hfbsx74lxgn"},{"name":"Runtime","_id":"cjg52i3jj000n4hfbij2e2m3q"},{"name":"Swift","_id":"cjg52i3k200174hfb7ilngugf"}]}}